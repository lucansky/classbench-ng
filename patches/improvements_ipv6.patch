diff --git a/ExtraList.cc b/ExtraList.cc
index d09f0aa..4b309fe 100644
--- a/ExtraList.cc
+++ b/ExtraList.cc
@@ -17,6 +17,7 @@ ExtraList::ExtraList(int P1) {
   for (int i = 1; i <= P; i++){
     // Create header list
     struct ExtraListHeader *temp = new struct ExtraListHeader;
+    temp->field = NULL;
     temp->next = NULL;
     temp->prev = last;
     if (i == 1) {
@@ -39,11 +40,12 @@ ExtraList::~ExtraList() {
     for (int j = 0; j < N; j++){
       tempI = temp->field[j];
       // Delete list of values
-      delete(tempI->value);
-      delete(tempI->prob);
+      delete[] (tempI->value);
+      delete[] (tempI->prob);
+      delete(tempI);
     }
     first = first->next;
-    delete(temp->field);
+    delete[] (temp->field);
     delete(temp);
   }
 }
diff --git a/FilterList.cc b/FilterList.cc
index c123529..4677276 100644
--- a/FilterList.cc
+++ b/FilterList.cc
@@ -11,6 +11,9 @@
 
 #include "stdinc.h"
 #include "FilterList.h"
+#include <network>
+
+namespace ip = std::experimental::net::ip;
 
 FilterList::FilterList() {
   first = last = NULL;
@@ -20,6 +23,9 @@ FilterList::FilterList() {
 FilterList::~FilterList() { 
   struct FilterList_item *temp;
   while (first != NULL) {
+    if (first->filt.num_ext_field > 0) {
+      delete[] (first->filt.ext_field);
+    }
     temp = first->next;
     delete(first);
     first = temp;
@@ -57,7 +63,7 @@ struct FilterList_item* FilterList::operator()(int i) {
 void FilterList::insert(struct FilterList_item *item, struct filter filt) {
   struct FilterList_item *newitem;
   newitem = new struct FilterList_item;
-  newitem->filt = filt;
+  copy_filter(newitem->filt, filt);
   newitem->prev = item->prev;
   newitem->next = item;
   if (first == item) first = newitem;
@@ -72,7 +78,7 @@ void FilterList::insert(struct FilterList_item *item, struct filter filt) {
 void FilterList::operator&=(struct filter filt) {
   struct FilterList_item *temp;
   temp = new struct FilterList_item;
-  temp->filt = filt;
+  copy_filter(temp->filt, filt);
   temp->prev = last;
   temp->next = NULL;
   if (num == 0){
@@ -110,7 +116,7 @@ void FilterList::operator=(FilterList* L) {
 void FilterList::push(struct filter filt) {
   struct FilterList_item *temp;
   temp = new struct FilterList_item;
-  temp->filt = filt;
+  copy_filter(temp->filt, filt);
   temp->next = first;
   temp->prev = NULL;
   if (num == 0){
@@ -125,35 +131,66 @@ void FilterList::push(struct filter filt) {
 
 // Print the contents of the FilterList.
 void FilterList::print(FILE* fp) {
-  int addr[4];
-  unsigned temp;
+  uint128_t temp;
   struct FilterList_item *tempfilt;
   
   for (tempfilt = first; tempfilt != NULL; tempfilt = tempfilt->next){
     // Print new filter character
     fprintf(fp,"@");
-    // Print source address
-    addr[0] = addr[1] = addr[2] = addr[3] = 0;
-    temp = 0;
-    temp = tempfilt->filt.sa;
-    addr[0] = (temp >> 24);
-    addr[1] = ((temp << 8) >> 24);
-    addr[2] = ((temp << 16) >> 24);
-    addr[3] = ((temp << 24) >> 24);
-    fprintf(fp, "%d.%d.%d.%d/%d\t",
-	    addr[0], addr[1], addr[2], addr[3],
-	    tempfilt->filt.sa_len);
-    // Print destination address 
-    addr[0] = addr[1] = addr[2] = addr[3] = 0;
-    temp = 0;
-    temp = tempfilt->filt.da;
-    addr[0] = (temp >> 24);
-    addr[1] = ((temp << 8) >> 24);
-    addr[2] = ((temp << 16) >> 24);
-    addr[3] = ((temp << 24) >> 24);
-    fprintf(fp, "%d.%d.%d.%d/%d\t",
-	    addr[0], addr[1], addr[2], addr[3],
-	    tempfilt->filt.da_len);
+    // Print source/destination addresses
+    if (ADDRLEN == 32) { // IPv4
+       // Source address
+       temp = tempfilt->filt.sa >> 96;
+       ip::address_v4 src_addr(temp);
+       fprintf(fp, "%s/%d\t", src_addr.to_string().c_str(), (tempfilt->filt.sa_len < 32) ? tempfilt->filt.sa_len : 32);
+       // Destination address
+       temp = tempfilt->filt.da >> 96;
+       ip::address_v4 dst_addr(temp);
+       fprintf(fp, "%s/%d\t", dst_addr.to_string().c_str(), (tempfilt->filt.da_len < 32) ? tempfilt->filt.da_len : 32);
+    } else { // IPv6
+       // Source address
+       temp = tempfilt->filt.sa;
+       const ip::address_v6::bytes_type src_temp_bytes_type(
+          (unsigned char) (temp.upper() >> 56),
+          (unsigned char) (temp.upper() >> 48),
+          (unsigned char) (temp.upper() >> 40),
+          (unsigned char) (temp.upper() >> 32),
+          (unsigned char) (temp.upper() >> 24),
+          (unsigned char) (temp.upper() >> 16),
+          (unsigned char) (temp.upper() >>  8),
+          (unsigned char)  temp.upper(),
+          (unsigned char) (temp.lower() >> 56),
+          (unsigned char) (temp.lower() >> 48),
+          (unsigned char) (temp.lower() >> 40),
+          (unsigned char) (temp.lower() >> 32),
+          (unsigned char) (temp.lower() >> 24),
+          (unsigned char) (temp.lower() >> 16),
+          (unsigned char) (temp.lower() >>  8),
+          (unsigned char)  temp.lower());
+       ip::address_v6 src_addr(src_temp_bytes_type);
+       fprintf(fp, "%s/%d\t", src_addr.to_string().c_str(), tempfilt->filt.sa_len);
+       // Destination address
+       temp = tempfilt->filt.da;
+       const ip::address_v6::bytes_type dst_temp_bytes_type(
+          (unsigned char) (temp.upper() >> 56),
+          (unsigned char) (temp.upper() >> 48),
+          (unsigned char) (temp.upper() >> 40),
+          (unsigned char) (temp.upper() >> 32),
+          (unsigned char) (temp.upper() >> 24),
+          (unsigned char) (temp.upper() >> 16),
+          (unsigned char) (temp.upper() >>  8),
+          (unsigned char)  temp.upper(),
+          (unsigned char) (temp.lower() >> 56),
+          (unsigned char) (temp.lower() >> 48),
+          (unsigned char) (temp.lower() >> 40),
+          (unsigned char) (temp.lower() >> 32),
+          (unsigned char) (temp.lower() >> 24),
+          (unsigned char) (temp.lower() >> 16),
+          (unsigned char) (temp.lower() >>  8),
+          (unsigned char)  temp.lower());
+       ip::address_v6 dst_addr(dst_temp_bytes_type);
+       fprintf(fp, "%s/%d\t", dst_addr.to_string().c_str(), tempfilt->filt.da_len);
+    }
     // Print source port 
     fprintf(fp, "%d : %d\t",
 	    tempfilt->filt.sp[0], tempfilt->filt.sp[1]);
diff --git a/FlagList.cc b/FlagList.cc
index 074c4e7..9a214cf 100644
--- a/FlagList.cc
+++ b/FlagList.cc
@@ -27,8 +27,8 @@ FlagList::~FlagList() {
       first[i] = temp;
     }
   }
-  delete(first);
-  delete(last);
+  delete[] (first);
+  delete[] (last);
 }
 
 void FlagList::choose(float p, int prot, unsigned *flags, unsigned *flags_mask){
diff --git a/PortList.cc b/PortList.cc
index 34ad3c2..4b26d15 100644
--- a/PortList.cc
+++ b/PortList.cc
@@ -22,7 +22,7 @@ PortList::PortList(int N1) {
   }
 }
 
-PortList::~PortList() { delete ports; }
+PortList::~PortList() { delete[] ports; }
 
 void PortList::read(int t, FILE *fp) {
   int done = 0;
diff --git a/PrefixList.cc b/PrefixList.cc
index a3df1dc..c3e23e5 100644
--- a/PrefixList.cc
+++ b/PrefixList.cc
@@ -11,21 +11,21 @@
 #include "PrefixList.h"
 
 PrefixList::PrefixList() {
-  N = 65;
+  N = 257;
   cdist = 0;
   prefixes = new struct prefix*[25];
   for (int type = 0; type < 25; type++){
     prefixes[type] = new struct prefix[N];
     for (int i = 0; i < N; i++) {
       prefixes[type][i].prob = 0;
-      for (int j = 0; j < 33; j++) prefixes[type][i].sprob[j] = 0;
+      for (int j = 0; j < 129; j++) prefixes[type][i].sprob[j] = 0;
     }
   }
 }
 
 PrefixList::~PrefixList() {
-  for (int type = 0; type < 25; type++) delete prefixes[type];
-  delete prefixes;
+  for (int type = 0; type < 25; type++) delete[] prefixes[type];
+  delete[] prefixes;
 }
 
 void PrefixList::read(FILE* fp){
@@ -102,14 +102,14 @@ void PrefixList::read_type(int type, FILE *fp) {
   int tlen = 0;
   int slen = 0;
   float prob = 0;
-  int lens[34];
-  float probs[34];
-  char scomm[500];
-  int scomm_len = 500;
+  int lens[130];
+  float probs[130];
+  char scomm[2000];
+  int scomm_len = 2000;
   while (done == 0) {
     fgets(scomm,scomm_len,fp);
     // Read a line of the input
-    matches = sscanf(scomm,"%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f",&lens[0],&probs[0],&lens[1],&probs[1],&lens[2],&probs[2],&lens[3],&probs[3],&lens[4],&probs[4],&lens[5],&probs[5],&lens[6],&probs[6],&lens[7],&probs[7],&lens[8],&probs[8],&lens[9],&probs[9],&lens[10],&probs[10],&lens[11],&probs[11],&lens[12],&probs[12],&lens[13],&probs[13],&lens[14],&probs[14],&lens[15],&probs[15],&lens[16],&probs[16],&lens[17],&probs[17],&lens[18],&probs[18],&lens[19],&probs[19],&lens[20],&probs[20],&lens[21],&probs[21],&lens[22],&probs[22],&lens[23],&probs[23],&lens[24],&probs[24],&lens[25],&probs[25],&lens[26],&probs[26],&lens[27],&probs[27],&lens[28],&probs[28],&lens[29],&probs[29],&lens[30],&probs[30],&lens[31],&probs[31],&lens[32],&probs[32],&lens[33],&probs[33]);
+    matches = sscanf(scomm,"%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f",&lens[0],&probs[0],&lens[1],&probs[1],&lens[2],&probs[2],&lens[3],&probs[3],&lens[4],&probs[4],&lens[5],&probs[5],&lens[6],&probs[6],&lens[7],&probs[7],&lens[8],&probs[8],&lens[9],&probs[9],&lens[10],&probs[10],&lens[11],&probs[11],&lens[12],&probs[12],&lens[13],&probs[13],&lens[14],&probs[14],&lens[15],&probs[15],&lens[16],&probs[16],&lens[17],&probs[17],&lens[18],&probs[18],&lens[19],&probs[19],&lens[20],&probs[20],&lens[21],&probs[21],&lens[22],&probs[22],&lens[23],&probs[23],&lens[24],&probs[24],&lens[25],&probs[25],&lens[26],&probs[26],&lens[27],&probs[27],&lens[28],&probs[28],&lens[29],&probs[29],&lens[30],&probs[30],&lens[31],&probs[31],&lens[32],&probs[32],&lens[33],&probs[33],&lens[34],&probs[34],&lens[35],&probs[35],&lens[36],&probs[36],&lens[37],&probs[37],&lens[38],&probs[38],&lens[39],&probs[39],&lens[40],&probs[40],&lens[41],&probs[41],&lens[42],&probs[42],&lens[43],&probs[43],&lens[44],&probs[44],&lens[45],&probs[45],&lens[46],&probs[46],&lens[47],&probs[47],&lens[48],&probs[48],&lens[49],&probs[49],&lens[50],&probs[50],&lens[51],&probs[51],&lens[52],&probs[52],&lens[53],&probs[53],&lens[54],&probs[54],&lens[55],&probs[55],&lens[56],&probs[56],&lens[57],&probs[57],&lens[58],&probs[58],&lens[59],&probs[59],&lens[60],&probs[60],&lens[61],&probs[61],&lens[62],&probs[62],&lens[63],&probs[63],&lens[64],&probs[64],&lens[65],&probs[65],&lens[66],&probs[66],&lens[67],&probs[67],&lens[68],&probs[68],&lens[69],&probs[69],&lens[70],&probs[70],&lens[71],&probs[71],&lens[72],&probs[72],&lens[73],&probs[73],&lens[74],&probs[74],&lens[75],&probs[75],&lens[76],&probs[76],&lens[77],&probs[77],&lens[78],&probs[78],&lens[79],&probs[79],&lens[80],&probs[80],&lens[81],&probs[81],&lens[82],&probs[82],&lens[83],&probs[83],&lens[84],&probs[84],&lens[85],&probs[85],&lens[86],&probs[86],&lens[87],&probs[87],&lens[88],&probs[88],&lens[89],&probs[89],&lens[90],&probs[90],&lens[91],&probs[91],&lens[92],&probs[92],&lens[93],&probs[93],&lens[94],&probs[94],&lens[95],&probs[95],&lens[96],&probs[96],&lens[97],&probs[97],&lens[98],&probs[98],&lens[99],&probs[99],&lens[100],&probs[100],&lens[101],&probs[101],&lens[102],&probs[102],&lens[103],&probs[103],&lens[104],&probs[104],&lens[105],&probs[105],&lens[106],&probs[106],&lens[107],&probs[107],&lens[108],&probs[108],&lens[109],&probs[109],&lens[110],&probs[110],&lens[111],&probs[111],&lens[112],&probs[112],&lens[113],&probs[113],&lens[114],&probs[114],&lens[115],&probs[115],&lens[116],&probs[116],&lens[117],&probs[117],&lens[118],&probs[118],&lens[119],&probs[119],&lens[120],&probs[120],&lens[121],&probs[121],&lens[122],&probs[122],&lens[123],&probs[123],&lens[124],&probs[124],&lens[125],&probs[125],&lens[126],&probs[126],&lens[127],&probs[127],&lens[128],&probs[128],&lens[129],&probs[129]);
     // printf("matches = %d, tlen = %d, prob = %.4f\n",matches,lens[0],probs[0]);
     if (matches >= 4) {
       // Assign total probability
@@ -155,16 +155,16 @@ void PrefixList::smooth_type(int type, int s){
   double tp[129];
   double sp[129];
   double spj[129];
-  struct prefix temps[65];
+  struct prefix temps[N];
   int tlen, slen;
   int r, start, end;
   int delta;
 
   // printf("this = 0x%08x\n",this);
 
-  for (int i=0; i<65; i++) {
+  for (int i=0; i<N; i++) {
     temps[i].prob = 0;
-    for (int j=0; j<33; j++) {
+    for (int j=0; j<129; j++) {
       temps[i].sprob[j] = 0;
     }
   }
@@ -189,9 +189,9 @@ void PrefixList::smooth_type(int type, int s){
 	tlen = i - s; bdist = 0;
       }
       // printf("tlen = %d, bdist = %d\n",tlen,bdist);
-      while (tlen <= 64 && bdist <= tk) {
+      while (tlen <= 256 && bdist <= tk) {
 
-	if (tlen < 0 || tlen > 64){
+	if (tlen < 0 || tlen > 256){
 	  printf("Error 1 : tlen is out of range, tlen = %d\n",tlen);
 	  exit(1);
 	}
@@ -208,7 +208,7 @@ void PrefixList::smooth_type(int type, int s){
       // Spread spike in source distribution for total distribution i
       skj = ((int)floor((double)s/(double)2)) * 2;
       binomial(skj,spj);
-      for (int j = 0; j <= 32; j++){
+      for (int j = 0; j <= 128; j++){
 	// j = source length
 	// Find source spike
 	if (prefixes[type][i].sprob[j] > 0){
@@ -221,9 +221,9 @@ void PrefixList::smooth_type(int type, int s){
 	    slen = j - skj/2; bdist = 0;
 	  }
 	  // printf("slen = %d, bdist = %d\n",slen,bdist);
-	  while (slen <= 32 && bdist <= skj) {
+	  while (slen <= 128 && bdist <= skj) {
 	    
-	    if (i < 0 || i > 64 || slen < 0 || slen > 32){
+	    if (i < 0 || i > 256 || slen < 0 || slen > 128){
 	      printf("Error 2: i or slen is out of range, i = %d, slen = %d\n",i,slen);
 	      exit(1);
 	    }
@@ -242,7 +242,7 @@ void PrefixList::smooth_type(int type, int s){
 	  for (int m = 1; m <= s; m++) {
 	    // compute total length point
 	    r = i - m;
-	    if (0 <= r && r <= 64) {
+	    if (0 <= r && r <= 256) {
 	      // set start, end points for source distribution
 	      start = j - m;
 	      end = j;
@@ -268,9 +268,9 @@ void PrefixList::smooth_type(int type, int s){
 		bdist = 0;
 	      }
 	      // printf("start = %d, bdist = %d\n",start,bdist);
-	      while (start <= 32 && bdist <= sk) {
+	      while (start <= 128 && bdist <= sk) {
 		
-		if (r < 0 || r > 64 || start < 0 || start > 32){
+		if (r < 0 || r > 256 || start < 0 || start > 128){
 		  printf("Error 3: r or start is out of range, r = %d, start = %d\n",r,start);
 		  exit(1);
 		}
@@ -290,7 +290,7 @@ void PrefixList::smooth_type(int type, int s){
 	  for (int m = 1; m <= s; m++) {
 	    // compute total length point
 	    r = i + m;
-	    if (0 <= r && r <= 64) {
+	    if (0 <= r && r <= 256) {
 	      // set start, end points for source distribution
 	      start = j;
 	      end = j + m;
@@ -315,9 +315,9 @@ void PrefixList::smooth_type(int type, int s){
 		bdist = 0;
 	      }
 	      // printf("start = %d, bdist = %d\n",start,bdist);
-	      while (start <= 32 && bdist <= sk) {
+	      while (start <= 128 && bdist <= sk) {
 		
-		if (r < 0 || r > 64 || start < 0 || start > 32){
+		if (r < 0 || r > 256 || start < 0 || start > 128){
 		  printf("Error 4: r or start is out of range, start = %d, q = %d\n",r,start);
 		  exit(1);
 		}
@@ -345,25 +345,25 @@ void PrefixList::smooth_type(int type, int s){
       temps[i].prob = temps[i].prob / totw;
       if (temps[i].prob > 0) {
 	// Truncate source distribution
-	if (i < 32) {
-	  for (int j = i + 1; j <= 32; j++) temps[i].sprob[j] = 0;
+	if (i < 128) {
+	  for (int j = i + 1; j <= 128; j++) temps[i].sprob[j] = 0;
 	}
-	else if (i > 32) {
-	  for (int j = 0; j < i - 32; j++) temps[i].sprob[j] = 0; 
+	else if (i > 128) {
+	  for (int j = 0; j < i - 128; j++) temps[i].sprob[j] = 0;
 	}
 	// Normalize source distribution
 	tots = 0;
-	for (int j = 0; j <= 32; j++) tots += temps[i].sprob[j]; 
-	for (int j = 0; j <= 32; j++) temps[i].sprob[j] = temps[i].sprob[j] / tots; 
+	for (int j = 0; j <= 128; j++) tots += temps[i].sprob[j];
+	for (int j = 0; j <= 128; j++) temps[i].sprob[j] = temps[i].sprob[j] / tots;
       }
     }
     // Apply adjustments to prefixes data structure
     for (int i = 0; i < N; i++) {
       prefixes[type][i].prob = temps[i].prob;
       if (i == N-1) prefixes[type][i].prob = 1;
-      for (int j = 0; j < 33; j++) {
+      for (int j = 0; j < 129; j++) {
 	prefixes[type][i].sprob[j] = temps[i].sprob[j];
-	if (j == 32) prefixes[type][i].sprob[j] = 1;
+	if (j == 128) prefixes[type][i].sprob[j] = 1;
       }
     }
   }
@@ -382,7 +382,7 @@ struct ppair PrefixList::choose_prefix(int type, float rs, float rt) {
   for (int i = 0; (i < N && done == 0); i++) {
     // printf("rt = %.6f, prefixes[type][%d].prob = %.6f\n",rt,i,prefixes[type][i].prob);
     if (rt <= prefixes[type][i].prob) {
-      for (int j = 0; (j < 33 && done == 0); j++) {
+      for (int j = 0; (j < 129 && done == 0); j++) {
 	// printf("rs = %.6f, prefixes[type][%d].sprob[%d] = %.6f\n",rs,i,j,prefixes[type][i].sprob[j]);
 	if (rs <= prefixes[type][i].sprob[j]){
 	  pair.slen = j;
@@ -407,7 +407,7 @@ void PrefixList::build_cdist() {
       tp = prefixes[type][i].prob;
       // Cummulative source distribution
       sp = 0;
-      for (int j = 0; j < 33; j++){
+      for (int j = 0; j < 129; j++){
 	prefixes[type][i].sprob[j] += sp;
 	sp = prefixes[type][i].sprob[j];
       } 
@@ -421,7 +421,7 @@ void PrefixList::print(int type, FILE *fp) {
   for (int i = 0; i < N; i++){
     if (prefixes[type][i].prob != 0) {
       fprintf(fp,"%d,%.8f",i,prefixes[type][i].prob);
-      for (int j = 0; j <= 32; j++) {
+      for (int j = 0; j <= 128; j++) {
 	if (prefixes[type][i].sprob[j] != 0) {
 	  fprintf(fp,"\t%d,%.8f",j,prefixes[type][i].sprob[j]);
 	}
diff --git a/PrefixList.h b/PrefixList.h
index 2d39529..1df63a2 100644
--- a/PrefixList.h
+++ b/PrefixList.h
@@ -15,7 +15,7 @@
 
 struct prefix {
   float prob;
-  float sprob[33];
+  float sprob[129];
 };
 
 class PrefixList {
diff --git a/ProtList.cc b/ProtList.cc
index a4bc451..b9bd739 100644
--- a/ProtList.cc
+++ b/ProtList.cc
@@ -24,8 +24,8 @@ ProtList::ProtList() {
 }
 
 ProtList::~ProtList() {
-  for (int i = 0; i < 25; i++) delete protocols[i].pt_prob;
-  delete protocols;
+  for (int i = 0; i < 25; i++) delete[] protocols[i].pt_prob;
+  delete[] protocols;
 }
 
 void ProtList::read(FILE *fp) {
diff --git a/README b/README
index 116aac2..f104e85 100644
--- a/README
+++ b/README
@@ -75,17 +75,17 @@ PPC
 10	AR/WC	source port arbitrary range, destination port wildcard
 11	HI/AR	source port [1024:65535], destination port arbitrary range
 12	AR/HI	source port arbitrary range, destination port [1024:65535]
-13	LO/AR	source port [0:1023], destination port arbitrary range
-14	AR/LO	source port arbitrary range, destination port [0:1023]
-15	AR/AR	source port arbitrary range, destination port arbitrary range
-16	WC/EM	source port wildcard, destination port exact match
-17	EM/WC	source port exact match, destination port wildcard
-18	HI/EM	source port [1024:65535], destination port exact match
-19	EM/HI	source port exact match, destination port [1024:65535]
-20	LO/EM	source port [0:1023], destination port exact match
-21	EM/LO	source port exact match, destination port [0:1023]
+13	WC/EM	source port wildcard, destination port exact match
+14	EM/WC	source port exact match, destination port wildcard
+15	HI/EM	source port [1024:65535], destination port exact match
+16	EM/HI	source port exact match, destination port [1024:65535]
+17	LO/AR	source port [0:1023], destination port arbitrary range
+18	AR/LO	source port arbitraty range, destination port [0:1023]
+19	LO/EM	source port [0:1023], destination port exact match
+20	EM/LO	source port exact match, destination port [0:1023]
+21	AR/AR	source port arbitraty range, destination port arbitrary range
 22	AR/EM	source port arbitrary range, destination port exact match
-23	EM/AR	source port exact match, destination port exact match arbitrary range
+23	EM/AR	source port exact match, destination port arbitrary range
 24	EM/EM	source port exact match, destination port exact match
 
 -flags
diff --git a/TupleBST.cc b/TupleBST.cc
index 9163d9b..911f1d5 100644
--- a/TupleBST.cc
+++ b/TupleBST.cc
@@ -17,7 +17,7 @@ TupleBST::TupleBST() {
 
 TupleBST::~TupleBST() {
   if (root != NULL) cleanup(root);
-  delete(ListOfFilterIndexPtrs);
+  delete[] (ListOfFilterIndexPtrs);
 }
 
 void TupleBST::cleanup(TupleBST_item* node){
@@ -34,7 +34,7 @@ void TupleBST::cleanup(TupleBST_item* node){
 
 int TupleBST::scope(FiveTuple* ftuple){
   double scope5d;
-  scope5d = (32 - ftuple->sa_len) + (32 - ftuple->da_len) + (log(ftuple->sp_wid)/log(2)) + (log(ftuple->dp_wid)/log(2)) + (8*(1 - ftuple->prot)) + (1 - ftuple->flag);
+  scope5d = (128 - ftuple->sa_len) + (128 - ftuple->da_len) + (log(ftuple->sp_wid)/log(2)) + (log(ftuple->dp_wid)/log(2)) + (8*(1 - ftuple->prot)) + (1 - ftuple->flag);
   return (int)scope5d;
 }
 
diff --git a/custom_db.cc b/custom_db.cc
index 6f8d193..7515336 100644
--- a/custom_db.cc
+++ b/custom_db.cc
@@ -20,15 +20,61 @@
 #include "redundant_filter_check.h"
 #include "TupleBST.h"
 #include "custom_db.h"
+#include <network>
+#include "ip_prefix.h"
+#include "trie.h"
+#include "filter_graph.h"
+
+namespace ip = std::experimental::net::ip;
+
+
+/*
+ * Transforms a pruned source/destination trie into a set of edges from/to the
+ * 's'/'t' node in the filter graph.
+ * The given trie is recursively traversed. When the traversed node is a prefix
+ * node, adding of the corresponding edge from/to the 's'/'t' node of the
+ * filter graph is triggered. Weight of the added edge is set according to the
+ * number of prefixes represented by the current prefix node.
+ * CAUTION:
+ *    * This function uses recursive calls!
+ * @param node         A pointer to the current trie node.
+ * @param src_trie     The trie node referenced by parameter node belongs to
+ *                     the source trie (TRUE) or the destination trie (FALSE).
+ * @param prefix_str   The prefix represented by the current node encoded as a
+ *                     string of bit values.
+ * @param graph        A pointer to the filter graph object.
+ */
+void trie_to_graph(const trie_node* node, bool src_trie, string prefix_str, Filter_graph* graph) {
+   if (node != NULL) { // non-empty subtree
+      int prefix_count = node->prefixes;
+      if (prefix_count > 0) { // prefix node
+         // add current prefix to the filter graph, either as "s_prefix" or as "t_prefix"
+         IP_prefix prefix(prefix_str, true);
+         if (src_trie) {
+            graph->add_s_prefix(prefix, prefix_count);
+         } else {
+            graph->add_t_prefix(prefix, prefix_count);
+         }
+      }
+      // call this function on both zero and one subtrees
+      trie_to_graph(node->zero, src_trie, prefix_str + "0", graph);
+      trie_to_graph(node->one, src_trie, prefix_str + "1", graph);
+   } else { // empty subtree
+      return;
+   }
+} // end trie_to_graph()
 
 
 int custom_db_gen(int num_filters, FilterList* filters, FILE* fp_in, int smoothness, float addr_scope, float port_scope, int branch){
 
+  // generate 100 times more filters (because of successive trie pruning)
+  int temp_num_filters = num_filters * 100;
+
   printf("Initializing data structures...\n");
   // Read in scale
   int scale = read_scale(fp_in);
   // printf("scale = %d\n",scale);
-  float scale_factor = (float)num_filters/(float)scale;
+  float scale_factor = (float)temp_num_filters/(float)scale;
   // printf("scale_factor = %.4f\n",scale);
 
   // Read protocol parameters, initialize data structure
@@ -80,7 +126,10 @@ int custom_db_gen(int num_filters, FilterList* filters, FILE* fp_in, int smoothn
 
   // Temporary filter
   // struct filter temp_filter;
-  struct filter *temp_filters = new struct filter[num_filters+1];
+  struct filter *temp_filters = new struct filter[temp_num_filters+1];
+  for (int i = 0; i < temp_num_filters+1; i++) {
+    temp_filters[i].num_ext_field = 0;
+  }
   dlist *Flist = new dlist;
   struct range temp_range;
   struct ppair temp_ppair;
@@ -89,7 +138,7 @@ int custom_db_gen(int num_filters, FilterList* filters, FILE* fp_in, int smoothn
   printf("Creating application specifications...\n");
   
   // For all filters:
-  for (int i = 1; i <= num_filters; i++){
+  for (int i = 1; i <= temp_num_filters; i++){
     // Select a protocol via random number
     p = drand48();
     temp_filters[i].prot_num = protL->choose_prot((float)p);
@@ -143,6 +192,8 @@ int custom_db_gen(int num_filters, FilterList* filters, FILE* fp_in, int smoothn
   printf(" \tdone\n");
   // Free up memory
   delete(protL);
+  delete(flagL);
+  delete(extraL);
   delete(sparL);
   delete(spemL);
   delete(dparL);
@@ -180,10 +231,9 @@ int custom_db_gen(int num_filters, FilterList* filters, FILE* fp_in, int smoothn
   }
   // printf("Flist = "); (*Flist).print(stdout); printf("\n");  
   (*Stree).build_tree(Flist,temp_filters);
-  delete(Stree);
   /*
   printf("Flist = "); (*Flist).print(stdout); printf("\n");
-  for (int i = 1; i <= num_filters; i++)
+  for (int i = 1; i <= temp_num_filters; i++)
     printf("filter[%d].sa = %u/%d\n",i,temp_filters[i].sa,temp_filters[i].sa_len);
   */
   printf(" \tdone\n");
@@ -203,13 +253,245 @@ int custom_db_gen(int num_filters, FilterList* filters, FILE* fp_in, int smoothn
 
   (*Dtree).build_tree(Flist,temp_filters);
   // printf("Flist = "); (*Flist).print(stdout); printf("\n");
-  delete(Dtree);
   printf(" \tdone\n");
   
   delete(Flist);
 
+
+// ****************************************************************************
+//  START of IMPROVEMENTS implemented in ClassBench-ng
+// ****************************************************************************
+
+  // transform filter set into filter graph and insert source/destination
+  // prefixes of filters into corresponding tries
+  Filter_graph graph;
+  Trie src_trie;
+  Trie dst_trie;
+  for (int i = 1; i <= temp_num_filters; i++) {
+     graph.add_filter(&(temp_filters[i]));
+     src_trie.insert(IP_prefix(temp_filters[i].sa, temp_filters[i].sa_len));
+     dst_trie.insert(IP_prefix(temp_filters[i].da, temp_filters[i].da_len));
+  }
+
+  // get statistics of source and destination tries
+  trie_stats src_trie_stats, dst_trie_stats;
+  src_trie.get_stats(src_trie_stats);
+  dst_trie.get_stats(dst_trie_stats);
+
+  // initialize data structures for trie-related distributions
+  vector<float> src_prefixes(129,0);
+  vector<float> src_one_child(129,0);
+  vector<float> src_two_children(129,0);
+  vector<float> src_skew(129,0);
+  vector<float> dst_prefixes(129,0);
+  vector<float> dst_one_child(129,0);
+  vector<float> dst_two_children(129,0);
+  vector<float> dst_skew(129,0);
+
+  // get source and destination prefix length distributions
+  // Use prefix length distributions from already generated source and
+  // destination prefix sets as ClassBench-generated rule sets follow them
+  // quite precisely.
+  for (int i = 0; i < 129; i++) {
+     src_prefixes[i] = (float)src_trie_stats.classbench.prefix_lengths[i] /
+                       (float)src_trie_stats.classbench.prefixes;
+     dst_prefixes[i] = (float)dst_trie_stats.classbench.prefix_lengths[i] /
+                       (float)dst_trie_stats.classbench.prefixes;
+  }
+
+  // get other src distributions
+  // Copy the values that were already read from the parameter file into Stree.
+  for (int i = 0; i < 129; i++) {
+     src_one_child[i] = Stree->get_p1child()[i];
+     src_two_children[i] = Stree->get_p2child()[i];
+     src_skew[i] = Stree->get_skew()[i];
+  }
+  delete(Stree);
+
+  // get other dst distributions
+  // Copy the values that were already read from the parameter file into Dtree.
+  for (int i = 0; i < 129; i++) {
+     dst_one_child[i] = Dtree->get_p1child()[i];
+     dst_two_children[i] = Dtree->get_p2child()[i];
+     dst_skew[i] = Dtree->get_skew()[i];
+  }
+  delete(Dtree);
+
+  // prune source and destination tries to 1/100 of the original prefix sets
+  src_trie.prune(num_filters, src_prefixes, src_one_child,
+                 src_two_children, src_skew);
+  dst_trie.prune(num_filters, dst_prefixes, dst_one_child,
+                 dst_two_children, dst_skew);
+
+  // extend filter graph according to pruned tries
+  trie_to_graph(src_trie.get_root(), true, "", &graph);
+  trie_to_graph(dst_trie.get_root(), false, "", &graph);
+
+  // modify the filter graph to conform with the flow network specification
+  graph.to_flow_network();
+
+  // compute maximum flow for the current flow network
+  int max_flow = graph.max_flow();
+
+  // auxiliary variables for construction of the set of pruned filters
+  struct filter* pruned_filters = new struct filter[temp_num_filters+1];
+  for (int i = 0; i < temp_num_filters+1; i++) {
+    pruned_filters[i].num_ext_field = 0;
+  }
+  int pruned_filters_i = 1;
+
+  /*
+   * 1st phase of construction of the set of pruned filters
+   */
+  // iterate over all filters
+  const node_list_item* node;
+  node = graph.get_src_nodes();
+  while (node != NULL) {
+     neighbour_list_item* neighbour = node->neighbours;
+     while (neighbour != NULL) {
+        filter_list_item* filter = neighbour->filters;
+        for (int i = 0; i < neighbour->flow; i++) {
+           // leave the cycle if enough filters have been selected
+           if (pruned_filters_i == num_filters+1) {
+              break;
+           }
+           // copy filters from the maximum flow to the pruned_filters array
+           copy_filter(pruned_filters[pruned_filters_i], *(filter->filter));
+           pruned_filters_i++;
+           filter = filter->next;
+        }
+        // leave the cycle if enough filters have been selected
+        if (pruned_filters_i == num_filters+1) {
+           break;
+        }
+        neighbour = neighbour->next;
+     }
+     // leave the cycle if enough filters have been selected
+     if (pruned_filters_i == num_filters+1) {
+        break;
+     }
+     node = node->next;
+  }
+
+  /*
+   * 2nd phase of construction of the set of pruned filters
+   */
+  // auxiliary variables for looking for not fully utilized source prefixes
+  neighbour_list_item* s_neighbour = (graph.get_s_node() != NULL) ?
+                                     graph.get_s_node()->neighbours : NULL;
+  // iterate over all destination prefixes
+  node = graph.get_dst_nodes();
+  while (node != NULL) {
+     neighbour_list_item* neighbour = node->neighbours;
+     if (neighbour != NULL) {
+        int free_weight = neighbour->weight - neighbour->flow;
+        // auxiliary variables for looking for not fully utilized filters with
+        // current destination prefix
+        const node_list_item* src_node = graph.get_src_nodes();
+        neighbour_list_item* src_neighbour;
+        filter_list_item* src_filter;
+        int src_filter_index = 0;
+        // for each not fully utilized destination prefix
+        for (int i = 0; i < free_weight; i++) {
+           // leave the cycle if enough filters have been selected
+           if (pruned_filters_i == num_filters+1) {
+              break;
+           }
+
+// FILTERS start --------------------------------------------------------------
+
+           // iterate over all filters with current destination prefix
+           while (src_node != NULL) {
+              src_neighbour = src_node->neighbours;
+              while (src_neighbour != NULL) {
+                 if (src_neighbour->node->prefix == node->prefix) {
+                    src_filter = src_neighbour->filters;
+                    // skip over all filters from the maximum flow
+                    for (;
+                         src_filter_index < src_neighbour->flow;
+                         src_filter_index++) {
+                       src_filter = src_filter->next;
+                    }
+                    if (src_filter != NULL) {// this filter is not fully
+                                             // utilized
+
+// SOURCE PREFIXES start ------------------------------------------------------
+
+                       // find the first not fully utilized source prefix
+                       while (s_neighbour != NULL) {
+                          // if this source prefix is not fully utilized
+                          if (s_neighbour->flow < s_neighbour->weight) {
+                             // create local copy of the selected filter and
+                             // modify its source prefix
+                             struct filter pruned_filter;
+                             copy_filter(pruned_filter, *(src_filter->filter));
+                             pruned_filter.sa =
+                                s_neighbour->node->prefix.get_prefix_uint128_t();
+                             pruned_filter.sa_len =
+                                s_neighbour->node->prefix.get_length();
+                             // inset the filter into the pruned_filters array
+                             pruned_filters[pruned_filters_i++] =
+                                pruned_filter;
+                             // increment flow value through used edges
+                             s_neighbour->flow++;
+                             src_neighbour->flow++;
+                             neighbour->flow++;
+                             // terminate looking for the next not fully
+                             // utilized source prefix
+                             break;
+                          }
+                          s_neighbour = s_neighbour->next;
+                       }
+                       // always terminate looking for not fully utilized
+                       // filters because of the following reasons:
+                       //    * if not fully utilized source prefix was found,
+                       //      move to the next not fully utilized destination
+                       //      prefix
+                       //    * if not fully utilized source prefix was not
+                       //      found, terminate inserting filters into the
+                       //      pruned_filters array at all
+                       break;
+
+// SOURCE PREFIES end ---------------------------------------------------------
+
+                    } else { // this filter is fully utilized
+                       src_filter_index = 0;
+                    }
+                 }
+                 src_neighbour = src_neighbour->next;
+              }
+              // if the previous cycle was broken, break also this cycle
+              // (because of the same reasons)
+              if (src_neighbour != NULL) {
+                 break;
+              }
+              src_node = src_node->next;
+           }
+           // if either all filters or prefixes are fully utilized, terminate
+           // looking for not fully utilized filters
+           if ((src_node == NULL) || (s_neighbour == NULL)) {
+              break;
+           }
+
+// FILTERS end ----------------------------------------------------------------
+
+        }
+     }
+     // if all source prefixes are fully utilized or enough filters have been
+     // selected, terminate looking for not fully utilized destination prefixes
+     if ((s_neighbour == NULL) || (pruned_filters_i == num_filters+1)) {
+        break;
+     }
+     node = node->next;
+  }
+
+// ****************************************************************************
+//  END of IMPROVEMENTS implemented in ClassBench-ng
+// ****************************************************************************
+
+
   printf("Removing redundant filters and ordering nested filters...\n");
-  int filter_cnt = remove_redundant_filters(num_filters,filters,temp_filters);
+  int filter_cnt = remove_redundant_filters(pruned_filters_i-1,filters,pruned_filters);
   printf(" \tdone\n");
 
   // Resolve conflicts, throw away filters if necessary
@@ -219,7 +501,16 @@ int custom_db_gen(int num_filters, FilterList* filters, FILE* fp_in, int smoothn
   // printf(" \tdone\n");
 
   // Delete data structures
-  delete(temp_filters);
+  for (int i = 0; i < temp_num_filters+1; i++) {
+    if (temp_filters[i].num_ext_field > 0) {
+      delete[] (temp_filters[i].ext_field);
+    }
+    if (pruned_filters[i].num_ext_field > 0) {
+      delete[] (pruned_filters[i].ext_field);
+    }
+  }
+  delete[] (temp_filters);
+  delete[] (pruned_filters);
   // printf("Done with custom_db\n");
 
   return filter_cnt;
@@ -464,33 +755,64 @@ void select_ports(int port_type, struct filter *temp_filter, PortList *sparL, Po
 }
 
 void fprint_filter(FILE *fp, struct filter *filt){
-  int addr[4];
-  unsigned temp;
+  uint128_t temp;
 
   // Print new filter character
   fprintf(fp,"@");
-  // Print source address
-  addr[0] = addr[1] = addr[2] = addr[3] = 0;
-  temp = 0;
-  temp = filt->sa;
-  addr[0] = (temp >> 24);
-  addr[1] = ((temp << 8) >> 24);
-  addr[2] = ((temp << 16) >> 24);
-  addr[3] = ((temp << 24) >> 24);
-  fprintf(fp, "%d.%d.%d.%d/%d\t",
-	  addr[0], addr[1], addr[2], addr[3],
-	  filt->sa_len);
-  // Print destination address 
-  addr[0] = addr[1] = addr[2] = addr[3] = 0;
-  temp = 0;
-  temp = filt->da;
-  addr[0] = (temp >> 24);
-  addr[1] = ((temp << 8) >> 24);
-  addr[2] = ((temp << 16) >> 24);
-  addr[3] = ((temp << 24) >> 24);
-  fprintf(fp, "%d.%d.%d.%d/%d\t",
-	  addr[0], addr[1], addr[2], addr[3],
-	  filt->da_len);
+  // Print source/destination address
+  if (ADDRLEN == 32) { // IPv4
+     // Source address
+     temp = filt->sa >> 96;
+     ip::address_v4 src_addr(temp);
+     fprintf(fp, "%s/%d\t", src_addr.to_string().c_str(), (filt->sa_len < 32) ? filt->sa_len : 32);
+     // Destination address
+     temp = filt->da >> 96;
+     ip::address_v4 dst_addr(temp);
+     fprintf(fp, "%s/%d\t", dst_addr.to_string().c_str(), (filt->da_len < 32) ? filt->da_len : 32);
+  } else { // IPv6
+     // Source address
+     temp = filt->sa;
+     const ip::address_v6::bytes_type src_temp_bytes_type(
+        (unsigned char) (temp.upper() >> 56),
+        (unsigned char) (temp.upper() >> 48),
+        (unsigned char) (temp.upper() >> 40),
+        (unsigned char) (temp.upper() >> 32),
+        (unsigned char) (temp.upper() >> 24),
+        (unsigned char) (temp.upper() >> 16),
+        (unsigned char) (temp.upper() >>  8),
+        (unsigned char)  temp.upper(),
+        (unsigned char) (temp.lower() >> 56),
+        (unsigned char) (temp.lower() >> 48),
+        (unsigned char) (temp.lower() >> 40),
+        (unsigned char) (temp.lower() >> 32),
+        (unsigned char) (temp.lower() >> 24),
+        (unsigned char) (temp.lower() >> 16),
+        (unsigned char) (temp.lower() >>  8),
+        (unsigned char)  temp.lower());
+     ip::address_v6 src_addr(src_temp_bytes_type);
+     fprintf(fp, "%s/%d\t", src_addr.to_string().c_str(), filt->sa_len);
+     // Destination address
+     temp = filt->da;
+     const ip::address_v6::bytes_type dst_temp_bytes_type(
+        (unsigned char) (temp.upper() >> 56),
+        (unsigned char) (temp.upper() >> 48),
+        (unsigned char) (temp.upper() >> 40),
+        (unsigned char) (temp.upper() >> 32),
+        (unsigned char) (temp.upper() >> 24),
+        (unsigned char) (temp.upper() >> 16),
+        (unsigned char) (temp.upper() >>  8),
+        (unsigned char)  temp.upper(),
+        (unsigned char) (temp.lower() >> 56),
+        (unsigned char) (temp.lower() >> 48),
+        (unsigned char) (temp.lower() >> 40),
+        (unsigned char) (temp.lower() >> 32),
+        (unsigned char) (temp.lower() >> 24),
+        (unsigned char) (temp.lower() >> 16),
+        (unsigned char) (temp.lower() >>  8),
+        (unsigned char)  temp.lower());
+     ip::address_v6 dst_addr(dst_temp_bytes_type);
+     fprintf(fp, "%s/%d\t", dst_addr.to_string().c_str(), filt->da_len);
+  }
   // Print source port 
   fprintf(fp, "%d : %d\t",
 	  filt->sp[0], filt->sp[1]);
diff --git a/db_generator.cc b/db_generator.cc
index 3344759..afa53fb 100644
--- a/db_generator.cc
+++ b/db_generator.cc
@@ -15,6 +15,9 @@
 #include "custom_db.h"
 #include "sys/time.h"
 
+// IP address length in bits (global variable)
+int ADDRLEN = 32;
+
 main(int argc, char *argv[])
 {
   char filename[1024];  
@@ -24,19 +27,20 @@ main(int argc, char *argv[])
   FILE *fp_std; // output file pointer for standard form filter file 
 
   int num_filters = 0; // number of filters 
-  
+
   int smoothness = 0; // precision of database replication 
   float addr_scope = 0; // adjustment to average address scope 
   float port_scope = 0; // adjustment to average port scope 
   
   // Check for correct number of input arguments 
   if (argc > 8 || argc <= 1){
-    fprintf(stderr,"Usage: db_generator -hrb (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+    fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
     fprintf(stderr,"db_generator is a synthetic filter database generator.\n");
-    fprintf(stderr,"Usage: db_generator -hrb (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+    fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
     fprintf(stderr,"\t -h displays help menu\n");
     fprintf(stderr,"\t -r generates a random database\n");
     fprintf(stderr,"\t -b turns on address prefix scaling with database size; note that this alters the skew distribution in the parameter file\n");
+    fprintf(stderr,"\t -6 generates a database with IPv6 5-tuples\n");
     fprintf(stderr,"\t -c generates a custom database using an input parameter file\n");
     fprintf(stderr,"\t <smoothness> is a parameter [0:64] that injects structured randomness\n");
     fprintf(stderr,"\t <address scope> is a parameter [-1.0:1.0] that adjusts the average scope of the address prefix pairs\n");
@@ -65,12 +69,16 @@ main(int argc, char *argv[])
       case 'b':
 	branch = 1;
 	break;
+      case '6':
+	ADDRLEN = 128;
+	break;
       case 'h':
 	fprintf(stderr,"db_generator is a synthetic filter database generator.\n");
-	fprintf(stderr,"Usage: db_generator -hrb (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+	fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
 	fprintf(stderr,"\t -h displays help menu\n");
 	fprintf(stderr,"\t -r generates a random database\n");
 	fprintf(stderr,"\t -b turns on address prefix scaling with database size; note that this alters the skew distribution in the parameter file\n");
+	fprintf(stderr,"\t -6 generates a database with IPv6 5-tuples\n");
 	fprintf(stderr,"\t -c generates a custom database using an input parameter file\n");
 	fprintf(stderr,"\t <smoothness> is a parameter [0:64] that injects structured randomness\n");
 	fprintf(stderr,"\t <address scope> is a parameter [-1.0:1.0] that adjusts the average scope of the address prefixe pairs\n");
@@ -87,7 +95,7 @@ main(int argc, char *argv[])
       }
     }
   }
-  
+
   if (random == 1 && argc == 2){
     num_filters = atoi(argv[0]);
     strcpy(filename,argv[1]);
@@ -99,21 +107,21 @@ main(int argc, char *argv[])
     // printf("smoothness = %d\n",smoothness);
     if (smoothness < 0 || smoothness > 64) {
       fprintf(stderr,"Error smoothness must be a value in the range [0:64]\n");
-      fprintf(stderr,"Usage: db_generator -hr (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+      fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
       exit(1);
     }
     sscanf(argv[3],"%f",&addr_scope);
     // printf("addr_scope = %.4f\n",addr_scope);
     if (addr_scope < -1 || addr_scope > 1) {
       fprintf(stderr,"Error address scope must be a value in the range [-1:1]\n");
-      fprintf(stderr,"Usage: db_generator -hr (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+      fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
       exit(1);
     }
     sscanf(argv[4],"%f",&port_scope);
     // printf("addr_scope = %.4f\n",port_scope);
     if (port_scope < -1 || port_scope > 1) {
       fprintf(stderr,"Error port scope must be a value in the range [-1:1]\n");
-      fprintf(stderr,"Usage: db_generator -hr (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+      fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
       exit(1);
     }
     strcpy(filename,argv[5]);
@@ -121,7 +129,7 @@ main(int argc, char *argv[])
     fp_in = fopen(in_filename,"r");
     if (fp_in == NULL) {fprintf(stderr,"ERROR: cannot open seed file %s\n",in_filename); exit(1);}
   } else {
-    fprintf(stderr,"Usage: db_generator -hr (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+    fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
     exit(1);
   }
 
diff --git a/dbintree.cc b/dbintree.cc
index 9274710..9a53299 100644
--- a/dbintree.cc
+++ b/dbintree.cc
@@ -13,13 +13,13 @@
 
 dbintree::dbintree() {
 // Initialize to graph with N vertices and no edges.
-  skew = new float[33];
-  corr = new float[33];
-  p1child = new float[33];
-  p2child = new float[33];
+  skew = new float[129];
+  corr = new float[129];
+  p1child = new float[129];
+  p2child = new float[129];
   num_tnodes = 0;
   root = NULL;
-  for (int u = 0; u < 33; u++) {
+  for (int u = 0; u < 129; u++) {
     skew[u] = 0;
     corr[u] = 0;
     p1child[u] = 0;
@@ -28,10 +28,10 @@ dbintree::dbintree() {
 }
 
 dbintree::~dbintree() {
-  delete(skew);
-  delete(corr);
-  delete(p1child);
-  delete(p2child);
+  delete[] (skew);
+  delete[] (corr);
+  delete[] (p1child);
+  delete[] (p2child);
   // call recursive node destructor
   if (root != NULL) delete_node(root);
 }
@@ -39,6 +39,7 @@ dbintree::~dbintree() {
 void dbintree::delete_node(struct tnode *me){
   if (me->child0 != NULL) delete_node(me->child0);
   if (me->child1 != NULL) delete_node(me->child1);
+  delete(me->stubList);
   delete(me);
   return;
 }
@@ -99,13 +100,13 @@ void dbintree::read_skew(FILE* fp_in){
     // printf("matches = %d\n",matches);
     // printf("level = %d, skew = %.4f\n",level,skew);
     if (matches == 4) {
-      if (level <= 32) {
+      if (level <= 128) {
 	p1child[level] = p1_t;
 	p2child[level] = p2_t;
 	skew[level] = f_skew;
       }
       else {
-	fprintf(stderr,"Level for destination address skew is greater than 32.\n");
+	fprintf(stderr,"Level for destination address skew is greater than 128.\n");
 	exit(1);
       }
       // printf("Read line: %d\t%.4f\t%.4f\t%.4f\n",level,p1_t,p2_t,f_skew);
@@ -147,7 +148,7 @@ void dbintree::read_corr(FILE* fp_in){
 void dbintree::print_skew(FILE *fp) {
   
   fprintf(fp,"Level\tp1\tp2\tSkew\n");
-  for (int i = 0; i < 33; i++) {
+  for (int i = 0; i < 129; i++) {
     fprintf(fp,"%d\t%.4f\t%.4f\t%.4f\n",
 	    i,p1child[i],p2child[i],skew[i]);
   }
@@ -157,14 +158,14 @@ void dbintree::print_skew(FILE *fp) {
 void dbintree::print_corr(FILE *fp) {
   
   fprintf(fp,"Level\tCorr\n");
-  for (int i = 0; i < 33; i++) {
+  for (int i = 0; i < 129; i++) {
     fprintf(fp,"%d\t%.4f\n",i,corr[i]);
   }
   return;
 }
 
 void dbintree::build_tree(dlist* Flist, struct filter filters[]){
-  unsigned int addr = 0;
+  uint128_t addr = 0;
   // Create copy of list
   dlist *temp_list = new dlist();
   (*temp_list)=(Flist);
@@ -221,7 +222,7 @@ void dbintree::add2child_stublist(struct tnode *node, int dir, int filt){
   return;
 }
 
-void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, struct filter filters[], int CurrNest){
+void dbintree::add_stub(struct tnode *node, uint128_t addr, dlist* Flist, struct filter filters[], int CurrNest){
   int Flist_size = 0;
   int lev = node->lvl;
   
@@ -237,21 +238,21 @@ void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, str
   // printf("Flist_size = %d\n",Flist_size);
   
   double temp;
-  unsigned int sa;
+  uint128_t sa;
 
-  unsigned int addr0, addr1;
+  uint128_t addr0, addr1;
   // Adjust addresses
   if (lev == 0) {
     addr0 = 0;
     addr1 = 1;
-    addr1 = addr1 << 31;
+    addr1 = addr1 << 127;
   } else {
-    addr0 = addr >> (32 - lev);
-    addr0 = addr0 << (32 - lev);
-    addr1 = addr >> (32 - lev);
+    addr0 = addr >> (128 - lev);
+    addr0 = addr0 << (128 - lev);
+    addr1 = addr >> (128 - lev);
     addr1 = addr1 << 1;
     addr1 += 1;
-    addr1 = addr1 << (31 - lev);
+    addr1 = addr1 << (127 - lev);
   }
  
   // Allocate temp_list's
@@ -297,7 +298,7 @@ void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, str
   // printf("Flist_size = %d, tempList: ",Flist_size); tempList->print(stdout); printf("\n");
   // if lev1_flag == 1, dump all lev1 filters to one side
   // printf("lev = %d, MyNest = %d, Nest = %d, lev1_flag = %d\n",lev,MyNest,Nest,lev1_flag);
-  if ((Flist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 31)){
+  if ((Flist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 127)){
     // printf("add_stub: Enforcing nesting limit\n");
     // Add all filters to stublist and let the finish_node process distribute them
     int fptr;
@@ -331,7 +332,7 @@ void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, str
 	// sa_len > lvl
 	// Prevent prefix nesting
 	sa = sa << lev;
-	sa = sa >> 31;
+	sa = sa >> 127;
 	// sa now equals next "bit" of source address
 	if (filters[fptr].sa_len == (lev+1)) {
 	  // Source prefix will be exhausted at next level
@@ -407,7 +408,7 @@ void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, str
   return;
 }
 
-void dbintree::finish_node(struct tnode *node, unsigned int addr, dlist* Flist, struct filter filters[], int CurrNest){
+void dbintree::finish_node(struct tnode *node, uint128_t addr, dlist* Flist, struct filter filters[], int CurrNest){
   int Flist_size = 0;
   int stubList_size = 0;
   int lev = node->lvl;
@@ -479,20 +480,20 @@ void dbintree::finish_node(struct tnode *node, unsigned int addr, dlist* Flist,
 
   double temp;
   int path;
-  unsigned int addr0, addr1;
+  uint128_t addr0, addr1;
 
   // Adjust addresses
   if (lev == 0) {
     addr0 = 0;
     addr1 = 1;
-    addr1 = addr1 << 31;
+    addr1 = addr1 << 127;
   } else {
-    addr0 = addr >> (32 - lev);
-    addr0 = addr0 << (32 - lev);
-    addr1 = addr >> (32 - lev);
+    addr0 = addr >> (128 - lev);
+    addr0 = addr0 << (128 - lev);
+    addr1 = addr >> (128 - lev);
     addr1 = addr1 << 1;
     addr1 += 1;
-    addr1 = addr1 << (31 - lev);
+    addr1 = addr1 << (127 - lev);
   }
   
   // Create an empty list
@@ -519,7 +520,7 @@ void dbintree::finish_node(struct tnode *node, unsigned int addr, dlist* Flist,
     // If at the nesting threshold and list has more than one child,
     //   then split list (allocate all nodes with level == lev1 to one path)
     // printf("lev = %d, MyNest = %d, Nest = %d, lev1_flag = %d\n",lev,MyNest,Nest,lev1_flag);
-    if ((templist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 31)){
+    if ((templist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 127)){
       // Allocate nest_list
       dlist *nest_list = new dlist();
       dlist *other_list = new dlist();
diff --git a/dbintree.h b/dbintree.h
index 5509fc3..d9311b6 100644
--- a/dbintree.h
+++ b/dbintree.h
@@ -33,10 +33,10 @@ class dbintree {
   float *p1child; // probability that a node at a given level has one child
   float *p2child; // probability that a node at a given level has two children
   int num_tnodes; // number of tree nodes 
-  void add_stub(struct tnode *node, unsigned int addr, dlist* Flist, struct filter filters[],int CurrNest);
+  void add_stub(struct tnode *node, uint128_t addr, dlist* Flist, struct filter filters[],int CurrNest);
   void add2child_stublist(struct tnode *node, int dir, int filt);
   void add_node(struct tnode *prnt, int lev, int dir);
-  void finish_node(struct tnode *node, unsigned int addr, dlist* Flist, struct filter filters[],int CurrNest);
+  void finish_node(struct tnode *node, uint128_t addr, dlist* Flist, struct filter filters[],int CurrNest);
   int Nest; // Maximum allowed nesting
 
  public: dbintree();
@@ -51,4 +51,15 @@ class dbintree {
   void print_corr(FILE*); // print correlation per level
   void build_tree(dlist* Flist, struct filter filters[]);
   void lsort();    // sort nodes by level 
+
+  // get methods for selected private members
+  inline float* get_skew() {
+     return skew;
+  };
+  inline float* get_p1child() {
+     return p1child;
+  };
+  inline float* get_p2child() {
+     return p2child;
+  };
 };
diff --git a/filter_graph.cc b/filter_graph.cc
new file mode 100644
index 0000000..726869a
--- /dev/null
+++ b/filter_graph.cc
@@ -0,0 +1,785 @@
+// filter_graph.cc: Filter_graph class definition
+//
+// Jiri Matousek, 2017
+// imatousek@fit.vutbr.cz
+
+
+// User includes
+#include "stdinc.h"
+#include "flow_network.h"
+#include "filter_graph.h"
+
+// Library includes
+#include <queue>
+#include <iostream>
+
+// Default namespace
+using namespace std;
+
+
+// ****************************************************************************
+//                            Function definitions
+// ****************************************************************************
+
+
+// ***** Auxiliary (non-member) functions *************************************
+
+
+/*
+ * Private function that builds a flow network corresponding to the filter
+ * graph.
+ * In three iterations the function traverses all edges of the filter graph
+ * (i.e., s_node->src_nodes, src_nodes->dst_nodes, and dst_nodes->t_node edges)
+ * and constructs the flow network corresponding to this graph. Each edge of
+ * the filter graph can be represented by at most two edges of the flow
+ * network -- a forward and backward edge. Note that they are included into the
+ * flow network only if their residual capacity is greater than zero.
+ * The function expects that the input graph is already a valid flow network,
+ * i.e., it contains only one node without input edges (the 's' node) and only
+ * one node without output edges (the 't' node).
+ * @param network   Reference to the (most probably empty) flow network object.
+ * @param graph     Pointer to the constant filter graph object.
+ */
+void build_flow_network(Flow_network& network, const Filter_graph* graph) {
+   // declatarion of "phase" variables
+   const node_list_item* list;
+   int src_list;
+   int dst_list;
+
+   // iteration through three phases
+   for (int i = 0; i < 3; i++) {
+      // setting of phase variables
+      switch (i) {
+         case 0: // edges from the 's' node to destination nodes
+            list = graph->get_s_node();
+            src_list = 0;
+            dst_list = 1;
+            break;
+         case 1: // edges from source nodes to destination nodes
+            list = graph->get_src_nodes();
+            src_list = 1;
+            dst_list = 2;
+            break;
+         case 2: // edges from destination nodes to the 'd' node
+            list = graph->get_dst_nodes();
+            src_list = 2;
+            dst_list = 3;
+            break;
+      }
+
+      // iteration over all nodes in the list
+      while (list != NULL) {
+         neighbour_list_item* neighbour = list->neighbours;
+         // iteration over all neighbours (i.e., edges of the filter graph)
+         while (neighbour != NULL) {
+            // compute residual capacity of forward and backward edges
+            int capacity_forward = neighbour->weight - neighbour->flow;
+            int capacity_backward = neighbour->flow;
+            // insert the forward edge, if it has capacity > 0
+            if (capacity_forward > 0) {
+               network.add_edge(list->prefix, src_list,
+                                neighbour->node->prefix, dst_list,
+                                neighbour, true, capacity_forward);
+            }
+            // insert the backward edge, if it has capacity > 0
+            if (capacity_backward > 0) {
+               network.add_edge(neighbour->node->prefix, dst_list,
+                                list->prefix, src_list,
+                                neighbour, false, capacity_backward);
+            }
+            // move to the next edge
+            neighbour = neighbour->next;
+         }
+         // move to the next node
+         list = list->next;
+      }
+   }
+} // end build_flow_network()
+
+
+// ***** Private functions ****************************************************
+
+
+/*
+ * Private static function that creates deep copy of the original list.
+ */
+node_list_item* Filter_graph::copy_node_list(const node_list_item* orig) {
+   // initialize pointer to copied node list
+   node_list_item* result = (orig == NULL) ?
+                            NULL :
+                            new node_list_item;
+
+   // node list level of copying
+   node_list_item* copy = result;
+   while (orig != NULL) {
+      // list item members initialization
+      copy->prefix = orig->prefix;
+      copy->pruned = orig->pruned;
+      copy->neighbours = (orig->neighbours == NULL) ?
+                         NULL :
+                         new neighbour_list_item;
+      copy->next   = (orig->next == NULL) ?
+                     NULL :
+                     new node_list_item;
+
+      // neighbour list level of copying
+      neighbour_list_item* orig_neighbours = orig->neighbours;
+      neighbour_list_item* copy_neighbours = copy->neighbours;
+      while (orig_neighbours != NULL) {
+         // list item members initialization
+         copy_neighbours->node = NULL; // cannot be initialized directly
+                                       // (points to different node list)
+         copy_neighbours->weight = orig_neighbours->weight;
+         copy_neighbours->flow = orig_neighbours->flow;
+         copy_neighbours->filters = (orig_neighbours->filters == NULL) ?
+                                    NULL :
+                                    new filter_list_item;
+         copy_neighbours->next = (orig_neighbours->next == NULL) ?
+                                 NULL :
+                                 new neighbour_list_item;
+
+         // filter list level of copying
+         filter_list_item* orig_filters = orig_neighbours->filters;
+         filter_list_item* copy_filters = copy_neighbours->filters;
+         while (orig_filters != NULL) {
+            // list item members initialization
+            copy_filters->filter = orig_filters->filter;
+            copy_filters->next = (orig_filters->next == NULL) ?
+                            NULL :
+                            new filter_list_item;
+            // move to the next item of filter list
+            copy_filters = copy_filters->next;
+            orig_filters = orig_filters->next;
+         }
+
+         // move to the next item of neighbour list
+         copy_neighbours = copy_neighbours->next;
+         orig_neighbours = orig_neighbours->next;
+      }
+
+      // move to the next item of node list
+      copy = copy->next;
+      orig = orig->next;
+   }
+
+   return result;
+} // end copy_node_list()
+
+
+/*
+ * Private static function that correctly deallocates the whole node list.
+ */
+void Filter_graph::remove_node_list(node_list_item** list) {
+   // traverse all nodes
+   while ((*list) != NULL) {
+      // get pointer to the first node
+      node_list_item* first_node = *list;
+
+      // correctly deallocate its whole neighbour list
+      remove_neighbour_list(&(first_node->neighbours));
+
+      // move to the next node list item and deallocate the current one
+      node_list_item* next_node = first_node->next;
+      delete first_node;
+      *list = next_node;
+   }
+} // end remove_node_list()
+
+
+/*
+ * Private static function that correctly deallocates the whole neighbour
+ * list.
+ */
+void Filter_graph::remove_neighbour_list(neighbour_list_item** list) {
+   // traverse all neighbours
+   while ((*list) != NULL) {
+      // get pointer to the first neighbour
+      neighbour_list_item* first_neighbour = *list;
+
+      // correctly deallocate it whole filter list
+      remove_filter_list(&(first_neighbour->filters));
+
+      // move to the next neighbour list item and deallocate the current one
+      neighbour_list_item* next_neighbour = first_neighbour->next;
+      delete first_neighbour;
+      *list = next_neighbour;
+   }
+} // end remove_neighbour_list()
+
+
+/*
+ * Private static function that correctly deallocates the whole filter list.
+ */
+void Filter_graph::remove_filter_list(filter_list_item** list) {
+   // traverse all filters
+   while ((*list) != NULL) {
+      // get pointer to the first filter
+      filter_list_item* first_filter = *list;
+
+      // move to the next filter list item and deallocate the current one
+      filter_list_item* next_filter = first_filter->next;
+      delete first_filter;
+      *list = next_filter;
+   }
+} // end remove_filter_list()
+
+
+/*
+ * Private static function that sets correct values of neighbour node pointers,
+ * which cannot be correctly initialized during copying.
+ */
+void Filter_graph::set_neighbour_nodes(const node_list_item* orig,
+                                             node_list_item* src,
+                                             node_list_item* dst) {
+   // traverse all nodes
+   while (orig != NULL) {
+      neighbour_list_item* orig_neighbours = orig->neighbours;
+      neighbour_list_item* src_neighbours = src->neighbours;
+
+      // traverse all neighbours
+      while (orig_neighbours != NULL) {
+         // set correct neighbour node pointer
+         src_neighbours->node = find_node(orig_neighbours->node->prefix, dst);
+
+         // move to the next item of neighbour list
+         orig_neighbours = orig_neighbours->next;
+         src_neighbours = src_neighbours->next;
+      }
+
+      // move to the next item of node list
+      orig = orig->next;
+      src = src->next;
+   }
+
+   return;
+} // end set_neighbour_nodes()
+
+
+/*
+ * Private static function that looks for node with the given prefix in the
+ * given list of nodes.
+ */
+node_list_item* Filter_graph::find_node(const IP_prefix& prefix,
+                                              node_list_item* list) {
+   // traverse all nodes
+   while (list != NULL) {
+      if (list->prefix == prefix) {
+         // corresponding node - return pointer to it
+         return list;
+      } else {
+         // node with different prefix - move to the next item of node list
+         list = list->next;
+      }
+   }
+
+   // return NULL if corresponding node was not found
+   return NULL;
+} // end find_node()
+
+
+/*
+ * Private static function that looks for the corresponding neighbour node in
+ * the given list of neighbours.
+ */
+neighbour_list_item* Filter_graph::find_neighbour(
+                                      const node_list_item* neighbour,
+                                      neighbour_list_item* list) {
+   // traverse all neighbour nodes
+   while (list != NULL) {
+      if (list->node->prefix == neighbour->prefix) {
+         // corresponding neighbour node - return pointer to it
+         return list;
+      } else {
+         // neighbour node corresponding to different prefix node - move to the
+         // next item of neighbour list
+         list = list->next;
+      }
+   }
+
+   // return NULL if corresponding neighbour node was not found
+   return NULL;
+} // end find_neighbour()
+
+
+/*
+ * Private static function that looks for the filter node pointing to the
+ * specified filter in the given list of filters.
+ */
+filter_list_item* Filter_graph::find_filter(const struct filter* filter,
+                                            filter_list_item* list) {
+   // traverse all filter nodes
+   while (list != NULL) {
+      if (list->filter == filter) {
+         // corresponding filter node - return pointer to it
+         return list;
+      } else {
+         // filter node pointing to different filter - move to the next item of
+         // filter list
+         list = list->next;
+      }
+   }
+
+   // return NULL if corresponding filter node was not found
+   return NULL;
+} // end find_filter()
+
+
+/*
+ * Private static function that inserts a node representing the given IP prefix
+ * at the beginning of the given list of nodes.
+ */
+void Filter_graph::insert_node(const IP_prefix& prefix,
+                               node_list_item** list) {
+   // allocate and initialize new prefix node
+   node_list_item* node = new node_list_item;
+   node->prefix = prefix;
+   node->pruned = false;
+   node->neighbours = NULL;
+
+   // insert new prefix node at the beginning of the list
+   node->next = *list;
+   *list = node;
+
+   return;
+} // end insert_node()
+
+
+/*
+ * Private static function that inserts a neighbour node corresponding to the
+ * given prefix node at the beginning of the given list of neighbour nodes.
+ */
+void Filter_graph::insert_neighbour(node_list_item* neighbour,
+                                    neighbour_list_item** list) {
+   // allocate and initialize new neighbour node
+   neighbour_list_item* node = new neighbour_list_item;
+   node->node = neighbour;
+   node->weight = 0;
+   node->flow = 0;
+   node->filters = NULL;
+
+   // insert new neighbour node at the beginning of the list
+   node->next = *list;
+   *list = node;
+
+   return;
+} // end insert_neighbour()
+
+
+/*
+ * Private static function that inserts a filter node pointing to the given
+ * filter at the beginning of the given list of filter nodes.
+ */
+void Filter_graph::insert_filter(const struct filter* filter,
+                                 filter_list_item** list) {
+   // allocate and initialize new filter node
+   filter_list_item* node = new filter_list_item;
+   node->filter = filter;
+
+   // insert new filter node at the beginning of the list
+   node->next = *list;
+   *list = node;
+
+   return;
+} // end insert_filter()
+
+
+/*
+ * Private static function that prints specified node list, including all
+ * sublists (i.e., neighbour lists and filter lists).
+ */
+void Filter_graph::print_node_list(const node_list_item* nodes) {
+   while (nodes != NULL) {
+      // print node list items
+      cout << "+-> " << nodes->prefix.get_prefix() << "/"
+                     << nodes->prefix.get_length() << endl;
+      neighbour_list_item* neighbours = nodes->neighbours;
+      while (neighbours != NULL) {
+         // print neighbour list items
+         cout << "|   +-> " << neighbours->node->prefix.get_prefix() << "/"
+                            << neighbours->node->prefix.get_length() << " "
+                            << "("
+                            << neighbours->flow << "/"
+                            << neighbours->weight
+                            << ")" << endl;
+         filter_list_item* filters = neighbours->filters;
+         while (filters != NULL) {
+            // print filter list items
+            cout << "|   |   +->  " << filters->filter->sp[0] << ":"
+                                    << filters->filter->sp[1] << " "
+                                    << filters->filter->dp[0] << ":"
+                                    << filters->filter->dp[1] << " "
+                                    << filters->filter->prot_num << endl;
+            // move to the next filter
+            filters = filters->next;
+         }
+         // moce tothe next neighbour
+         neighbours = neighbours->next;
+      }
+      // move to the next node
+      nodes = nodes->next;
+   }
+} // end print_node_list()
+
+
+/*
+ * Private function that removes non-pruned nodes and resets the "pruned"
+ * flag of pruned nodes of the filter graph.
+ */
+void Filter_graph::remove_and_reset() {
+   for (int i = 0; i < 4; i++) {
+      // select the correct node list for iteration
+      node_list_item** node_ptr;
+      switch (i) {
+         case 0:
+            node_ptr = &s_node;
+            break;
+         case 1:
+            node_ptr = &src_nodes;
+            break;
+         case 2:
+            node_ptr = &dst_nodes;
+            break;
+         case 3:
+            node_ptr = &t_node;
+            break;
+      }
+
+      // iterate over all nodes in the list
+      while ((*node_ptr) != NULL) {
+         node_list_item* node = *node_ptr;
+         if (node->pruned == false) { // remove the non-pruned node
+            (*node_ptr) = node->next;
+            delete node;
+         } else { // reset the "pruned" flag of the pruned node
+            node->pruned = false;
+            node_ptr = &(node->next);
+         }
+      }
+   }
+} // end remove_and_reset()
+
+
+// ***** Public functions *****************************************************
+
+
+/*
+ * Default constructor.
+ */
+Filter_graph::Filter_graph() {
+   src_nodes = NULL;
+   dst_nodes = NULL;
+   s_node    = NULL;
+   t_node    = NULL;
+} // end Filter_graph()
+
+
+/*
+ * Copy constructor.
+ */
+Filter_graph::Filter_graph(const Filter_graph& orig) {
+   // acquire members of the original object
+   const node_list_item* orig_src_nodes = orig.get_src_nodes();
+   const node_list_item* orig_dst_nodes = orig.get_dst_nodes();
+   const node_list_item* orig_s_node = orig.get_s_node();
+   const node_list_item* orig_t_node = orig.get_t_node();
+
+   // copy member node lists one by one
+   src_nodes = copy_node_list(orig_src_nodes);
+   dst_nodes = copy_node_list(orig_dst_nodes);
+   s_node = copy_node_list(orig_s_node);
+   t_node = copy_node_list(orig_t_node);
+
+   // set pointers to neighbour nodes
+   set_neighbour_nodes(orig_t_node, t_node, NULL);
+   set_neighbour_nodes(orig_dst_nodes, dst_nodes, t_node);
+   set_neighbour_nodes(orig_src_nodes, src_nodes, dst_nodes);
+   set_neighbour_nodes(orig_s_node, s_node, src_nodes);
+} // end Filter_graph()
+
+
+/*
+ * Destructor.
+ */
+Filter_graph::~Filter_graph() {
+   remove_node_list(&s_node);
+   remove_node_list(&src_nodes);
+   remove_node_list(&dst_nodes);
+   remove_node_list(&t_node);
+} // end ~Filter_graph()
+
+
+/*
+ * Copy assignment.
+ */
+Filter_graph& Filter_graph::operator=(const Filter_graph& copy) {
+   // destruct the original object
+   remove_node_list(&s_node);
+   remove_node_list(&src_nodes);
+   remove_node_list(&dst_nodes);
+   remove_node_list(&t_node);
+
+   // acquire members of the copied object
+   const node_list_item* copy_src_nodes = copy.get_src_nodes();
+   const node_list_item* copy_dst_nodes = copy.get_dst_nodes();
+   const node_list_item* copy_s_node = copy.get_s_node();
+   const node_list_item* copy_t_node = copy.get_t_node();
+
+   // copy member node lists one by one
+   src_nodes = copy_node_list(copy_src_nodes);
+   dst_nodes = copy_node_list(copy_dst_nodes);
+   s_node = copy_node_list(copy_s_node);
+   t_node = copy_node_list(copy_t_node);
+
+   // set pointers to neighbour nodes
+   set_neighbour_nodes(copy_t_node, t_node, NULL);
+   set_neighbour_nodes(copy_dst_nodes, dst_nodes, t_node);
+   set_neighbour_nodes(copy_src_nodes, src_nodes, dst_nodes);
+   set_neighbour_nodes(copy_s_node, s_node, src_nodes);
+
+   // return the original object with new content
+   return *this;
+} // end operator=()
+
+
+/*
+ * Modifies filter graph to add the specified filter into the set of filters
+ * represented by the graph.
+ */
+void Filter_graph::add_filter(const struct filter* filter) {
+   // acquire source and destination prefixes
+   IP_prefix src_pref(filter->sa, filter->sa_len);
+   IP_prefix dst_pref(filter->da, filter->da_len);
+
+   // find source prefix node and insert such node if it does not exist
+   node_list_item* src_node = find_node(src_pref, src_nodes);
+   if (src_node == NULL) {
+      // node is inserted at the beginning of the list
+      insert_node(src_pref, &src_nodes);
+      src_node = src_nodes;
+   }
+
+   // find destination prefix node and insert such node if it does not exist
+   node_list_item* dst_node = find_node(dst_pref, dst_nodes);
+   if (dst_node == NULL) {
+      // node is inserted at the beginning of the list
+      insert_node(dst_pref, &dst_nodes);
+      dst_node = dst_nodes;
+   }
+
+   // find neighbour node corresponding to the filter and insert such node if
+   // it does not exist
+   neighbour_list_item* neighbour = find_neighbour(dst_node,
+                                                   src_node->neighbours);
+   if (neighbour == NULL) {
+      // neighbour is inserted at the beginning of the list
+      insert_neighbour(dst_node, &(src_node->neighbours));
+      neighbour = src_node->neighbours;
+   }
+
+   // find filter node pointing to the specified filter and insert such node if
+   // it does not exist
+   filter_list_item* filter_node = find_filter(filter, neighbour->filters);
+   if (filter_node == NULL) {
+      insert_filter(filter, &(neighbour->filters));
+      neighbour->weight += 1;
+   }
+} // end add_filter()
+
+
+/*
+ * Adds an edge from the 's' node to a node representing the given prefix
+ * within the source nodes list and sets its weight to the given value.
+ */
+void Filter_graph::add_s_prefix(const IP_prefix& prefix, const int weight) {
+   // check existence of the 's' node and allocate it if it does not exist
+   if (s_node == NULL) {
+     insert_node(IP_prefix(), &s_node);
+     s_node->pruned = true;
+   }
+
+   // find a node representing the given prefix within the source nodes list
+   // (existence of such node is not checked since it should always exist)
+   node_list_item* src_node = find_node(prefix, src_nodes);
+
+   // find a neighbour node corresponding to the given prefix
+   neighbour_list_item* neighbour = find_neighbour(src_node,
+                                                   s_node->neighbours);
+   if (neighbour == NULL) { // the neighbour node does not exist
+      // insert the node at the beginning of the list
+      insert_neighbour(src_node, &(s_node->neighbours));
+      neighbour = s_node->neighbours;
+      // set neighbour node's weight member
+      neighbour->weight = weight;
+   } else { // the neighbour node exists
+      // adjust neighbour node's weight member accordingly
+      neighbour->weight += weight;
+   }
+
+   // set source node's pruned flag to true
+   src_node->pruned = true;
+} // end add_s_prefix()
+
+
+/*
+ * Adds an edge from a node representing the given prefix within the
+ * destination nodes list to the 't' node and sets its weight to the given
+ * value.
+ */
+void Filter_graph::add_t_prefix(const IP_prefix& prefix, const int weight) {
+   // check existence of the 't' node and allocate it if it does not exist
+   if (t_node == NULL) {
+     insert_node(IP_prefix(), &t_node);
+     t_node->pruned = true;
+   }
+
+   // find a node representing the given prefix within the destination nodes
+   // list
+   // (existence of such node is not checked since it should always exist)
+   node_list_item* dst_node = find_node(prefix, dst_nodes);
+
+   // find a neighbour node corresponding to the 't' node
+   neighbour_list_item* neighbour = find_neighbour(t_node,
+                                                   dst_node->neighbours);
+   if (neighbour == NULL) { // the neighbour node does not exist
+      // insert the node at the beginning of the list
+      insert_neighbour(t_node, &(dst_node->neighbours));
+      neighbour = dst_node->neighbours;
+      // set neighbour node's weight member
+      neighbour->weight = weight;
+   } else { // the neighbour node exists
+      // adjust neighbour node's weight member accordingly
+      neighbour->weight += weight;
+   }
+
+   // set destination node's pruned flag to true
+   dst_node->pruned = true;
+} // end add_t_prefix()
+
+
+/*
+ * Modifies the filter graph such that it conforms with the flow network
+ * specification -- i.e., it has only one node without input edges (the
+ * 's' node) and only one node without output edges (the 't' node).
+ */
+void Filter_graph::to_flow_network() {
+   // 1) remove filters containing at least one non-pruned prefix
+   node_list_item* node = src_nodes;
+   while (node != NULL) {
+      if (node->pruned == false) { // remove all neighbours of this node
+         remove_neighbour_list(&(node->neighbours));
+      } else { // remove only neighbours pointing to a non-pruned node
+         neighbour_list_item** neighbour_ptr = &(node->neighbours);
+         while ((*neighbour_ptr) != NULL) {
+            neighbour_list_item* neighbour = *neighbour_ptr;
+            if (neighbour->node->pruned == false) { // remove this neighbour
+               remove_filter_list(&(neighbour->filters));
+               *neighbour_ptr = neighbour->next;
+               delete neighbour;
+            } else { // just move to the next neighbour
+               neighbour_ptr = &(neighbour->next);
+            }
+         }
+      }
+      node = node->next;
+   }
+
+   // 2) remove non-pruned nodes and reset the "pruned" flag of other nodes
+   remove_and_reset();
+
+   // 3) BFS to set the "pruned" flag of visited nodes with at least one
+   //    neighbour and the 's' and 't' nodes
+   queue<node_list_item*> q;
+   q.push(s_node);
+   // do the BFS
+   while (!q.empty()) {
+      // dequeue the front element of the queue
+      node_list_item* node = q.front();
+      q.pop();
+      // set the "pruned" flag if the list of neighbours is non-empty
+      if (node->neighbours != NULL) {
+         node->pruned = true;
+      }
+      // insert neighbours into the queue
+      neighbour_list_item* neighbour = node->neighbours;
+      while (neighbour != NULL) {
+         q.push(neighbour->node);
+         neighbour = neighbour->next;
+      }
+   }
+   // set the "pruned" flag of the 's' and 't' nodes
+   s_node->pruned = true;
+   t_node->pruned = true;
+
+   // 4) remove edges from the 's' node going to non-pruned nodes
+   neighbour_list_item** neighbour_ptr = &(s_node->neighbours);
+   while ((*neighbour_ptr) != NULL) {
+      neighbour_list_item* neighbour = *neighbour_ptr;
+      if (neighbour->node->pruned == false) { // remove this edge
+         // there are no filters represented by edges from the 's' node
+         (*neighbour_ptr) = neighbour->next;
+         delete neighbour;
+      } else { // move to the next edge
+         neighbour_ptr = &(neighbour->next);
+      }
+   }
+
+   // 5) remove edges to the 't' node going from non-pruned nodes
+   node = dst_nodes;
+   while (node != NULL) {
+      if (node->pruned == false) { // remove all edges going from this node
+         remove_neighbour_list(&(node->neighbours));
+      }
+      // move to the next node
+      node = node->next;
+   }
+
+   // 6) remove non-pruned nodes (and reset the "pruned" flag of other nodes)
+   remove_and_reset();
+} // end to_flow_network()
+
+
+/*
+ * Computes maximum flow using Dinic's algorithm.
+ */
+int Filter_graph::max_flow() {
+   int max_flow = 0;
+   int flow_inc;
+
+   do { // iterate until the flow cannot be improved
+      // build flow network corresponding to the filter graph
+      Flow_network network;
+      build_flow_network(network, this);
+
+      // transform the flow network into the level graph
+      network.to_level_graph();
+
+      // compute a blocking flow in the flow network and update the flow in the
+      // filter graph accordingly
+      flow_inc = network.find_blocking_flow();
+      max_flow += flow_inc;
+   } while (flow_inc != 0);
+
+   return max_flow;
+} // end max_flow()
+
+
+/*
+ * Prints the filter graph.
+ */
+void Filter_graph::print() {
+   cout << "S_NODE:" << endl;
+   print_node_list(s_node);
+   cout << "--------------------" << endl;
+
+   cout << "SRC_NODES:" << endl;
+   print_node_list(src_nodes);
+   cout << "--------------------" << endl;
+
+   cout << "DST_NODES:" << endl;
+   print_node_list(dst_nodes);
+   cout << "--------------------" << endl;
+
+   cout << "T_NODE:" << endl;
+   print_node_list(t_node);
+   cout << "--------------------" << endl;
+}
diff --git a/filter_graph.h b/filter_graph.h
new file mode 100644
index 0000000..601f2cd
--- /dev/null
+++ b/filter_graph.h
@@ -0,0 +1,437 @@
+// filter_graph.h: header file for Filter_graph class
+//
+// Jiri Matousek, 2017
+// imatousek@fit.vutbr.cz
+
+
+#ifndef FILTER_GRAPH_H
+#define FILTER_GRAPH_H
+
+
+// User includes
+#include "ip_prefix.h"
+
+// Library includes
+
+// Default namespace
+using namespace std;
+
+
+// ****************************************************************************
+//                            Structures declaration
+// ****************************************************************************
+
+
+// Forward declarations (including typedef) to resolve circular dependency
+typedef struct node_list_item node_list_item;
+typedef struct neighbour_list_item neighbour_list_item;
+typedef struct filter_list_item filter_list_item;
+
+/*
+ * A structure representing an item in a list of graph nodes.
+ */
+struct node_list_item {
+   // IP prefix represented by this node
+   IP_prefix prefix;
+
+   // Flag that is utilized for "pruning" filters once the complete filter
+   // graph is constructed
+   bool pruned;
+
+   // List of neighbours
+   neighbour_list_item* neighbours;
+
+   // Next item in list of graph nodes
+   node_list_item* next;
+};
+
+/*
+ * A structure representing an item in a list of neighbours of a graph node.
+ */
+struct neighbour_list_item {
+   // Pointer to neighbour node within list of graph nodes
+   node_list_item* node;
+
+   // Weight of filter graph's edge between neighbouring nodes
+   int weight;
+
+   // Flow through filter graph's edge between neighbouring nodes
+   int flow;
+
+   // List of filters that specify prefixes of neighbouring nodes
+   filter_list_item* filters;
+
+   // Next item in list of neighbours
+   neighbour_list_item* next;
+};
+
+/*
+ * A Structure representing an item in a list of filters that specify prefixes
+ * of neighbouring graph nodes.
+ */
+struct filter_list_item {
+   // Pointer to representation of filter
+   // (struct filter is defined in stdinc.h included in custom_db.cc)
+   const struct filter* filter;
+
+   // Next item in list of filters
+   filter_list_item* next;
+};
+
+
+// ****************************************************************************
+//                              Class declaration
+// ****************************************************************************
+
+/*
+ * Class for representation of a set of filters as a filter graph -- i.e.,
+ * weighted directed bipartite graph with special source (s) and terminate (t)
+ * nodes -- that is constructed according to filters' source and destination
+ * prefixes and pruned source and destination prefix tries.
+ */
+class Filter_graph {
+
+
+   // ***** Private members ***************************************************
+
+
+   private:
+      /*
+       * Lists of source and destination nodes of the filter graph.
+       */
+      node_list_item* src_nodes;
+      node_list_item* dst_nodes;
+
+      /*
+       * Special nodes 's' and 't' of the filter graph.
+       */
+      node_list_item* s_node;
+      node_list_item* t_node;
+
+      /*
+       * Private static function that creates deep copy of the original list.
+       * The function creates new instances of all items from the original list
+       * (as well as all sublists) and sets the value of their components
+       * according to this original list. The only exception is pointer to
+       * neighbour node, which is initialized to NULL (it points to different
+       * list, thus it cannot be initialized to correct value during copying).
+       * @param orig   Pointer to the constant original node list.
+       * @return       Pointer to the copy of the original node list.
+       */
+      static node_list_item* copy_node_list(const node_list_item* orig);
+
+      /*
+       * Private static function that correctly deallocates the whole node
+       * list.
+       * The function traverses the given node list and all its sublists and
+       * starting from the inner-most list it deallocates all the traversed
+       * list items.
+       * @ param list   Pointer to pointer to node list that is to be
+       *                deallocated.
+       */
+      static void remove_node_list(node_list_item** list);
+
+      /*
+       * Private static function that correctly deallocates the whole neighbour
+       * list.
+       * The function traverses the given neighbour list and all its sublists
+       * and starting from the inner-most list it deallocates all the traversed
+       * list items.
+       * @param   Pointer to pointer to the neighbour list that is to be
+       *          deallocated.
+       */
+      static void remove_neighbour_list(neighbour_list_item** list);
+
+      /*
+       * Private static function that correctly deallocates the whole filter
+       * list.
+       * The function traverses the given filter list and deallocates all the
+       * traversed list items.
+       * @param   Pointer to pointer to the filter list that is to be
+       *          deallocated.
+       */
+      static void remove_filter_list(filter_list_item** list);
+
+      /*
+       * Private static function that sets correct values of neighbour node
+       * pointers, which cannot be correctly initialized during copying.
+       * The function simultaneously traverses neighbours lists in orig and src
+       * node lists. For each neighbour node from orig list it looks for
+       * corresponding item in dst node list and stores pointer to this node to
+       * current item in src list.
+       * @param orig   Pointer to the constant original node list.
+       * @param src    Pointer to the list of source nodes (neighbour node
+       *               pointers of this list are set).
+       * @param dst    Pointer to the list of destination nodes (nodes of this
+       *               list act as targets of neighbour node pointers within
+       *               src node list).
+       */
+      static void set_neighbour_nodes(const node_list_item* orig,
+                                            node_list_item* src,
+                                            node_list_item* dst);
+
+// PROBABLY IT IS NOT NECESSARY TO HAVE THIS FUNCTION PRIVATE
+      /*
+       * Private static function that looks for node with the given prefix in
+       * the given list of nodes.
+       * @param prefix   Reference to a constant IP prefix of node that the
+       *                 function looks for in the list.
+       * @param list     Pointer to list of nodes that is traversed during
+       *                 looking for node with the given IP prefix.
+       * @return         Pointer to found node or NULL.
+       */
+      static node_list_item* find_node(const IP_prefix& prefix,
+                                             node_list_item* list);
+
+// PROBABLY IT IS NOT NECESSARY TO HAVE THIS FUNCTION PRIVATE
+      /*
+       * Private static function that looks for the corresponding neighbour
+       * node in the given list of neighbours.
+       * @param neighbour   Pointer to a constant prefix node whose neighbour
+       *                    node the function looks for in the list.
+       * @param list        Pointer to the list of neighbour nodes that is
+       *                    traversed during looking for the node corresponding
+       *                    to the given prefix node.
+       * @return            Pointer to the found neighbour node or NULL.
+       */
+      static neighbour_list_item* find_neighbour(
+                                     const node_list_item* neighbour,
+                                     neighbour_list_item* list);
+
+// PROBABLY IT IS NOT NECESSARY TO HAVE THIS FUNCTION PRIVATE
+      /*
+       * Private static function that looks for the filter node pointing to the
+       * specified filter in the given list of filters.
+       * @param filter   Pointer to the constant filter that is referenced by
+       *                 the filter node the function looks for in the list.
+       * @param list     Pointer to the list of filter nodes that is traversed
+       *                 during looking for a node pointing to the given
+       *                 filter.
+       * @return         Pointer to the found filter node or NULL.
+       */
+      static filter_list_item* find_filter(const struct filter* filter,
+                                           filter_list_item* list);
+
+      /*
+       * Private static function that inserts a node representing the given IP
+       * prefix at the beginning of the given list of nodes.
+       * @param prefix   Reference to a constant IP prefix that is going to be
+       *                 represented by the inserted node.
+       * @param list     Pointer to pointer to the list of nodes that is going
+       *                 to be extended by the inserted node.
+       */
+      static void insert_node(const IP_prefix& prefix,
+                              node_list_item** list);
+
+      /*
+       * Private static function that inserts a neighbour node corresponding to
+       * the given prefix node at the beginning of the given list of
+       * neighbour nodes.
+       * @param neighbour   Pointer to a prefix node whose neighbour node is
+       *                    going to be inserted.
+       * @param list        Pointer to pointer to the list of neighbours that
+       *                    is going to be extended by the inserted node.
+       */
+      static void insert_neighbour(node_list_item* neighbour,
+                                   neighbour_list_item** list);
+
+      /*
+       * Private static function that inserts a filter node pointing to the
+       * given filter at the beginning of the given list of filter nodes.
+       * @param node   Pointer to the constant filter that is going to be
+       *               referenced by the inserted filter node.
+       * @param list   Pointer to pointer to the list of filters that is going
+       *               to be extended by the inserted node.
+       */
+      static void insert_filter(const struct filter* filter,
+                                filter_list_item** list);
+
+      /*
+       * Private static function that prints specified node list, including all
+       * sublists (i.e., neighbour lists and filter lists).
+       * @param nodes   Pointer to the constant list of nodes that is to be
+       *                printed.
+       */
+      static void print_node_list(const node_list_item* nodes);
+
+      /*
+       * Private function that removes non-pruned nodes and resets the "pruned"
+       * flag of pruned nodes of the filter graph.
+       * The function performs the specified function on all nodes of the
+       * filter graph (i.e., source and destination nodes as well as the 's'
+       * and 't' nodes).
+       * The function expects that neighbours list referenced from the
+       * non-pruned nodes have been correctly deallocated before calling this
+       * function.
+       */
+      void remove_and_reset();
+
+
+   // ***** Public members ****************************************************
+
+
+   public:
+      /*
+       * Default constructor.
+       * All pointers are initialized to NULL.
+       */
+      Filter_graph();
+
+      /*
+       * Copy constructor.
+       * All pointers are initialized to a deep copy of corresponding members
+       * of the original object.
+       * @param orig   Reference to the constant original object.
+       */
+      Filter_graph(const Filter_graph& orig);
+
+      /*
+       * Destructor.
+       * Correctly deallocates all lists that are referenced by object members.
+       */
+      ~Filter_graph();
+
+      /*
+       * Copy assignment.
+       * The original object is destructed and its new content is constructed
+       * in similar way as in the copy constructor.
+       * @param copy   Reference to the constant copied object.
+       * @return       Reference to the original object with new content.
+       */
+      Filter_graph& operator= (const Filter_graph& copy);
+
+      /*
+       * Get function for the src_nodes member.
+       * @return   Pointer to the constant list of source nodes.
+       */
+      inline const node_list_item* get_src_nodes() const {
+         return src_nodes;
+      } // end get_src_nodes()
+
+      /*
+       * Get function for the dst_nodes member.
+       * @return   Pointer to the constant list of destination nodes.
+       */
+      inline const node_list_item* get_dst_nodes() const {
+         return dst_nodes;
+      } // end get_dst_nodes()
+
+      /*
+       * Get function for the s_node member.
+       * @return   Pointer to the constant special 's' node.
+       */
+      inline const node_list_item* get_s_node() const {
+         return s_node;
+      } // end get_s_node()
+
+      /*
+       * Get function for the t_node member.
+       * @return   Pointer to the constant special 't' node.
+       */
+      inline const node_list_item* get_t_node() const {
+         return t_node;
+      } // end get_t_node()
+
+      /*
+       * Modifies filter graph to add the specified filter into the set of
+       * filters represented by the graph.
+       * The function searches src_nodes and dst_nodes lists for nodes
+       * representing source and destination prefixes of the given filter and
+       * inserts such nodes into these lists if they are not found. Next, the
+       * function seraches neighbours list of source prefix node for neighbour
+       * node representing destination prefix of the given filter and inserts
+       * such neighbour node into the list if it is not found. Finally, the
+       * function searches filters list of neighbouring node for pointer to the
+       * given filter and inserts such pointer into the list if it is not
+       * found. Along with inserting new filter pointer to the list, the
+       * function increments weight item of neighbouring node representation.
+       * @param filter   Pointer to a constant structure representing inserted
+       *                 filter.
+       */
+      void add_filter(const struct filter* filter);
+
+      /*
+       * Adds an edge from the 's' node to a node representing the given prefix
+       * within the source nodes list and sets its weight to the given value.
+       * First of all, the function checks whether the 's' node has already
+       * been allocated and allocates this node in case it does not yet exist.
+       * Next, the function searches the neighbours list of the 's' node for a
+       * neighbour node representing the given prefix. If such neighbour node
+       * exists, the function just adds the given weight to the current value
+       * of its weight counter. If such neighbour node does not exist, the
+       * function inserts the node into the list and sets its weight counter to
+       * the given value. The function also sets the "pruned" flag of the node
+       * representing the given prefix to true.
+       * The implementation expects that all filters have already been added to
+       * the filter graph and that only prefixes of a pruned source trie are
+       * added using this function. In such a case the source nodes list always
+       * contains a node representing the given prefix.
+       * @param prefix   Reference to the IP_prefix object that determines a
+       *                 target node of the edge from the 's' node.
+       * @param weight   Weight of the newly created edge.
+       */
+      void add_s_prefix(const IP_prefix& prefix, const int weight);
+
+      /*
+       * Adds an edge from a node representing the given prefix within the
+       * destination nodes list to the 't' node and sets its weight to the
+       * given value.
+       * First of all, the function checks whether the 't' node has already
+       * been allocated and allocates this node in case it does not yet exist.
+       * Next, the function searches the neighbours list of the node
+       * representing the given prefix within the destination nodes list for a
+       * neighbour node representing the 't' node. If such neighbour node
+       * exists, the function just adds the given weight to the current value
+       * of its weight counter. If such neighbour node does not exist, the
+       * function inserts the node into the list and sets its weight counter to
+       * the given value. The function also sets the "pruned" flag of the node
+       * representing the given prefix to true.
+       * The implementation expects that all filters have already been added to
+       * the filter graph and that only prefixes of a pruned destination trie
+       * are added using this function. In such a case the destination nodes
+       * list always contains a node representing the given prefix.
+       * @param prefix   Reference to the IP_prefix object that determines a
+       *                 source node of the edge towards the 't' node.
+       * @param weight   Weight of the newly created edge.
+       */
+      void add_t_prefix(const IP_prefix& prefix, const int weight);
+
+      /*
+       * Modifies the filter graph such that it conforms with the flow network
+       * specification -- i.e., it has only one node without input edges (the
+       * 's' node) and only one node without output edges (the 't' node).
+       * First of all, the function removes all edges representing filters with
+       * at least one non-pruned prefix and all nodes representing non-pruned
+       * prefixes. During this step, the "pruned" flag of the remaining nodes
+       * is also set to false. Next, the filter graph is traversed in a BFS
+       * manner and the "pruned" flag is set to true for all visited nodes with
+       * at least one input edge and one output edge. Finally, the function
+       * removes all edges going from the 's' node/to the 't' node that do not
+       * end/start in a node with the set "pruned" flag. These non-pruned nodes
+       * are also removed from the graph in this final step.
+       * The function expects that all steps of the filter graph construction
+       * (i.e., adding filters, s-prefixes, and t-prefixes) have already been
+       * performed before its invocation.
+       */
+      void to_flow_network();
+
+      /*
+       * Computes maximum flow using Dinic's algorithm.
+       * The function builds a flow network corresponding to the filter graph,
+       * transforms it to a level graph and updates the flow through the filter
+       * graph according to a blocking flow through the level graph. This way
+       * the flow through the filter graph is iteratively updated until there
+       * are paths from the 's' node to the 't' node in the level graph.
+       * The flow network is represented by an object of the Flow_network,
+       * which also allows transformation into the corresponding level graph.
+       * @return   The value of the maximum flow through the filter graph.
+       */
+      int max_flow();
+
+      /*
+       * Prints the filter graph.
+       */
+      void print();
+};
+
+#endif
diff --git a/flow_network.cc b/flow_network.cc
new file mode 100644
index 0000000..b5523da
--- /dev/null
+++ b/flow_network.cc
@@ -0,0 +1,592 @@
+// flow_network.cc: Flow_network class definition
+//
+// Jiri Matousek, 2017
+// imatousek@fit.vutbr.cz
+
+
+// User includes
+#include "flow_network.h"
+
+// Library includes
+#include <queue>
+#include <stack>
+#include <list>
+#include <iostream>
+
+// Default namespace
+using namespace std;
+
+
+// ****************************************************************************
+//                            Function definitions
+// ****************************************************************************
+
+
+// ***** Private functions (related to filter graph) **************************
+
+
+/*
+ * Private static function that creates deep copy of the original list.
+ */
+net_node_list_item* Flow_network::copy_node_list(const net_node_list_item* orig) {
+   // initialize pointer to copied node list
+   net_node_list_item* result = (orig == NULL) ?
+                                NULL :
+                                new net_node_list_item;
+
+   // node list level of copying
+   net_node_list_item* copy = result;
+   while (orig != NULL) {
+      // list item members initialization
+      copy->prefix = orig->prefix;
+      copy->visited = orig->visited;
+      copy->neighbours = (orig->neighbours == NULL) ?
+                         NULL :
+                         new net_neighbour_list_item;
+      copy->next = (orig->next == NULL) ?
+                   NULL :
+                   new net_node_list_item;
+
+      // neighbour list level of copying
+      net_neighbour_list_item* orig_neighbours = orig->neighbours;
+      net_neighbour_list_item* copy_neighbours = copy->neighbours;
+      while (orig_neighbours != NULL) {
+         // list item members initialization
+         copy_neighbours->src_node = copy;
+         copy_neighbours->dst_node = NULL; // cannot be initialized directly
+                                           // (points to different node list)
+         copy_neighbours->capacity = orig_neighbours->capacity;
+         copy_neighbours->flow = orig_neighbours->flow;
+         copy_neighbours->orig_edge = orig_neighbours->orig_edge;
+         copy_neighbours->forward_edge = orig_neighbours->forward_edge;
+         copy_neighbours->next = (orig_neighbours->next == NULL) ?
+                                 NULL :
+                                 new net_neighbour_list_item;
+
+         // move to the next item of neighbour list
+         copy_neighbours = copy_neighbours->next;
+         orig_neighbours = orig_neighbours->next;
+      }
+
+      // move to the next item of node list
+      copy = copy->next;
+      orig = orig->next;
+   }
+
+   return result;
+} // end copy_node_list()
+
+
+/*
+ * Private static function that correctly deallocates the whole node list.
+ */
+void Flow_network::remove_node_list(net_node_list_item* list) {
+   // traverse all nodes
+   while (list != NULL) {
+      net_neighbour_list_item* neighbours = list->neighbours;
+
+      // traverse all neighbours
+      while (neighbours != NULL) {
+         // move to the next neighbour list item and deallocate the current one
+         net_neighbour_list_item* current_neighbour = neighbours;
+         neighbours = neighbours->next;
+         delete current_neighbour;
+      }
+
+      // move to the next node list item and deallocate the current one
+      net_node_list_item* current_node = list;
+      list = list->next;
+      delete current_node;
+   }
+
+   return;
+} // end remove_node_list()
+
+
+/*
+ * Private static function that sets correct values of destination node
+ * pointers, which cannot be correctly initialized during copying.
+ */
+void Flow_network::set_destination_nodes(const net_node_list_item* orig,
+                                               net_node_list_item* copy,
+                                               net_node_list_item* prev,
+                                               net_node_list_item* next) {
+   // traverse all nodes
+   while (orig != NULL) {
+      net_neighbour_list_item* orig_neighbours = orig->neighbours;
+      net_neighbour_list_item* copy_neighbours = copy->neighbours;
+
+      // traverse all neighbours
+      while (orig_neighbours != NULL) {
+         // set correct destination node pointer
+         if (orig_neighbours->forward_edge) { // forward edge
+            copy_neighbours->dst_node =
+               find_node(orig_neighbours->dst_node->prefix, next);
+         } else { // backward edge
+            copy_neighbours->dst_node =
+               find_node(orig_neighbours->dst_node->prefix, prev);
+         }
+
+         // move to the next item of neighbour list
+         orig_neighbours = orig_neighbours->next;
+         copy_neighbours = copy_neighbours->next;
+      }
+
+      // move to the next item of node list
+      orig = orig->next;
+      copy = copy->next;
+   }
+
+   return;
+} // end set_destination_nodes()
+
+
+/*
+ * Private static function that looks for node with the given prefix in the
+ * given list of nodes.
+ */
+net_node_list_item* Flow_network::find_node(const IP_prefix& prefix,
+                                            net_node_list_item* list) {
+   // traverse all nodes
+   while (list != NULL) {
+      if (list->prefix == prefix) {
+         // corresponding node - return pointer to it
+         return list;
+      } else {
+         // node with different prefix - move to the next item of node list
+         list = list->next;
+      }
+   }
+
+   // return NULL if corresponding node was not found
+   return NULL;
+} // end find_node()
+
+
+/*
+ * Private static function that looks for the corresponding neighbour node in
+ * the given list of neighbours.
+ */
+net_neighbour_list_item* Flow_network::find_neighbour(
+                                          const net_node_list_item* neighbour,
+                                          net_neighbour_list_item* list) {
+   // traverse all neighbour nodes
+   while (list != NULL) {
+      if (list->dst_node->prefix == neighbour->prefix) {
+         // corresponding neighbour node - return pointer to it
+         return list;
+      } else {
+         // neighbour node corresponding to different prefix node - move to the
+         // next item of neighbour list
+         list = list->next;
+      }
+   }
+
+   // return NULL if corresponding neighbour node was not found
+   return NULL;
+} // end find_neighbour()
+
+
+/*
+ * Private static function that inserts a node representing the given IP prefix
+ * at the beginning of the given list of nodes.
+ */
+void Flow_network::insert_node(const IP_prefix& prefix,
+                               net_node_list_item** list) {
+   // allocate and initialize new prefix node
+   net_node_list_item* node = new net_node_list_item;
+   node->prefix = prefix;
+   node->visited = false;
+   node->neighbours = NULL;
+
+   // insert new prefix node at the beginning of the list
+   node->next = *list;
+   *list = node;
+
+   return;
+} // end insert_node()
+
+
+/*
+ * Private static function that inserts a neighbour node representing an edge
+ * between the given source and destination nodes at the beginning of the
+ * specified list of neighbour nodes.
+ */
+void Flow_network::insert_neighbour(net_node_list_item* src_node,
+                                    net_node_list_item* dst_node,
+                                    int capacity,
+                                    int flow,
+                                    neighbour_list_item* orig_edge,
+                                    bool forward_edge,
+                                    net_neighbour_list_item** list) {
+   // allocate and initialize new neighbour node
+   net_neighbour_list_item* node = new net_neighbour_list_item;
+   node->src_node = src_node;
+   node->dst_node = dst_node;
+   node->capacity = capacity;
+   node->flow = flow;
+   node->orig_edge = orig_edge;
+   node->forward_edge = forward_edge;
+
+   // insert new neighbour node at the beginning of the list
+   node->next = *list;
+   *list = node;
+
+   return;
+} // end insert_neighbour()
+
+
+/*
+ * Private static function that prints specified node list, including all
+ * sublists.
+ */
+void Flow_network::print_node_list(const net_node_list_item* nodes) {
+   while (nodes != NULL) {
+      // print node list items
+      cout << "+-> " << nodes->prefix.get_prefix() << "/"
+                     << nodes->prefix.get_length() << endl;
+      net_neighbour_list_item* neighbours = nodes->neighbours;
+      while (neighbours != NULL) {
+         // print neighbour list items
+         cout << "|   +-> ";
+         if (neighbours->forward_edge) { // forward edge
+            cout << "FORWARD: ";
+         } else { // backward edge
+            cout << "BACKWARD: ";
+         }
+         cout  << neighbours->src_node->prefix.get_prefix() << "/"
+               << neighbours->src_node->prefix.get_length()
+               << " --> "
+               << neighbours->dst_node->prefix.get_prefix() << "/"
+               << neighbours->dst_node->prefix.get_length()
+               << " "
+               << "("
+               << neighbours->flow << "/"
+               << neighbours->capacity
+               << ")" << endl;
+         // move to the next neighbour
+         neighbours = neighbours->next;
+      }
+      // move to the next node
+      nodes = nodes->next;
+   }
+} // end print_node_list()
+
+
+// ***** Public functions *****************************************************
+
+
+/*
+ * Default constructor.
+ */
+Flow_network::Flow_network() {
+   src_nodes = NULL;
+   dst_nodes = NULL;
+   s_node    = NULL;
+   t_node    = NULL;
+} // end Flow_network()
+
+
+/*
+ * Copy constructor.
+ */
+Flow_network::Flow_network(const Flow_network& orig) {
+   // acquire members of the original object
+   const net_node_list_item* orig_src_nodes = orig.get_src_nodes();
+   const net_node_list_item* orig_dst_nodes = orig.get_dst_nodes();
+   const net_node_list_item* orig_s_node = orig.get_s_node();
+   const net_node_list_item* orig_t_node = orig.get_t_node();
+
+   // copy member node lists one by one
+   src_nodes = copy_node_list(orig_src_nodes);
+   dst_nodes = copy_node_list(orig_dst_nodes);
+   s_node = copy_node_list(orig_s_node);
+   t_node = copy_node_list(orig_t_node);
+
+   // set pointers to neighbour nodes
+   set_destination_nodes(orig_t_node, t_node, dst_nodes, NULL);
+   set_destination_nodes(orig_dst_nodes, dst_nodes, src_nodes, t_node);
+   set_destination_nodes(orig_src_nodes, src_nodes, s_node, dst_nodes);
+   set_destination_nodes(orig_s_node, s_node, NULL, src_nodes);
+} // end Filter_graph()
+
+
+/*
+ * Copy assignment.
+ */
+Flow_network& Flow_network::operator=(const Flow_network& copy) {
+   // destruct the original object
+   remove_node_list(s_node);
+   remove_node_list(src_nodes);
+   remove_node_list(dst_nodes);
+   remove_node_list(t_node);
+
+   // acquire members of the copied object
+   const net_node_list_item* copy_src_nodes = copy.get_src_nodes();
+   const net_node_list_item* copy_dst_nodes = copy.get_dst_nodes();
+   const net_node_list_item* copy_s_node = copy.get_s_node();
+   const net_node_list_item* copy_t_node = copy.get_t_node();
+
+   // copy member node lists one by one
+   src_nodes = copy_node_list(copy_src_nodes);
+   dst_nodes = copy_node_list(copy_dst_nodes);
+   s_node = copy_node_list(copy_s_node);
+   t_node = copy_node_list(copy_t_node);
+
+   // set pointers to neighbour nodes
+   set_destination_nodes(copy_t_node, t_node, dst_nodes, NULL);
+   set_destination_nodes(copy_dst_nodes, dst_nodes, src_nodes, t_node);
+   set_destination_nodes(copy_src_nodes, src_nodes, s_node, dst_nodes);
+   set_destination_nodes(copy_s_node, s_node, NULL, src_nodes);
+
+   // return the original object with new content
+   return *this;
+} // end operator=()
+
+
+/*
+ * Destructor.
+ */
+Flow_network::~Flow_network() {
+   remove_node_list(s_node);
+   remove_node_list(src_nodes);
+   remove_node_list(dst_nodes);
+   remove_node_list(t_node);
+} // end ~Flow_network()
+
+
+/*
+ * Adds an edge to the flow network.
+ */
+void Flow_network::add_edge(const IP_prefix& src_prefix, int src_list,
+                            const IP_prefix& dst_prefix, int dst_list,
+                            neighbour_list_item* orig_edge, bool forward_edge,
+                            int capacity) {
+   // get pointer to correct source node list pointer
+   net_node_list_item** src_list_ptr;
+   switch (src_list) {
+      case 0 :
+         src_list_ptr = &s_node;
+         break;
+      case 1 :
+         src_list_ptr = &src_nodes;
+         break;
+      case 2 :
+         src_list_ptr = &dst_nodes;
+         break;
+      case 3 :
+         src_list_ptr = &t_node;
+         break;
+   }
+
+   // get pointer to correct destination node list pointer
+   net_node_list_item** dst_list_ptr;
+   switch (dst_list) {
+      case 0 :
+         dst_list_ptr = &s_node;
+         break;
+      case 1 :
+         dst_list_ptr = &src_nodes;
+         break;
+      case 2 :
+         dst_list_ptr = &dst_nodes;
+         break;
+      case 3 :
+         dst_list_ptr = &t_node;
+         break;
+   }
+
+   // find source prefix node in the specified node list and insert such node
+   // if it does not exist
+   net_node_list_item* src_node = find_node(src_prefix, *src_list_ptr);
+   if (src_node == NULL) {
+      // node is inserted at the beginning of the list
+      insert_node(src_prefix, src_list_ptr);
+      src_node = *src_list_ptr;
+   }
+
+   // find destination prefix node in the specified node list and insert such node
+   // if it does not exist
+   net_node_list_item* dst_node = find_node(dst_prefix, *dst_list_ptr);
+   if (dst_node == NULL) {
+      // node is inserted at the beginning of the list
+      insert_node(dst_prefix, dst_list_ptr);
+      dst_node = *dst_list_ptr;
+   }
+
+   // find neighbour node corresponding to the filter and insert such node if
+   // it does not exist
+   net_neighbour_list_item* neighbour = find_neighbour(dst_node,
+                                                       src_node->neighbours);
+   if (neighbour == NULL) {
+      // neighbour is inserted at the beginning of the list
+      insert_neighbour(src_node, dst_node, capacity, 0, orig_edge,
+                       forward_edge, &(src_node->neighbours));
+   }
+} // end add_edge()
+
+
+/*
+ * Transforms the flow network into a level graph.
+ */
+void Flow_network::to_level_graph() {
+
+   // initialize auxiliary variables
+   queue<net_node_list_item*> q;
+   stack<net_neighbour_list_item**> s;
+   if (s_node != NULL) {
+      s_node->visited = true;
+      q.push(s_node);
+   }
+
+   // do a breadth-first search
+   while (!q.empty()) {
+      // dequeue the front element of the queue
+      net_node_list_item* node = q.front();
+      q.pop();
+      // iterate through the list of node's neighbours
+      net_neighbour_list_item** neighbour_ptr = &(node->neighbours);
+      while ((*neighbour_ptr) != NULL) {
+         // push a pointer to a pointer to the edge on the stack
+         s.push(neighbour_ptr);
+         // if it has not been visited yet, enqueue a pointer to the target
+         // node of this edge
+         if ((*neighbour_ptr)->dst_node->visited == false) {
+            (*neighbour_ptr)->dst_node->visited = true;
+            q.push((*neighbour_ptr)->dst_node);
+         }
+         // move to the next neighbour
+         neighbour_ptr = &((*neighbour_ptr)->next);
+      }
+   }
+
+   // initialize a set of level graph nodes with the 't' node
+   list<net_node_list_item*> l;
+   l.push_front(t_node);
+
+   // do an inverse breadth-first search
+   while (!s.empty()) {
+      // pop the top element of the stack
+      net_neighbour_list_item** neighbour_ptr = s.top();
+      s.pop();
+      // check if the dst_node already belongs to the level graph
+      net_node_list_item* dst_node = (*neighbour_ptr)->dst_node;
+      list<net_node_list_item*>::iterator i;
+      for (i = l.begin(); i != l.end(); ++i) {
+         if (*i == dst_node) {
+            break;
+         }
+      }
+      if (i != l.end()) { // dst_node belongs to the level graph
+         // add also src_node to the level graph
+         l.push_front((*neighbour_ptr)->src_node);
+      } else { // dst_node does not belong to the level graph
+         // remove the edge from the flow network
+         net_neighbour_list_item* edge = (*neighbour_ptr);
+         *neighbour_ptr = (*neighbour_ptr)->next;
+         delete edge;
+      }
+   }
+} // end to_level_graph()
+
+
+/*
+ * Finds a blocking flow in the flow network, adds its value to the
+ * current flow in the corresponding filter graph, and also returns its
+ * value.
+ */
+int Flow_network::find_blocking_flow() {
+   // check if the flow network exists at all
+   if (s_node == NULL) {
+      return 0;
+   }
+
+   int blocking_flow = 0;
+   while (1) { // inifinite loop with return statement inside
+      // initialize auxiliary variables
+      stack<net_neighbour_list_item**> s;
+      stack<int> s_capacity;
+      net_node_list_item* node = s_node;
+      // do a depth-first search
+      while (node != t_node) {
+         while (node->neighbours == NULL) { // no output edges - traverse back
+            if (s.empty()) { // the stack is empty - no way to traverse back
+               return blocking_flow;
+            }
+            // traverse back along the edge on the top of the stack
+            net_neighbour_list_item** neighbour_ptr = s.top();
+            net_neighbour_list_item* neighbour = *neighbour_ptr;
+            node = neighbour->src_node;
+            // pop the top elements of both stacks
+            s.pop();
+            s_capacity.pop();
+            // remove back-traversed edge
+            *neighbour_ptr = neighbour->next;
+            delete neighbour;
+         }
+         // push the first edge of the current node and its remaining capacity on
+         // the respective stacks
+         s.push(&(node->neighbours));
+         s_capacity.push(node->neighbours->capacity - node->neighbours->flow);
+         // move forward along the edge - update the current node
+         node = node->neighbours->dst_node;
+      }
+
+      // determine the smallest capacity among edges of the found path
+      int min_capacity = s_capacity.top();
+      s_capacity.pop();
+      while (!s_capacity.empty()) {
+         // pop the top element of the capacity stack
+         int capacity = s_capacity.top();
+         s_capacity.pop();
+         if (capacity < min_capacity) { // update the smallest capacity
+            min_capacity = capacity;
+         }
+      }
+
+      // update the flow through the found path according to min_capacity value
+      while (!s.empty()) {
+         // pop the top element of the stack
+         net_neighbour_list_item** neighbour_ptr = s.top();
+         s.pop();
+         // update the flow in both the flow network and filter graph
+         net_neighbour_list_item* neighbour = *neighbour_ptr;
+         neighbour->flow += min_capacity;
+         if (neighbour->forward_edge) { // forward edge
+            neighbour->orig_edge->flow += min_capacity;
+         } else { // backward edge
+            neighbour->orig_edge->flow -= min_capacity;
+         }
+         // remove the edge if its remaining capacity decreases to 0
+         if (neighbour->capacity == neighbour->flow) {
+            *neighbour_ptr = neighbour->next;
+            delete neighbour;
+         }
+      }
+
+      // update the value of blocking flow through the flow network
+      blocking_flow += min_capacity;
+   }
+} // end find_blocking_flow()
+
+
+/*
+ * Prints the flow network.
+ */
+void Flow_network::print() {
+   cout << "S_NODE:" << endl;
+   print_node_list(s_node);
+   cout << "--------------------" << endl;
+
+   cout << "SRC_NODES:" << endl;
+   print_node_list(src_nodes);
+   cout << "--------------------" << endl;
+
+   cout << "DST_NODES:" << endl;
+   print_node_list(dst_nodes);
+   cout << "--------------------" << endl;
+
+   cout << "T_NODE:" << endl;
+   print_node_list(t_node);
+   cout << "--------------------" << endl;
+}
diff --git a/flow_network.h b/flow_network.h
new file mode 100644
index 0000000..df76c3f
--- /dev/null
+++ b/flow_network.h
@@ -0,0 +1,362 @@
+// flow_network.h: header file for Flow_network class
+//
+// Jiri Matousek, 2017
+// imatousek@fit.vutbr.cz
+
+
+#ifndef FLOW_NETWORK_H
+#define FLOW_NETWORK_H
+
+
+// User includes
+#include "ip_prefix.h"
+#include "filter_graph.h"
+
+// Library includes
+
+// Default namespace
+using namespace std;
+
+
+// ****************************************************************************
+//                            Structures declaration
+// ****************************************************************************
+
+
+// Forward declarations (including typedef) to resolve circular dependency
+typedef struct net_node_list_item net_node_list_item;
+typedef struct net_neighbour_list_item net_neighbour_list_item;
+
+/*
+ * A structure representing an item in a list of network nodes.
+ */
+struct net_node_list_item {
+   // IP prefix represented by this node
+   IP_prefix prefix;
+
+   // Flag showing whether the node was already visited during a traversal
+   bool visited;
+
+   // List of neighbours
+   net_neighbour_list_item* neighbours;
+
+   // Next item in list of network nodes
+   net_node_list_item* next;
+};
+
+/*
+ * A structure representing an item in a list of neighbours of a network node.
+ */
+struct net_neighbour_list_item {
+   // Pointer to source node within list of network nodes
+   net_node_list_item* src_node;
+
+   // Pointer to destination node within list of network nodes
+   net_node_list_item* dst_node;
+
+   // Residual capacity of flow network's edge between neighbouring nodes
+   int capacity;
+
+   // Flow through flow network's edge between neighbouring nodes
+   int flow;
+
+   // Pointer to corresponding edge in filter graph
+   // (the pointer is the same for both forward and backward edges)
+   neighbour_list_item* orig_edge;
+
+   // Flag showing whether this node represents a forward edge
+   bool forward_edge;
+
+   // Next item in list of neighbours
+   net_neighbour_list_item* next;
+};
+
+
+// ****************************************************************************
+//                              Class declaration
+// ****************************************************************************
+
+/*
+ * Class for representation of a flow network -- i.e., weighted directed graph
+ * with special source (s) and terminate (t) nodes -- over a filter graph.
+ */
+class Flow_network {
+
+
+   // ***** Private members ***************************************************
+
+
+   private:
+      /*
+       * Lists of source and destination nodes of the flow network.
+       */
+      net_node_list_item* src_nodes;
+      net_node_list_item* dst_nodes;
+
+      /*
+       * Special nodes 's' and 't' of the flow network.
+       */
+      net_node_list_item* s_node;
+      net_node_list_item* t_node;
+
+      /*
+       * Private static function that creates a deep copy of the original list.
+       * The function creates new instances of all items from the original list
+       * (as well as their neighbours sublists) and sets the value of their
+       * components according to this original list. The only exception is a
+       * pointer to destination node, which is initialized to NULL (it points
+       * to different list, thus it cannot be initialized to correct value
+       * during copying).
+       * @param orig   Pointer to the constant original node list.
+       * @return       Pointer to the copy of the original node list.
+       */
+      static net_node_list_item* copy_node_list(const net_node_list_item* orig);
+
+      /*
+       * Private static function that correctly deallocates the whole node
+       * list.
+       * The function traverses the given list and all its sublists and
+       * starting from lists of neighbours it deallocates all the traversed
+       * list items.
+       * @ param list   Pointer to node list that is to be deallocated.
+       */
+      static void remove_node_list(net_node_list_item* list);
+
+      /*
+       * Private static function that sets correct values of destination node
+       * pointers, which cannot be correctly initialized during copying.
+       * The function simultaneously traverses neighbours lists in the orig and
+       * copy node lists. For each destination node from the orig list it looks
+       * for a corresponding item in either prev (backward edges) or next
+       * (forward edges) node list and stores the pointer to this node to the
+       * current item in the copy list.
+       * @param orig   Pointer to the constant original node list.
+       * @param copy   Pointer to the copy of the original node list
+       *               (destination node pointers of this list are set).
+       * @param prev   Pointer to the list of destination nodes of backward
+       *               edges.
+       * @param next   Pointer to the list of destination nodes of forward
+       *               edges.
+       */
+      static void set_destination_nodes(const net_node_list_item* orig,
+                                              net_node_list_item* copy,
+                                              net_node_list_item* prev,
+                                              net_node_list_item* next);
+
+// PROBABLY IT IS NOT NECESSARY TO HAVE THIS FUNCTION PRIVATE
+      /*
+       * Private static function that looks for a node with the given prefix in
+       * the given list of nodes.
+       * @param prefix   Reference to a constant IP prefix of the node that the
+       *                 function looks for in the list.
+       * @param list     Pointer to the list of nodes that is traversed during
+       *                 looking for the node with the given IP prefix.
+       * @return         Pointer to the found node or NULL.
+       */
+      static net_node_list_item* find_node(const IP_prefix& prefix,
+                                                 net_node_list_item* list);
+
+// PROBABLY IT IS NOT NECESSARY TO HAVE THIS FUNCTION PRIVATE
+      /*
+       * Private static function that looks for the corresponding neighbour
+       * node in the given list of neighbours.
+       * @param neighbour   Pointer to a constant prefix node whose neighbour
+       *                    node the function looks for in the list.
+       * @param list        Pointer to the list of neighbour nodes that is
+       *                    traversed during looking for the node corresponding
+       *                    to the given prefix node.
+       * @return            Pointer to the found neighbour node or NULL.
+       */
+      static net_neighbour_list_item* find_neighbour(
+                                         const net_node_list_item* neighbour,
+                                         net_neighbour_list_item* list);
+
+      /*
+       * Private static function that inserts a node representing the given IP
+       * prefix at the beginning of the given list of nodes.
+       * @param prefix   Reference to a constant IP prefix that is going to be
+       *                 represented by the inserted node.
+       * @param list     Pointer to pointer to the list of nodes that is going
+       *                 to be extended by the inserted node.
+       */
+      static void insert_node(const IP_prefix& prefix,
+                              net_node_list_item** list);
+
+      /*
+       * Private static function that inserts a neighbour node representing an
+       * edge between the given source and destination nodes at the beginning
+       * of the specified list of neighbour nodes.
+       * @param src_node       Pointer to a source node of the represented
+       *                       edge.
+       * @param dst_node       Pointer to a destination node of the represented
+       *                       edge.
+       * @param capacity       Residual capacity of the represented edge.
+       * @param flow           Flow through the represented edge.
+       * @param orig_edge      Pointer to the corresponding edge in the filter
+       *                       graph.
+       * @param forward_edge   Flag showing whether the inserted neighbour
+       *                       represents a forward edge.
+       * @param list           Pointer to pointer to the list of neighbours
+       *                       that is going to be extended by the inserted
+       *                       node.
+       */
+      static void insert_neighbour(net_node_list_item* src_node,
+                                   net_node_list_item* dst_node,
+                                   int capacity,
+                                   int flow,
+                                   neighbour_list_item* orig_edge,
+                                   bool forward_edge,
+                                   net_neighbour_list_item** list);
+
+      /*
+       * Private static function that prints specified node list, including all
+       * sublists.
+       * @param nodes   Pointer to the constant list of nodes that is to be
+       *                printed.
+       */
+      static void print_node_list(const net_node_list_item* nodes);
+
+
+   // ***** Public members ****************************************************
+
+
+   public:
+      /*
+       * Default constructor.
+       * All pointers are initialized to NULL.
+       */
+      Flow_network();
+
+      /*
+       * Copy constructor.
+       * All pointers used by the filter graph are initialized to a deep copy
+       * of corresponding members of the original object.
+       * @param orig   Reference to the constant original object.
+       */
+      Flow_network(const Flow_network& orig);
+
+      /*
+       * Copy assignment.
+       * The original object is destructed and its new content is constructed
+       * in a similar way as in the copy constructor.
+       * @param copy   Reference to the constant copied object.
+       * @return       Reference to the original object with new content.
+       */
+      Flow_network& operator= (const Flow_network& copy);
+
+      /*
+       * Destructor.
+       * Correctly deallocates all lists that are referenced by object members.
+       */
+      ~Flow_network();
+
+      /*
+       * Get function for the src_nodes member.
+       * @return   Pointer to the constant list of source nodes.
+       */
+      inline const net_node_list_item* get_src_nodes() const {
+         return src_nodes;
+      } // end get_src_nodes()
+
+      /*
+       * Get function for the dst_nodes member.
+       * @return   Pointer to the constant list of destination nodes.
+       */
+      inline const net_node_list_item* get_dst_nodes() const {
+         return dst_nodes;
+      } // end get_dst_nodes()
+
+      /*
+       * Get function for the s_node member.
+       * @return   Pointer to the constant special 's' node.
+       */
+      inline const net_node_list_item* get_s_node() const {
+         return s_node;
+      } // end get_s_node()
+
+      /*
+       * Get function for the t_node member.
+       * @return   Pointer to the constant special 't' node.
+       */
+      inline const net_node_list_item* get_t_node() const {
+         return t_node;
+      } // end get_t_node()
+
+      /*
+       * Adds an edge to the flow network.
+       * First of all, if they are not already present, the function inserts
+       * nodes representing src_prefix and dst_prefix into node lists src_list
+       * and dst_list, respectively. Next, if it is not already present, the
+       * function inserts a neighbour node representing the edge into the list
+       * of neighbours of the node representing the source prefix. Flow item of
+       * the neighbour node is set to 0, while other items within its structure
+       * are set according to the function's parameters.
+       * @param src_prefix     Reference to the IP_prefix object that
+       *                       determines a source node of the added edge.
+       * @param src_list       Specification of a node list that contains the
+       *                       source node of the added edge. Mapping of the
+       *                       four allowed values to the node lists is the
+       *                       following:
+       *                          0 ... s_node
+       *                          1 ... src_node
+       *                          2 ... dst_node
+       *                          3 ... t_node
+       * @param dst_prefix     Reference to the IP_prefix object that
+       *                       determines a destination node of the added edge.
+       * @param dst_list       Specification of a node list that contains the
+       *                       destination node of the added edge. Mapping of
+       *                       the four allowed values to the node lists is the
+       *                       following:
+       *                          0 ... s_node
+       *                          1 ... src_node
+       *                          2 ... dst_node
+       *                          3 ... t_node
+       * @param orig_edge      Pointer to the corresponding edge in the filter
+       *                       graph.
+       * @param forward_edge   Flag showing whether the added edge represents a
+       *                       forward edge.
+       * @param capacity       Residual capacity of the added edge.
+       */
+      void add_edge(const IP_prefix& src_prefix, int src_list,
+                    const IP_prefix& dst_prefix, int dst_list,
+                    neighbour_list_item* orig_edge, bool forward_edge,
+                    int capacity);
+
+      /*
+       * Transforms the flow network into a level graph.
+       * During inverse BFS of the flow network, starting from a set containing
+       * the 't' node, the function incrementally extends the set by start
+       * nodes of edges ending in one of the set nodes and removes from the
+       * flow network edges that do not meet this condition.
+       */
+      void to_level_graph();
+
+      /*
+       * Finds a blocking flow in the flow network, adds its value to the
+       * current flow in the corresponding filter graph, and also returns its
+       * value.
+       * The function repeatedly performs DST to find an s-t path in the flow
+       * network and the smallest capacity on this path. Once the function
+       * reaches the 't' node, it returns along the found path and increases
+       * the flow through the particular flow network edges as well as the
+       * corresponding filter graph edges. The function also updates capacities
+       * of backward-traversed flow network edges and removes them in case
+       * their capacity decreases to 0. In case of DFS ending in a node other
+       * than the 't' node, the function traverses back to the closest node
+       * with at least two output edges and removes all back-traversed edges.
+       * After each successful DFS and flow update on the found path, the
+       * function increases the value of the total flow through the flow
+       * network, which is returned at the end.
+       * The function expects that the flow network is in the form of a level
+       * graph at the time of invocation.
+       * @return   The value of the blocking flow through the flow network.
+       */
+      int find_blocking_flow();
+
+      /*
+       * Prints the flow network.
+       */
+      void print();
+};
+
+#endif
diff --git a/ip-address/COPYING b/ip-address/COPYING
new file mode 100644
index 0000000..03fc9f6
--- /dev/null
+++ b/ip-address/COPYING
@@ -0,0 +1,4 @@
+Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+
+Distributed under the Boost Software License, Version 1.0. (See accompanying
+file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/ip-address/LICENSE_1_0.txt b/ip-address/LICENSE_1_0.txt
new file mode 100644
index 0000000..36b7cd9
--- /dev/null
+++ b/ip-address/LICENSE_1_0.txt
@@ -0,0 +1,23 @@
+Boost Software License - Version 1.0 - August 17th, 2003
+
+Permission is hereby granted, free of charge, to any person or organization
+obtaining a copy of the software and accompanying documentation covered by
+this license (the "Software") to use, reproduce, display, distribute,
+execute, and transmit the Software, and to prepare derivative works of the
+Software, and to permit third-parties to whom the Software is furnished to
+do so, all subject to the following:
+
+The copyright notices in the Software and this entire statement, including
+the above license grant, this restriction and the following disclaimer,
+must be included in all copies of the Software, in whole or in part, and
+all derivative works of the Software, unless such copies or derivative
+works are solely in the form of machine-executable object code generated by
+a source language processor.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/ip-address/README.md b/ip-address/README.md
new file mode 100644
index 0000000..08ff928
--- /dev/null
+++ b/ip-address/README.md
@@ -0,0 +1,18 @@
+IP Address Proposal
+===================
+
+Proposed IP addresses classes for the standard C++ library.
+
+What's Included
+---------------
+
+* `./include` - Reference implementation.
+
+Tested Platforms
+----------------
+
+* Mac OS 10.8 using g++ 4.7 (requires `-std=c++11`)
+* Mac OS 10.8 using clang++ from Xcode 4.6 (requires `-std=c++11` and `-stdlib=libc++`)
+* Linux (CentOS 6.2) using g++ 4.7 (requires `-std=c++11`)
+* Windows 7 32-bit using Visual Studio 2010
+* Windows 7 x64 using Visual Studio 2010
diff --git a/ip-address/include/network b/ip-address/include/network
new file mode 100644
index 0000000..c97ea69
--- /dev/null
+++ b/ip-address/include/network
@@ -0,0 +1,25 @@
+//
+// network
+// ~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_NETWORK_HEADER_FILE
+#define STDNET_NETWORK_HEADER_FILE
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/ip/fwd.hpp"
+#include "std/net/ip/address.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/address_v6.hpp"
+#include "std/net/ip/address_cast.hpp"
+#include "std/net/literals.hpp"
+
+#endif // STDNET_NETWORK_HEADER_FILE
diff --git a/ip-address/include/std/net/detail/config.hpp b/ip-address/include/std/net/detail/config.hpp
new file mode 100644
index 0000000..c797490
--- /dev/null
+++ b/ip-address/include/std/net/detail/config.hpp
@@ -0,0 +1,666 @@
+//
+// detail/config.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_CONFIG_HPP
+#define STDNET_DETAIL_CONFIG_HPP
+
+// Default to a header-only implementation. The user must specifically request
+// separate compilation by defining either STDNET_SEPARATE_COMPILATION or
+// STDNET_DYN_LINK (as a DLL/shared library implies separate compilation).
+#if !defined(STDNET_HEADER_ONLY)
+# if !defined(STDNET_SEPARATE_COMPILATION)
+#  if !defined(STDNET_DYN_LINK)
+#   define STDNET_HEADER_ONLY 1
+#  endif // !defined(STDNET_DYN_LINK)
+# endif // !defined(STDNET_SEPARATE_COMPILATION)
+#endif // !defined(STDNET_HEADER_ONLY)
+
+#if defined(STDNET_HEADER_ONLY)
+# define STDNET_DECL inline
+#else // defined(STDNET_HEADER_ONLY)
+# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(__CODEGEARC__)
+// We need to import/export our code only if the user has specifically asked
+// for it by defining STDNET_DYN_LINK.
+#  if defined(STDNET_DYN_LINK)
+// Export if this is our own source, otherwise import.
+#   if defined(STDNET_SOURCE)
+#    define STDNET_DECL __declspec(dllexport)
+#   else // defined(STDNET_SOURCE)
+#    define STDNET_DECL __declspec(dllimport)
+#   endif // defined(STDNET_SOURCE)
+#  endif // defined(STDNET_DYN_LINK)
+# endif // defined(_MSC_VER) || defined(__BORLANDC__) || defined(__CODEGEARC__)
+#endif // defined(STDNET_HEADER_ONLY)
+
+// If STDNET_DECL isn't defined yet define it now.
+#if !defined(STDNET_DECL)
+# define STDNET_DECL
+#endif // !defined(STDNET_DECL)
+
+// Microsoft Visual C++ detection.
+#if !defined(STDNET_MSVC)
+# if defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__EDG_VERSION__)
+#  define STDNET_MSVC _MSC_VER
+# endif // defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__EDG_VERSION__)
+#endif // defined(STDNET_MSVC)
+
+// Support move construction and assignment on compilers known to allow it.
+#if !defined(STDNET_HAS_MOVE)
+# if !defined(STDNET_DISABLE_MOVE)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_MOVE 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_MOVE)
+#endif // !defined(STDNET_HAS_MOVE)
+
+// If STDNET_MOVE_CAST isn't defined, and move support is available, define
+// STDNET_MOVE_ARG and STDNET_MOVE_CAST to take advantage of rvalue
+// references and perfect forwarding.
+#if defined(STDNET_HAS_MOVE) && !defined(STDNET_MOVE_CAST)
+# define STDNET_MOVE_ARG(type) type&&
+# define STDNET_MOVE_CAST(type) static_cast<type&&>
+#endif // defined(STDNET_HAS_MOVE) && !defined(STDNET_MOVE_CAST)
+
+// If STDNET_MOVE_CAST still isn't defined, default to a C++03-compatible
+// implementation. Note that older g++ and MSVC versions don't like it when you
+// pass a non-member function through a const reference, so for most compilers
+// we'll play it safe and stick with the old approach of passing the handler by
+// value.
+#if !defined(STDNET_MOVE_CAST)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ > 4)
+#   define STDNET_MOVE_ARG(type) const type&
+#  else // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ > 4)
+#   define STDNET_MOVE_ARG(type) type
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ > 4)
+# elif defined(STDNET_MSVC)
+#  if (_MSC_VER >= 1400)
+#   define STDNET_MOVE_ARG(type) const type&
+#  else // (_MSC_VER >= 1400)
+#   define STDNET_MOVE_ARG(type) type
+#  endif // (_MSC_VER >= 1400)
+# else
+#  define STDNET_MOVE_ARG(type) type
+# endif
+# define STDNET_MOVE_CAST(type) static_cast<const type&>
+#endif // !defined_STDNET_MOVE_CAST
+
+// Support variadic templates on compilers known to allow it.
+#if !defined(STDNET_HAS_VARIADIC_TEMPLATES)
+# if !defined(STDNET_DISABLE_VARIADIC_TEMPLATES)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_VARIADIC_TEMPLATES 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_variadic_templates)
+#   define STDNET_HAS_VARIADIC_TEMPLATES 1
+#  endif // __has_feature(cxx_noexcept)
+# endif // defined(__clang__)
+# endif // !defined(STDNET_DISABLE_VARIADIC_TEMPLATES)
+#endif // !defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+// Support the noexcept specifier on compilers known to allow it.
+#if !defined(STDNET_NOEXCEPT)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#    define STDNET_NOEXCEPT noexcept
+#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+# endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_noexcept)
+#   define STDNET_NOEXCEPT noexcept
+#  endif // __has_feature(cxx_noexcept)
+# endif // defined(__clang__)
+# if !defined(STDNET_NOEXCEPT)
+#  define STDNET_NOEXCEPT
+# endif // !defined(STDNET_NOEXCEPT)
+#endif // !defined(STDNET_NOEXCEPT)
+
+// Support deleted functions on compilers known to allow it.
+#if !defined(STDNET_DELETED)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#    define STDNET_DELETED = delete
+#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+# endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_deleted_functions)
+#   define STDNET_DELETED = delete
+#  endif // __has_feature(cxx_noexcept)
+# endif // defined(__clang__)
+# if !defined(STDNET_DELETED)
+#  define STDNET_DELETED
+# endif // !defined(STDNET_DELETED)
+#endif // !defined(STDNET_DELETED)
+
+// Support relaxed constexpr on compilers known to allow it.
+#if !defined(STDNET_CONSTEXPR)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#    define STDNET_HAS_CONSTEXPR 1
+#    define STDNET_CONSTEXPR constexpr
+#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+# endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_constexpr)
+#   define STDNET_HAS_CONSTEXPR 1
+#   define STDNET_CONSTEXPR constexpr
+#  endif // __has_feature(cxx_constexpr)
+# endif // defined(__clang__)
+# if !defined(STDNET_CONSTEXPR)
+#  define STDNET_CONSTEXPR
+# endif // !defined(STDNET_CONSTEXPR)
+#endif // !defined(STDNET_CONSTEXPR)
+
+// Standard library support for system errors.
+#if !defined(STDNET_HAS_STD_SYSTEM_ERROR)
+# if !defined(STDNET_DISABLE_STD_SYSTEM_ERROR)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_SYSTEM_ERROR 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_SYSTEM_ERROR)
+#endif // !defined(STDNET_HAS_STD_SYSTEM_ERROR)
+
+// Compliant C++11 compilers put noexcept specifiers on error_category members.
+#if !defined(STDNET_ERROR_CATEGORY_NOEXCEPT)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_ERROR_CATEGORY_NOEXCEPT noexcept(true)
+#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+# endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_noexcept)
+#    define STDNET_ERROR_CATEGORY_NOEXCEPT noexcept(true)
+#  endif // __has_feature(cxx_noexcept)
+# endif // defined(__clang__)
+# if !defined(STDNET_ERROR_CATEGORY_NOEXCEPT)
+#  define STDNET_ERROR_CATEGORY_NOEXCEPT
+# endif // !defined(STDNET_ERROR_CATEGORY_NOEXCEPT)
+#endif // !defined(STDNET_ERROR_CATEGORY_NOEXCEPT)
+
+// Standard library support for arrays.
+#if !defined(STDNET_HAS_STD_ARRAY)
+# if !defined(STDNET_DISABLE_STD_ARRAY)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_ARRAY 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+#  if defined(STDNET_MSVC)
+#   if (_MSC_VER >= 1600)
+#    define STDNET_HAS_STD_ARRAY 1
+#   endif // (_MSC_VER >= 1600)
+#  endif // defined(STDNET_MSVC)
+# endif // !defined(STDNET_DISABLE_STD_ARRAY)
+#endif // !defined(STDNET_HAS_STD_ARRAY)
+
+// Standard library support for shared_ptr and weak_ptr.
+#if !defined(STDNET_HAS_STD_SHARED_PTR)
+# if !defined(STDNET_DISABLE_STD_SHARED_PTR)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_SHARED_PTR 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+#  if defined(STDNET_MSVC)
+#   if (_MSC_VER >= 1600)
+#    define STDNET_HAS_STD_SHARED_PTR 1
+#   endif // (_MSC_VER >= 1600)
+#  endif // defined(STDNET_MSVC)
+# endif // !defined(STDNET_DISABLE_STD_SHARED_PTR)
+#endif // !defined(STDNET_HAS_STD_SHARED_PTR)
+
+// Standard library support for atomic operations.
+#if !defined(STDNET_HAS_STD_ATOMIC)
+# if !defined(STDNET_DISABLE_STD_ATOMIC)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_ATOMIC 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_ATOMIC)
+#endif // !defined(STDNET_HAS_STD_ATOMIC)
+
+// Standard library support for chrono. Some standard libraries (such as the
+// libstdc++ shipped with gcc 4.6) provide monotonic_clock as per early C++0x
+// drafts, rather than the eventually standardised name of steady_clock.
+#if !defined(STDNET_HAS_STD_CHRONO)
+# if !defined(STDNET_DISABLE_STD_CHRONO)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_CHRONO 1
+#     if ((__GNUC__ == 4) && (__GNUC_MINOR__ == 6))
+#      define STDNET_HAS_STD_CHRONO_MONOTONIC_CLOCK 1
+#     endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ == 6))
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_CHRONO)
+#endif // !defined(STDNET_HAS_STD_CHRONO)
+
+// Standard library support for addressof.
+#if !defined(STDNET_HAS_STD_ADDRESSOF)
+# if !defined(STDNET_DISABLE_STD_ADDRESSOF)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_ADDRESSOF 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_ADDRESSOF)
+#endif // !defined(STDNET_HAS_STD_ADDRESSOF)
+
+// Standard library support for the function class.
+#if !defined(STDNET_HAS_STD_FUNCTION)
+# if !defined(STDNET_DISABLE_STD_FUNCTION)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_FUNCTION 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_FUNCTION)
+#endif // !defined(STDNET_HAS_STD_FUNCTION)
+
+// Standard library support for type traits.
+#if !defined(STDNET_HAS_STD_TYPE_TRAITS)
+# if !defined(STDNET_DISABLE_STD_TYPE_TRAITS)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_TYPE_TRAITS 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_TYPE_TRAITS)
+#endif // !defined(STDNET_HAS_STD_TYPE_TRAITS)
+
+// Standard library support for the cstdint header.
+#if !defined(STDNET_HAS_CSTDINT)
+# if !defined(STDNET_DISABLE_CSTDINT)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_CSTDINT 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_CSTDINT)
+#endif // !defined(STDNET_HAS_CSTDINT)
+
+// Windows target.
+#if !defined(STDNET_WINDOWS)
+# if defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
+#  define STDNET_WINDOWS 1
+# endif // defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
+#endif // !defined(STDNET_WINDOWS)
+
+// Windows: target OS version.
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# if !defined(_WIN32_WINNT) && !defined(_WIN32_WINDOWS)
+#  if defined(_MSC_VER) || defined(__BORLANDC__)
+#   pragma message( \
+  "Please define _WIN32_WINNT or _WIN32_WINDOWS appropriately. For example:\n"\
+  "- add -D_WIN32_WINNT=0x0501 to the compiler command line; or\n"\
+  "- add _WIN32_WINNT=0x0501 to your project's Preprocessor Definitions.\n"\
+  "Assuming _WIN32_WINNT=0x0501 (i.e. Windows XP target).")
+#  else // defined(_MSC_VER) || defined(__BORLANDC__)
+#   warning Please define _WIN32_WINNT or _WIN32_WINDOWS appropriately.
+#   warning For example, add -D_WIN32_WINNT=0x0501 to the compiler command line.
+#   warning Assuming _WIN32_WINNT=0x0501 (i.e. Windows XP target).
+#  endif // defined(_MSC_VER) || defined(__BORLANDC__)
+#  define _WIN32_WINNT 0x0501
+# endif // !defined(_WIN32_WINNT) && !defined(_WIN32_WINDOWS)
+# if defined(_MSC_VER)
+#  if defined(_WIN32) && !defined(WIN32)
+#   if !defined(_WINSOCK2API_)
+#    define WIN32 // Needed for correct types in winsock2.h
+#   else // !defined(_WINSOCK2API_)
+#    error Please define the macro WIN32 in your compiler options
+#   endif // !defined(_WINSOCK2API_)
+#  endif // defined(_WIN32) && !defined(WIN32)
+# endif // defined(_MSC_VER)
+# if defined(__BORLANDC__)
+#  if defined(__WIN32__) && !defined(WIN32)
+#   if !defined(_WINSOCK2API_)
+#    define WIN32 // Needed for correct types in winsock2.h
+#   else // !defined(_WINSOCK2API_)
+#    error Please define the macro WIN32 in your compiler options
+#   endif // !defined(_WINSOCK2API_)
+#  endif // defined(__WIN32__) && !defined(WIN32)
+# endif // defined(__BORLANDC__)
+# if defined(__CYGWIN__)
+#  if !defined(__USE_W32_SOCKETS)
+#   error You must add -D__USE_W32_SOCKETS to your compiler options.
+#  endif // !defined(__USE_W32_SOCKETS)
+# endif // defined(__CYGWIN__)
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+// Windows: minimise header inclusion.
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# if !defined(STDNET_NO_WIN32_LEAN_AND_MEAN)
+#  if !defined(WIN32_LEAN_AND_MEAN)
+#   define WIN32_LEAN_AND_MEAN
+#  endif // !defined(WIN32_LEAN_AND_MEAN)
+# endif // !defined(STDNET_NO_WIN32_LEAN_AND_MEAN)
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+// Windows: suppress definition of "min" and "max" macros.
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# if !defined(STDNET_NO_NOMINMAX)
+#  if !defined(NOMINMAX)
+#   define NOMINMAX 1
+#  endif // !defined(NOMINMAX)
+# endif // !defined(STDNET_NO_NOMINMAX)
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+// Windows: No ANSI API calls.
+#if !defined(STDNET_NO_ANSI_APIS)
+# if defined(STDNET_WINDOWS) && defined(UNDER_CE)
+#  define STDNET_NO_ANSI_APIS 1
+# endif // defined(STDNET_WINDOWS) && defined(UNDER_CE)
+#endif // !defined(STDNET_NO_ANSI_APIS)
+
+// Windows: IO Completion Ports.
+#if !defined(STDNET_HAS_IOCP)
+# if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+#  if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0400)
+#   if !defined(UNDER_CE)
+#    if !defined(STDNET_DISABLE_IOCP)
+#     define STDNET_HAS_IOCP 1
+#    endif // !defined(STDNET_DISABLE_IOCP)
+#   endif // !defined(UNDER_CE)
+#  endif // defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0400)
+# endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+#endif // !defined(STDNET_HAS_IOCP)
+
+// Linux: epoll, eventfd and timerfd.
+#if defined(__linux__)
+# include <linux/version.h>
+# if !defined(STDNET_HAS_EPOLL)
+#  if !defined(STDNET_DISABLE_EPOLL)
+#   if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,45)
+#    define STDNET_HAS_EPOLL 1
+#   endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,45)
+#  endif // !defined(STDNET_DISABLE_EPOLL)
+# endif // !defined(STDNET_HAS_EPOLL)
+# if !defined(STDNET_HAS_EVENTFD)
+#  if !defined(STDNET_DISABLE_EVENTFD)
+#   if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#    define STDNET_HAS_EVENTFD 1
+#   endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#  endif // !defined(STDNET_DISABLE_EVENTFD)
+# endif // !defined(STDNET_HAS_EVENTFD)
+# if !defined(STDNET_HAS_TIMERFD)
+#  if defined(STDNET_HAS_EPOLL)
+#   if (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 8)
+#    define STDNET_HAS_TIMERFD 1
+#   endif // (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 8)
+#  endif // defined(STDNET_HAS_EPOLL)
+# endif // !defined(STDNET_HAS_TIMERFD)
+#endif // defined(__linux__)
+
+// Mac OS X, FreeBSD, NetBSD, OpenBSD: kqueue.
+#if (defined(__MACH__) && defined(__APPLE__)) \
+  || defined(__FreeBSD__) \
+  || defined(__NetBSD__) \
+  || defined(__OpenBSD__)
+# if !defined(STDNET_HAS_KQUEUE)
+#  if !defined(STDNET_DISABLE_KQUEUE)
+#   define STDNET_HAS_KQUEUE 1
+#  endif // !defined(STDNET_DISABLE_KQUEUE)
+# endif // !defined(STDNET_HAS_KQUEUE)
+#endif // (defined(__MACH__) && defined(__APPLE__))
+       //   || defined(__FreeBSD__)
+       //   || defined(__NetBSD__)
+       //   || defined(__OpenBSD__)
+
+// Solaris: /dev/poll.
+#if defined(__sun)
+# if !defined(STDNET_HAS_DEV_POLL)
+#  if !defined(STDNET_DISABLE_DEV_POLL)
+#   define STDNET_HAS_DEV_POLL 1
+#  endif // !defined(STDNET_DISABLE_DEV_POLL)
+# endif // !defined(STDNET_HAS_DEV_POLL)
+#endif // defined(__sun)
+
+// Serial ports.
+#if !defined(STDNET_HAS_SERIAL_PORT)
+# if defined(STDNET_HAS_IOCP) \
+    || !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#  if !defined(__SYMBIAN32__)
+#   if !defined(STDNET_DISABLE_SERIAL_PORT)
+#    define STDNET_HAS_SERIAL_PORT 1
+#   endif // !defined(STDNET_DISABLE_SERIAL_PORT)
+#  endif // !defined(__SYMBIAN32__)
+# endif // defined(STDNET_HAS_IOCP)
+        //   || !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#endif // !defined(STDNET_HAS_SERIAL_PORT)
+
+// Windows: stream handles.
+#if !defined(STDNET_HAS_WINDOWS_STREAM_HANDLE)
+# if !defined(STDNET_DISABLE_WINDOWS_STREAM_HANDLE)
+#  if defined(STDNET_HAS_IOCP)
+#   define STDNET_HAS_WINDOWS_STREAM_HANDLE 1
+#  endif // defined(STDNET_HAS_IOCP)
+# endif // !defined(STDNET_DISABLE_WINDOWS_STREAM_HANDLE)
+#endif // !defined(STDNET_HAS_WINDOWS_STREAM_HANDLE)
+
+// Windows: random access handles.
+#if !defined(STDNET_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
+# if !defined(STDNET_DISABLE_WINDOWS_RANDOM_ACCESS_HANDLE)
+#  if defined(STDNET_HAS_IOCP)
+#   define STDNET_HAS_WINDOWS_RANDOM_ACCESS_HANDLE 1
+#  endif // defined(STDNET_HAS_IOCP)
+# endif // !defined(STDNET_DISABLE_WINDOWS_RANDOM_ACCESS_HANDLE)
+#endif // !defined(STDNET_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
+
+// Windows: object handles.
+#if !defined(STDNET_HAS_WINDOWS_OBJECT_HANDLE)
+# if !defined(STDNET_DISABLE_WINDOWS_OBJECT_HANDLE)
+#  if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+#   if !defined(UNDER_CE)
+#    define STDNET_HAS_WINDOWS_OBJECT_HANDLE 1
+#   endif // !defined(UNDER_CE)
+#  endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# endif // !defined(STDNET_DISABLE_WINDOWS_OBJECT_HANDLE)
+#endif // !defined(STDNET_HAS_WINDOWS_OBJECT_HANDLE)
+
+// Windows: OVERLAPPED wrapper.
+#if !defined(STDNET_HAS_WINDOWS_OVERLAPPED_PTR)
+# if !defined(STDNET_DISABLE_WINDOWS_OVERLAPPED_PTR)
+#  if defined(STDNET_HAS_IOCP)
+#   define STDNET_HAS_WINDOWS_OVERLAPPED_PTR 1
+#  endif // defined(STDNET_HAS_IOCP)
+# endif // !defined(STDNET_DISABLE_WINDOWS_OVERLAPPED_PTR)
+#endif // !defined(STDNET_HAS_WINDOWS_OVERLAPPED_PTR)
+
+// POSIX: stream-oriented file descriptors.
+#if !defined(STDNET_HAS_POSIX_STREAM_DESCRIPTOR)
+# if !defined(STDNET_DISABLE_POSIX_STREAM_DESCRIPTOR)
+#  if !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#   define STDNET_HAS_POSIX_STREAM_DESCRIPTOR 1
+#  endif // !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+# endif // !defined(STDNET_DISABLE_POSIX_STREAM_DESCRIPTOR)
+#endif // !defined(STDNET_HAS_POSIX_STREAM_DESCRIPTOR)
+
+// UNIX domain sockets.
+#if !defined(STDNET_HAS_LOCAL_SOCKETS)
+# if !defined(STDNET_DISABLE_LOCAL_SOCKETS)
+#  if !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#   define STDNET_HAS_LOCAL_SOCKETS 1
+#  endif // !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+# endif // !defined(STDNET_DISABLE_LOCAL_SOCKETS)
+#endif // !defined(STDNET_HAS_LOCAL_SOCKETS)
+
+// Can use sigaction() instead of signal().
+#if !defined(STDNET_HAS_SIGACTION)
+# if !defined(STDNET_DISABLE_SIGACTION)
+#  if !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#   define STDNET_HAS_SIGACTION 1
+#  endif // !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+# endif // !defined(STDNET_DISABLE_SIGACTION)
+#endif // !defined(STDNET_HAS_SIGACTION)
+
+// Can use signal().
+#if !defined(STDNET_HAS_SIGNAL)
+# if !defined(STDNET_DISABLE_SIGNAL)
+#  if !defined(UNDER_CE)
+#   define STDNET_HAS_SIGNAL 1
+#  endif // !defined(UNDER_CE)
+# endif // !defined(STDNET_DISABLE_SIGNAL)
+#endif // !defined(STDNET_HAS_SIGNAL)
+
+// Whether standard iostreams are disabled.
+//#if !defined(STDNET_NO_IOSTREAM)
+//# define STDNET_NO_IOSTREAM 1
+//#endif // !defined(STDNET_NO_IOSTREAM)
+
+// Whether exception handling is disabled.
+//#if !defined(STDNET_NO_EXCEPTIONS)
+//# define STDNET_NO_EXCEPTIONS 1
+//#endif // !defined(STDNET_NO_EXCEPTIONS)
+
+// Whether the typeid operator is supported.
+//#if !defined(STDNET_NO_TYPEID)
+//# define STDNET_NO_TYPEID 1
+//#endif // !defined(STDNET_NO_TYPEID)
+
+// On POSIX (and POSIX-like) platforms we need to include unistd.h in order to
+// get access to the various platform feature macros, e.g. to be able to test
+// for threads support.
+#if !defined(STDNET_HAS_UNISTD_H)
+# if defined(unix) \
+  || defined(__unix) \
+  || defined(_XOPEN_SOURCE) \
+  || defined(_POSIX_SOURCE) \
+  || (defined(__MACH__) && defined(__APPLE__)) \
+  || defined(__FreeBSD__) \
+  || defined(__NetBSD__) \
+  || defined(__OpenBSD__) \
+  || defined(__linux__)
+#  define STDNET_HAS_UNISTD_H 1
+# endif
+#endif // !defined(STDNET_HAS_UNISTD_H)
+#if defined(STDNET_HAS_UNISTD_H)
+# include <unistd.h>
+#endif // defined(STDNET_HAS_UNISTD_H)
+
+// Threads.
+#if !defined(STDNET_HAS_THREADS)
+# if !defined(STDNET_DISABLE_THREADS)
+#  if defined(_MSC_VER) && defined(_MT)
+#   define STDNET_HAS_THREADS 1
+#  elif defined(__BORLANDC__) && defined(__MT__)
+#   define STDNET_HAS_THREADS 1
+#  elif defined(_POSIX_THREADS)
+#   define STDNET_HAS_THREADS 1
+#  endif // defined(_MSC_VER) && defined(_MT)
+# endif // !defined(STDNET_DISABLE_THREADS)
+#endif // !defined(STDNET_HAS_THREADS)
+
+// POSIX threads.
+#if !defined(STDNET_HAS_PTHREADS)
+# if defined(STDNET_HAS_THREADS)
+#  if defined(_POSIX_THREADS)
+#   define STDNET_HAS_PTHREADS 1
+#  endif // defined(_POSIX_THREADS)
+# endif // defined(STDNET_HAS_THREADS)
+#endif // !defined(STDNET_HAS_PTHREADS)
+
+// Helper to prevent macro expansion.
+#define STDNET_PREVENT_MACRO_SUBSTITUTION
+
+// Helper to define in-class constants.
+#if !defined(STDNET_STATIC_CONSTANT)
+# define STDNET_STATIC_CONSTANT(type, assignment) \
+   static const type assignment
+#endif // !defined(STDNET_STATIC_CONSTANT)
+
+// Microsoft Visual C++'s secure C runtime library.
+#if !defined(STDNET_HAS_SECURE_RTL)
+# if !defined(STDNET_DISABLE_SECURE_RTL)
+#  if defined(STDNET_MSVC) \
+    && (STDNET_MSVC >= 1400) \
+    && !defined(UNDER_CE)
+#   define STDNET_HAS_SECURE_RTL 1
+#  endif // defined(STDNET_MSVC)
+         // && (STDNET_MSVC >= 1400)
+         // && !defined(UNDER_CE)
+# endif // !defined(STDNET_DISABLE_SECURE_RTL)
+#endif // !defined(STDNET_HAS_SECURE_RTL)
+
+// Handler hooking. Disabled for ancient Borland C++ and gcc compilers.
+#if !defined(STDNET_HAS_HANDLER_HOOKS)
+# if !defined(STDNET_DISABLE_HANDLER_HOOKS)
+#  if defined(__GNUC__)
+#   if (__GNUC__ >= 3)
+#    define STDNET_HAS_HANDLER_HOOKS 1
+#   endif // (__GNUC__ >= 3)
+#  elif !defined(__BORLANDC__)
+#   define STDNET_HAS_HANDLER_HOOKS 1
+#  endif // !defined(__BORLANDC__)
+# endif // !defined(STDNET_DISABLE_HANDLER_HOOKS)
+#endif // !defined(STDNET_HAS_HANDLER_HOOKS)
+
+// Support for the __thread keyword extension.
+#if !defined(STDNET_DISABLE_THREAD_KEYWORD_EXTENSION)
+# if defined(__linux__)
+#  if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+#   if ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3)
+#    if !defined(__INTEL_COMPILER) && !defined(__ICL)
+#     define STDNET_HAS_THREAD_KEYWORD_EXTENSION 1
+#    elif defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1100)
+#     define STDNET_HAS_THREAD_KEYWORD_EXTENSION 1
+#    endif // defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1100)
+#   endif // ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3)
+#  endif // defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+# endif // defined(__linux__)
+#endif // !defined(STDNET_DISABLE_THREAD_KEYWORD_EXTENSION)
+
+// Support for POSIX ssize_t typedef.
+#if !defined(STDNET_DISABLE_SSIZE_T)
+# if defined(__linux__) \
+   || (defined(__MACH__) && defined(__APPLE__))
+#  define STDNET_HAS_SSIZE_T 1
+# endif // defined(__linux__)
+        //   || (defined(__MACH__) && defined(__APPLE__))
+#endif // !defined(STDNET_DISABLE_SSIZE_T)
+
+#endif // STDNET_DETAIL_CONFIG_HPP
diff --git a/ip-address/include/std/net/detail/impl/socket_ops.ipp b/ip-address/include/std/net/detail/impl/socket_ops.ipp
new file mode 100644
index 0000000..13b32a3
--- /dev/null
+++ b/ip-address/include/std/net/detail/impl/socket_ops.ipp
@@ -0,0 +1,260 @@
+//
+// detail/impl/socket_ops.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_SOCKET_OPS_IPP
+#define STDNET_DETAIL_SOCKET_OPS_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <cctype>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <cerrno>
+#include <new>
+#include "std/net/detail/socket_ops.hpp"
+#include "std/net/detail/system_errors.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace socket_ops {
+
+#if defined(__hpux)
+// HP-UX doesn't declare these functions extern "C", so they are declared again
+// here to avoid linker errors about undefined symbols.
+extern "C" char* if_indextoname(unsigned int, char*);
+extern "C" unsigned int if_nametoindex(const char*);
+#endif // defined(__hpux)
+
+inline void clear_last_error()
+{
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  WSASetLastError(0);
+#else
+  errno = 0;
+#endif
+}
+
+template <typename ReturnType>
+inline ReturnType error_wrapper(ReturnType return_value,
+    std::error_code& ec)
+{
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  ec = std::error_code(WSAGetLastError(),
+      std::experimental::net::detail::syserrc::system_category());
+#else
+  ec = std::error_code(errno,
+      std::experimental::net::detail::syserrc::system_category());
+#endif
+  return return_value;
+}
+
+const char* inet_ntop(int af, const void* src, char* dest, size_t length,
+    unsigned long scope_id, std::error_code& ec)
+{
+  clear_last_error();
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  using namespace std; // For memcpy.
+
+  if (af != AF_INET && af != AF_INET6)
+  {
+    ec = std::experimental::net::detail::syserrc::address_family_not_supported;
+    return 0;
+  }
+
+  union
+  {
+    socket_addr_type base;
+    sockaddr_storage_type storage;
+    sockaddr_in4_type v4;
+    sockaddr_in6_type v6;
+  } address;
+  DWORD address_length;
+  if (af == AF_INET)
+  {
+    address_length = sizeof(sockaddr_in4_type);
+    address.v4.sin_family = AF_INET;
+    address.v4.sin_port = 0;
+    memcpy(&address.v4.sin_addr, src, sizeof(in4_addr_type));
+  }
+  else // AF_INET6
+  {
+    address_length = sizeof(sockaddr_in6_type);
+    address.v6.sin6_family = AF_INET6;
+    address.v6.sin6_port = 0;
+    address.v6.sin6_flowinfo = 0;
+    address.v6.sin6_scope_id = scope_id;
+    memcpy(&address.v6.sin6_addr, src, sizeof(in6_addr_type));
+  }
+
+  DWORD string_length = static_cast<DWORD>(length);
+#if defined(STDNET_NO_ANSI_APIS)
+  LPWSTR string_buffer = (LPWSTR)_alloca(length * sizeof(WCHAR));
+  int result = error_wrapper(::WSAAddressToStringW(&address.base,
+        address_length, 0, string_buffer, &string_length), ec);
+  ::WideCharToMultiByte(CP_ACP, 0, string_buffer, -1, dest, length, 0, 0);
+#else
+  int result = error_wrapper(::WSAAddressToStringA(
+        &address.base, address_length, 0, dest, &string_length), ec);
+#endif
+
+  // Windows may set error code on success.
+  if (result != socket_error_retval)
+    ec = std::error_code();
+
+  // Windows may not set an error code on failure.
+  else if (result == socket_error_retval && !ec)
+    ec = std::experimental::net::detail::syserrc::invalid_argument;
+
+  return result == socket_error_retval ? 0 : dest;
+#else // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  const char* result = error_wrapper(::inet_ntop(
+        af, src, dest, static_cast<int>(length)), ec);
+  if (result == 0 && !ec)
+    ec = std::experimental::net::detail::syserrc::invalid_argument;
+  if (result != 0 && af == AF_INET6 && scope_id != 0)
+  {
+    using namespace std; // For strcat and sprintf.
+    char if_name[IF_NAMESIZE + 1] = "%";
+    const in6_addr_type* ipv6_address = static_cast<const in6_addr_type*>(src);
+    bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
+        && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
+    if (!is_link_local
+        || if_indextoname(static_cast<unsigned>(scope_id), if_name + 1) == 0)
+      sprintf(if_name + 1, "%lu", scope_id);
+    strcat(dest, if_name);
+  }
+  return result;
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+}
+
+int inet_pton(int af, const char* src, void* dest,
+    unsigned long* scope_id, std::error_code& ec)
+{
+  clear_last_error();
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  using namespace std; // For memcpy and strcmp.
+
+  if (af != AF_INET && af != AF_INET6)
+  {
+    ec = std::experimental::net::detail::syserrc::address_family_not_supported;
+    return -1;
+  }
+
+  union
+  {
+    socket_addr_type base;
+    sockaddr_storage_type storage;
+    sockaddr_in4_type v4;
+    sockaddr_in6_type v6;
+  } address;
+  int address_length = sizeof(sockaddr_storage_type);
+#if defined(STDNET_NO_ANSI_APIS)
+  int num_wide_chars = strlen(src) + 1;
+  LPWSTR wide_buffer = (LPWSTR)_alloca(num_wide_chars * sizeof(WCHAR));
+  ::MultiByteToWideChar(CP_ACP, 0, src, -1, wide_buffer, num_wide_chars);
+  int result = error_wrapper(::WSAStringToAddressW(
+        wide_buffer, af, 0, &address.base, &address_length), ec);
+#else
+  int result = error_wrapper(::WSAStringToAddressA(
+        const_cast<char*>(src), af, 0, &address.base, &address_length), ec);
+#endif
+
+  if (af == AF_INET)
+  {
+    if (result != socket_error_retval)
+    {
+      memcpy(dest, &address.v4.sin_addr, sizeof(in4_addr_type));
+      ec = std::error_code();
+    }
+    else if (strcmp(src, "255.255.255.255") == 0)
+    {
+      static_cast<in4_addr_type*>(dest)->s_addr = INADDR_NONE;
+      ec = std::error_code();
+    }
+  }
+  else // AF_INET6
+  {
+    if (result != socket_error_retval)
+    {
+      memcpy(dest, &address.v6.sin6_addr, sizeof(in6_addr_type));
+      if (scope_id)
+        *scope_id = address.v6.sin6_scope_id;
+      ec = std::error_code();
+    }
+  }
+
+  // Windows may not set an error code on failure.
+  if (result == socket_error_retval && !ec)
+    ec = std::experimental::net::detail::syserrc::invalid_argument;
+
+  if (result != socket_error_retval)
+    ec = std::error_code();
+
+  return result == socket_error_retval ? -1 : 1;
+#else // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  int result = error_wrapper(::inet_pton(af, src, dest), ec);
+  if (result <= 0 && !ec)
+    ec = std::experimental::net::detail::syserrc::invalid_argument;
+  if (result > 0 && af == AF_INET6 && scope_id)
+  {
+    using namespace std; // For strchr and atoi.
+    *scope_id = 0;
+    if (const char* if_name = strchr(src, '%'))
+    {
+      in6_addr_type* ipv6_address = static_cast<in6_addr_type*>(dest);
+      bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
+          && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
+      if (is_link_local)
+        *scope_id = if_nametoindex(if_name + 1);
+      if (*scope_id == 0)
+        *scope_id = atoi(if_name + 1);
+    }
+  }
+  return result;
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+}
+
+u_long_type network_to_host_long(u_long_type value)
+{
+  return ntohl(value);
+}
+
+u_long_type host_to_network_long(u_long_type value)
+{
+  return htonl(value);
+}
+
+u_short_type network_to_host_short(u_short_type value)
+{
+  return ntohs(value);
+}
+
+u_short_type host_to_network_short(u_short_type value)
+{
+  return htons(value);
+}
+
+} // namespace socket_ops
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_DETAIL_SOCKET_OPS_IPP
diff --git a/ip-address/include/std/net/detail/impl/system_errors.ipp b/ip-address/include/std/net/detail/impl/system_errors.ipp
new file mode 100644
index 0000000..8b01e08
--- /dev/null
+++ b/ip-address/include/std/net/detail/impl/system_errors.ipp
@@ -0,0 +1,94 @@
+//
+// impl/system_errors.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_IMPL_SYSTEM_ERRORS_IPP
+#define STDNET_DETAIL_IMPL_SYSTEM_ERRORS_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include "std/net/detail/local_free_on_block_exit.hpp"
+#include "std/net/detail/system_errors.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace syserrc {
+
+class system_category : public std::error_category
+{
+public:
+  const char* name() const STDNET_ERROR_CATEGORY_NOEXCEPT
+  {
+    return "std.net.system";
+  }
+
+  std::string message(int value) const
+  {
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+    char* msg = 0;
+    DWORD length = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER
+        | FORMAT_MESSAGE_FROM_SYSTEM
+        | FORMAT_MESSAGE_IGNORE_INSERTS, 0, value,
+        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char*)&msg, 0, 0);
+    detail::local_free_on_block_exit local_free_obj(msg);
+    if (length && msg[length - 1] == '\n')
+      msg[--length] = '\0';
+    if (length && msg[length - 1] == '\r')
+      msg[--length] = '\0';
+    if (length)
+      return msg;
+    else
+      return "std.net.system error";
+#else // defined(STDNET_WINDOWS)
+#if !defined(__sun)
+    if (value == ECANCELED)
+      return "Operation aborted.";
+#endif // !defined(__sun)
+#if defined(__sun) || defined(__QNX__) || defined(__SYMBIAN32__)
+    using namespace std;
+    return strerror(value);
+#elif defined(__MACH__) && defined(__APPLE__) \
+  || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__) \
+  || defined(_AIX) || defined(__hpux) || defined(__osf__) \
+  || defined(__ANDROID__)
+    char buf[256] = "";
+    using namespace std;
+    strerror_r(value, buf, sizeof(buf));
+    return buf;
+#else
+    char buf[256] = "";
+    return strerror_r(value, buf, sizeof(buf));
+#endif
+#endif // defined(STDNET_WINDOWS)
+  }
+};
+
+} // namespace syserrc
+
+const std::error_category& system_category()
+{
+  static syserrc::system_category instance;
+  return instance;
+}
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_DETAIL_IMPL_SYSTEM_ERRORS_IPP
diff --git a/ip-address/include/std/net/detail/impl/throw_error.ipp b/ip-address/include/std/net/detail/impl/throw_error.ipp
new file mode 100644
index 0000000..92baf1c
--- /dev/null
+++ b/ip-address/include/std/net/detail/impl/throw_error.ipp
@@ -0,0 +1,49 @@
+//
+// detail/impl/throw_error.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_IMPL_THROW_ERROR_IPP
+#define STDNET_DETAIL_IMPL_THROW_ERROR_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <system_error>
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/detail/throw_exception.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+void do_throw_error(const std::error_code& err)
+{
+  std::system_error e(err);
+  std::experimental::net::detail::throw_exception(e);
+}
+
+void do_throw_error(const std::error_code& err, const char* location)
+{
+  std::system_error e(err, location);
+  std::experimental::net::detail::throw_exception(e);
+}
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_DETAIL_IMPL_THROW_ERROR_IPP
diff --git a/ip-address/include/std/net/detail/impl/winsock_init.ipp b/ip-address/include/std/net/detail/impl/winsock_init.ipp
new file mode 100644
index 0000000..7114f6a
--- /dev/null
+++ b/ip-address/include/std/net/detail/impl/winsock_init.ipp
@@ -0,0 +1,73 @@
+//
+// detail/impl/winsock_init.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_IMPL_WINSOCK_INIT_IPP
+#define STDNET_DETAIL_IMPL_WINSOCK_INIT_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#include "std/net/detail/socket_types.hpp"
+#include "std/net/detail/system_errors.hpp"
+#include "std/net/detail/winsock_init.hpp"
+#include "std/net/detail/throw_error.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+void winsock_init_base::startup(data& d,
+    unsigned char major, unsigned char minor)
+{
+  if (::InterlockedIncrement(&d.init_count_) == 1)
+  {
+    WSADATA wsa_data;
+    long result = ::WSAStartup(MAKEWORD(major, minor), &wsa_data);
+    ::InterlockedExchange(&d.result_, result);
+  }
+}
+
+void winsock_init_base::cleanup(data& d)
+{
+  if (::InterlockedDecrement(&d.init_count_) == 0)
+  {
+    ::WSACleanup();
+  }
+}
+
+void winsock_init_base::throw_on_error(data& d)
+{
+  long result = ::InterlockedExchangeAdd(&d.result_, 0);
+  if (result != 0)
+  {
+    std::error_code ec(result,
+        std::experimental::net::detail::system_category());
+    std::experimental::net::detail::throw_error(ec, "winsock");
+  }
+}
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#endif // STDNET_DETAIL_IMPL_WINSOCK_INIT_IPP
diff --git a/ip-address/include/std/net/detail/local_free_on_block_exit.hpp b/ip-address/include/std/net/detail/local_free_on_block_exit.hpp
new file mode 100644
index 0000000..64c9137
--- /dev/null
+++ b/ip-address/include/std/net/detail/local_free_on_block_exit.hpp
@@ -0,0 +1,63 @@
+//
+// detail/local_free_on_block_exit.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
+#define STDNET_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#include "std/net/detail/socket_types.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+class local_free_on_block_exit
+{
+public:
+  // Constructor blocks all signals for the calling thread.
+  explicit local_free_on_block_exit(void* p)
+    : p_(p)
+  {
+  }
+
+  // Destructor restores the previous signal mask.
+  ~local_free_on_block_exit()
+  {
+    ::LocalFree(p_);
+  }
+
+private:
+  // Disallow copying and assignemnt.
+  local_free_on_block_exit(const local_free_on_block_exit&);
+  local_free_on_block_exit& operator=(const local_free_on_block_exit&);
+
+  void* p_;
+};
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#endif // STDNET_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
diff --git a/ip-address/include/std/net/detail/old_win_sdk_compat.hpp b/ip-address/include/std/net/detail/old_win_sdk_compat.hpp
new file mode 100644
index 0000000..3a3cdac
--- /dev/null
+++ b/ip-address/include/std/net/detail/old_win_sdk_compat.hpp
@@ -0,0 +1,218 @@
+//
+// detail/old_win_sdk_compat.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_OLD_WIN_SDK_COMPAT_HPP
+#define STDNET_DETAIL_OLD_WIN_SDK_COMPAT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+// Guess whether we are building against on old Platform SDK.
+#if !defined(IN6ADDR_ANY_INIT)
+#define STDNET_HAS_OLD_WIN_SDK 1
+#endif // !defined(IN6ADDR_ANY_INIT)
+
+#if defined(STDNET_HAS_OLD_WIN_SDK)
+
+// Emulation of types that are missing from old Platform SDKs.
+//
+// N.B. this emulation is also used if building for a Windows 2000 target with
+// a recent (i.e. Vista or later) SDK, as the SDK does not provide IPv6 support
+// in that case.
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+enum
+{
+  sockaddr_storage_maxsize = 128, // Maximum size.
+  sockaddr_storage_alignsize = (sizeof(__int64)), // Desired alignment.
+  sockaddr_storage_pad1size = (sockaddr_storage_alignsize - sizeof(short)),
+  sockaddr_storage_pad2size = (sockaddr_storage_maxsize -
+      (sizeof(short) + sockaddr_storage_pad1size + sockaddr_storage_alignsize))
+};
+
+struct sockaddr_storage_emulation
+{
+  short ss_family;
+  char __ss_pad1[sockaddr_storage_pad1size];
+  __int64 __ss_align;
+  char __ss_pad2[sockaddr_storage_pad2size];
+};
+
+struct in6_addr_emulation
+{
+  union
+  {
+    u_char Byte[16];
+    u_short Word[8];
+  } u;
+};
+
+#if !defined(s6_addr)
+# define _S6_un u
+# define _S6_u8 Byte
+# define s6_addr _S6_un._S6_u8
+#endif // !defined(s6_addr)
+
+struct sockaddr_in6_emulation
+{
+  short sin6_family;
+  u_short sin6_port;
+  u_long sin6_flowinfo;
+  in6_addr_emulation sin6_addr;
+  u_long sin6_scope_id;
+};
+
+struct ipv6_mreq_emulation
+{
+  in6_addr_emulation ipv6mr_multiaddr;
+  unsigned int ipv6mr_interface;
+};
+
+struct addrinfo_emulation
+{
+  int ai_flags;
+  int ai_family;
+  int ai_socktype;
+  int ai_protocol;
+  size_t ai_addrlen;
+  char* ai_canonname;
+  sockaddr* ai_addr;
+  addrinfo_emulation* ai_next;
+};
+
+#if !defined(AI_PASSIVE)
+# define AI_PASSIVE 0x1
+#endif
+
+#if !defined(AI_CANONNAME)
+# define AI_CANONNAME 0x2
+#endif
+
+#if !defined(AI_NUMERICHOST)
+# define AI_NUMERICHOST 0x4
+#endif
+
+#if !defined(EAI_AGAIN)
+# define EAI_AGAIN WSATRY_AGAIN
+#endif
+
+#if !defined(EAI_BADFLAGS)
+# define EAI_BADFLAGS WSAEINVAL
+#endif
+
+#if !defined(EAI_FAIL)
+# define EAI_FAIL WSANO_RECOVERY
+#endif
+
+#if !defined(EAI_FAMILY)
+# define EAI_FAMILY WSAEAFNOSUPPORT
+#endif
+
+#if !defined(EAI_MEMORY)
+# define EAI_MEMORY WSA_NOT_ENOUGH_MEMORY
+#endif
+
+#if !defined(EAI_NODATA)
+# define EAI_NODATA WSANO_DATA
+#endif
+
+#if !defined(EAI_NONAME)
+# define EAI_NONAME WSAHOST_NOT_FOUND
+#endif
+
+#if !defined(EAI_SERVICE)
+# define EAI_SERVICE WSATYPE_NOT_FOUND
+#endif
+
+#if !defined(EAI_SOCKTYPE)
+# define EAI_SOCKTYPE WSAESOCKTNOSUPPORT
+#endif
+
+#if !defined(NI_NOFQDN)
+# define NI_NOFQDN 0x01
+#endif
+
+#if !defined(NI_NUMERICHOST)
+# define NI_NUMERICHOST 0x02
+#endif
+
+#if !defined(NI_NAMEREQD)
+# define NI_NAMEREQD 0x04
+#endif
+
+#if !defined(NI_NUMERICSERV)
+# define NI_NUMERICSERV 0x08
+#endif
+
+#if !defined(NI_DGRAM)
+# define NI_DGRAM 0x10
+#endif
+
+#if !defined(IPPROTO_IPV6)
+# define IPPROTO_IPV6 41
+#endif
+
+#if !defined(IPV6_UNICAST_HOPS)
+# define IPV6_UNICAST_HOPS 4
+#endif
+
+#if !defined(IPV6_MULTICAST_IF)
+# define IPV6_MULTICAST_IF 9
+#endif
+
+#if !defined(IPV6_MULTICAST_HOPS)
+# define IPV6_MULTICAST_HOPS 10
+#endif
+
+#if !defined(IPV6_MULTICAST_LOOP)
+# define IPV6_MULTICAST_LOOP 11
+#endif
+
+#if !defined(IPV6_JOIN_GROUP)
+# define IPV6_JOIN_GROUP 12
+#endif
+
+#if !defined(IPV6_LEAVE_GROUP)
+# define IPV6_LEAVE_GROUP 13
+#endif
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // defined(STDNET_HAS_OLD_WIN_SDK)
+
+// Even newer Platform SDKs that support IPv6 may not define IPV6_V6ONLY.
+#if !defined(IPV6_V6ONLY)
+# define IPV6_V6ONLY 27
+#endif
+
+// Some SDKs (e.g. Windows CE) don't define IPPROTO_ICMPV6.
+#if !defined(IPPROTO_ICMPV6)
+# define IPPROTO_ICMPV6 58
+#endif
+
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#endif // STDNET_DETAIL_OLD_WIN_SDK_COMPAT_HPP
diff --git a/ip-address/include/std/net/detail/pop_options.hpp b/ip-address/include/std/net/detail/pop_options.hpp
new file mode 100644
index 0000000..8aa375e
--- /dev/null
+++ b/ip-address/include/std/net/detail/pop_options.hpp
@@ -0,0 +1,98 @@
+//
+// detail/pop_options.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// No header guard
+
+#if defined(__COMO__)
+
+// Comeau C++
+
+#elif defined(__DMC__)
+
+// Digital Mars C++
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) \
+  || defined(__ICC) || defined(__ECC)
+
+// Intel C++
+
+#elif defined(__GNUC__)
+
+// GNU C++
+
+# if defined(__MINGW32__) || defined(__CYGWIN__)
+#  pragma pack (pop)
+# endif
+
+# if defined(__OBJC__)
+#  if !defined(__APPLE_CC__) || (__APPLE_CC__ <= 1)
+#   if defined(STDNET_OBJC_WORKAROUND)
+#    undef Protocol
+#    undef id
+#    undef STDNET_OBJC_WORKAROUND
+#   endif
+#  endif
+# endif
+
+#elif defined(__KCC)
+
+// Kai C++
+
+#elif defined(__sgi)
+
+// SGI MIPSpro C++
+
+#elif defined(__DECCXX)
+
+// Compaq Tru64 Unix cxx
+
+#elif defined(__ghs)
+
+// Greenhills C++
+
+#elif defined(__BORLANDC__)
+
+// Borland C++
+
+# pragma option pop
+# pragma nopushoptwarn
+# pragma nopackwarning
+
+#elif defined(__MWERKS__)
+
+// Metrowerks CodeWarrior
+
+#elif defined(__SUNPRO_CC)
+
+// Sun Workshop Compiler C++
+
+#elif defined(__HP_aCC)
+
+// HP aCC
+
+#elif defined(__MRC__) || defined(__SC__)
+
+// MPW MrCpp or SCpp
+
+#elif defined(__IBMCPP__)
+
+// IBM Visual Age
+
+#elif defined(_MSC_VER)
+
+// Microsoft Visual C++
+//
+// Must remain the last #elif since some other vendors (Metrowerks, for example)
+// also #define _MSC_VER
+
+# pragma warning (pop)
+# pragma pack (pop)
+
+#endif
diff --git a/ip-address/include/std/net/detail/push_options.hpp b/ip-address/include/std/net/detail/push_options.hpp
new file mode 100644
index 0000000..ec64373
--- /dev/null
+++ b/ip-address/include/std/net/detail/push_options.hpp
@@ -0,0 +1,127 @@
+//
+// detail/push_options.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// No header guard
+
+#if defined(__COMO__)
+
+// Comeau C++
+
+#elif defined(__DMC__)
+
+// Digital Mars C++
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) \
+  || defined(__ICC) || defined(__ECC)
+
+// Intel C++
+
+#elif defined(__GNUC__)
+
+// GNU C++
+
+# if defined(__MINGW32__) || defined(__CYGWIN__)
+#  pragma pack (push, 8)
+# endif
+
+# if defined(__OBJC__)
+#  if !defined(__APPLE_CC__) || (__APPLE_CC__ <= 1)
+#   if !defined(STDNET_DISABLE_OBJC_WORKAROUND)
+#    if !defined(Protocol) && !defined(id)
+#     define Protocol cpp_Protocol
+#     define id cpp_id
+#     define STDNET_OBJC_WORKAROUND
+#    endif
+#   endif
+#  endif
+# endif
+
+#elif defined(__KCC)
+
+// Kai C++
+
+#elif defined(__sgi)
+
+// SGI MIPSpro C++
+
+#elif defined(__DECCXX)
+
+// Compaq Tru64 Unix cxx
+
+#elif defined(__ghs)
+
+// Greenhills C++
+
+#elif defined(__BORLANDC__)
+
+// Borland C++
+
+# pragma option push -a8 -b -Ve- -Vx- -w-inl -vi-
+# pragma nopushoptwarn
+# pragma nopackwarning
+# if !defined(__MT__)
+#  error Multithreaded RTL must be selected.
+# endif // !defined(__MT__)
+
+#elif defined(__MWERKS__)
+
+// Metrowerks CodeWarrior
+
+#elif defined(__SUNPRO_CC)
+
+// Sun Workshop Compiler C++
+
+#elif defined(__HP_aCC)
+
+// HP aCC
+
+#elif defined(__MRC__) || defined(__SC__)
+
+// MPW MrCpp or SCpp
+
+#elif defined(__IBMCPP__)
+
+// IBM Visual Age
+
+#elif defined(_MSC_VER)
+
+// Microsoft Visual C++
+//
+// Must remain the last #elif since some other vendors (Metrowerks, for example)
+// also #define _MSC_VER
+
+# pragma warning (disable:4103)
+# pragma warning (push)
+# pragma warning (disable:4127)
+# pragma warning (disable:4180)
+# pragma warning (disable:4244)
+# pragma warning (disable:4355)
+# pragma warning (disable:4512)
+# pragma warning (disable:4675)
+# if defined(_M_IX86) && defined(_Wp64)
+// The /Wp64 option is broken. If you want to check 64 bit portability, use a
+// 64 bit compiler!
+#  pragma warning (disable:4311)
+#  pragma warning (disable:4312)
+# endif // defined(_M_IX86) && defined(_Wp64)
+# pragma pack (push, 8)
+// Note that if the /Og optimisation flag is enabled with MSVC6, the compiler
+// has a tendency to incorrectly optimise away some calls to member template
+// functions, even though those functions contain code that should not be
+// optimised away! Therefore we will always disable this optimisation option
+// for the MSVC6 compiler.
+# if (_MSC_VER < 1300)
+#  pragma optimize ("g", off)
+# endif
+# if !defined(_MT)
+#  error Multithreaded RTL must be selected.
+# endif // !defined(_MT)
+
+#endif
diff --git a/ip-address/include/std/net/detail/socket_ops.hpp b/ip-address/include/std/net/detail/socket_ops.hpp
new file mode 100644
index 0000000..02cb8a4
--- /dev/null
+++ b/ip-address/include/std/net/detail/socket_ops.hpp
@@ -0,0 +1,57 @@
+//
+// detail/socket_ops.hpp
+// ~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_SOCKET_OPS_HPP
+#define STDNET_DETAIL_SOCKET_OPS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#include <system_error>
+#include "std/net/detail/socket_types.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace socket_ops {
+
+STDNET_DECL const char* inet_ntop(int af, const void* src, char* dest,
+    size_t length, unsigned long scope_id, std::error_code& ec);
+
+STDNET_DECL int inet_pton(int af, const char* src, void* dest,
+    unsigned long* scope_id, std::error_code& ec);
+
+STDNET_DECL u_long_type network_to_host_long(u_long_type value);
+
+STDNET_DECL u_long_type host_to_network_long(u_long_type value);
+
+STDNET_DECL u_short_type network_to_host_short(u_short_type value);
+
+STDNET_DECL u_short_type host_to_network_short(u_short_type value);
+
+} // namespace socket_ops
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/detail/impl/socket_ops.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_DETAIL_SOCKET_OPS_HPP
diff --git a/ip-address/include/std/net/detail/socket_types.hpp b/ip-address/include/std/net/detail/socket_types.hpp
new file mode 100644
index 0000000..ee35521
--- /dev/null
+++ b/ip-address/include/std/net/detail/socket_types.hpp
@@ -0,0 +1,186 @@
+//
+// detail/socket_types.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_SOCKET_TYPES_HPP
+#define STDNET_DETAIL_SOCKET_TYPES_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# if defined(_WINSOCKAPI_) && !defined(_WINSOCK2API_)
+#  error WinSock.h has already been included
+# endif // defined(_WINSOCKAPI_) && !defined(_WINSOCK2API_)
+# if defined(__BORLANDC__)
+#  include <stdlib.h> // Needed for __errno
+#  if !defined(_WSPIAPI_H_)
+#   define _WSPIAPI_H_
+#   define STDNET_WSPIAPI_H_DEFINED
+#  endif // !defined(_WSPIAPI_H_)
+# endif // defined(__BORLANDC__)
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# if defined(STDNET_WSPIAPI_H_DEFINED)
+#  undef _WSPIAPI_H_
+#  undef STDNET_WSPIAPI_H_DEFINED
+# endif // defined(STDNET_WSPIAPI_H_DEFINED)
+# if !defined(STDNET_NO_DEFAULT_LINKED_LIBS)
+#  if defined(UNDER_CE)
+#   pragma comment(lib, "ws2.lib")
+#  elif defined(_MSC_VER) || defined(__BORLANDC__)
+#   pragma comment(lib, "ws2_32.lib")
+#   pragma comment(lib, "mswsock.lib")
+#  endif // defined(_MSC_VER) || defined(__BORLANDC__)
+# endif // !defined(STDNET_NO_DEFAULT_LINKED_LIBS)
+# include "std/net/detail/old_win_sdk_compat.hpp"
+#else
+# include <sys/ioctl.h>
+# if !defined(__SYMBIAN32__)
+#  include <sys/poll.h>
+# endif
+# include <sys/types.h>
+# include <sys/stat.h>
+# include <fcntl.h>
+# if defined(__hpux)
+#  include <sys/time.h>
+# endif
+# if !defined(__hpux) || defined(__SELECT)
+#  include <sys/select.h>
+# endif
+# include <sys/socket.h>
+# include <sys/uio.h>
+# include <sys/un.h>
+# include <netinet/in.h>
+# if !defined(__SYMBIAN32__)
+#  include <netinet/tcp.h>
+# endif
+# include <arpa/inet.h>
+# include <netdb.h>
+# include <net/if.h>
+# include <limits.h>
+# if defined(__sun)
+#  include <sys/filio.h>
+#  include <sys/sockio.h>
+# endif
+#endif
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+typedef SOCKET socket_type;
+const SOCKET invalid_socket = INVALID_SOCKET;
+const int socket_error_retval = SOCKET_ERROR;
+const int max_addr_v4_str_len = 256;
+const int max_addr_v6_str_len = 256;
+typedef sockaddr socket_addr_type;
+typedef in_addr in4_addr_type;
+typedef ip_mreq in4_mreq_type;
+typedef sockaddr_in sockaddr_in4_type;
+# if defined(STDNET_HAS_OLD_WIN_SDK)
+typedef in6_addr_emulation in6_addr_type;
+typedef ipv6_mreq_emulation in6_mreq_type;
+typedef sockaddr_in6_emulation sockaddr_in6_type;
+typedef sockaddr_storage_emulation sockaddr_storage_type;
+typedef addrinfo_emulation addrinfo_type;
+# else
+typedef in6_addr in6_addr_type;
+typedef ipv6_mreq in6_mreq_type;
+typedef sockaddr_in6 sockaddr_in6_type;
+typedef sockaddr_storage sockaddr_storage_type;
+typedef addrinfo addrinfo_type;
+# endif
+typedef unsigned long ioctl_arg_type;
+typedef u_long u_long_type;
+typedef u_short u_short_type;
+typedef int signed_size_type;
+const int shutdown_receive = SD_RECEIVE;
+const int shutdown_send = SD_SEND;
+const int shutdown_both = SD_BOTH;
+const int message_peek = MSG_PEEK;
+const int message_out_of_band = MSG_OOB;
+const int message_do_not_route = MSG_DONTROUTE;
+const int message_end_of_record = 0; // Not supported on Windows.
+# if defined (_WIN32_WINNT)
+const int max_iov_len = 64;
+# else
+const int max_iov_len = 16;
+# endif
+#else
+typedef int socket_type;
+const int invalid_socket = -1;
+const int socket_error_retval = -1;
+const int max_addr_v4_str_len = INET_ADDRSTRLEN;
+#if defined(INET6_ADDRSTRLEN)
+const int max_addr_v6_str_len = INET6_ADDRSTRLEN + 1 + IF_NAMESIZE;
+#else // defined(INET6_ADDRSTRLEN)
+const int max_addr_v6_str_len = 256;
+#endif // defined(INET6_ADDRSTRLEN)
+typedef sockaddr socket_addr_type;
+typedef in_addr in4_addr_type;
+# if defined(__hpux)
+// HP-UX doesn't provide ip_mreq when _XOPEN_SOURCE_EXTENDED is defined.
+struct in4_mreq_type
+{
+  struct in_addr imr_multiaddr;
+  struct in_addr imr_interface;
+};
+# else
+typedef ip_mreq in4_mreq_type;
+# endif
+typedef sockaddr_in sockaddr_in4_type;
+typedef in6_addr in6_addr_type;
+typedef ipv6_mreq in6_mreq_type;
+typedef sockaddr_in6 sockaddr_in6_type;
+typedef sockaddr_storage sockaddr_storage_type;
+typedef sockaddr_un sockaddr_un_type;
+typedef addrinfo addrinfo_type;
+typedef int ioctl_arg_type;
+typedef uint32_t u_long_type;
+typedef uint16_t u_short_type;
+#if defined(STDNET_HAS_SSIZE_T)
+typedef ssize_t signed_size_type;
+#else // defined(STDNET_HAS_SSIZE_T)
+typedef int signed_size_type;
+#endif // defined(STDNET_HAS_SSIZE_T)
+const int shutdown_receive = SHUT_RD;
+const int shutdown_send = SHUT_WR;
+const int shutdown_both = SHUT_RDWR;
+const int message_peek = MSG_PEEK;
+const int message_out_of_band = MSG_OOB;
+const int message_do_not_route = MSG_DONTROUTE;
+const int message_end_of_record = MSG_EOR;
+# if defined(IOV_MAX)
+const int max_iov_len = IOV_MAX;
+# else
+// POSIX platforms are not required to define IOV_MAX.
+const int max_iov_len = 16;
+# endif
+#endif
+const int custom_socket_option_level = 0xA5100000;
+const int enable_connection_aborted_option = 1;
+const int always_fail_option = 2;
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_DETAIL_SOCKET_TYPES_HPP
diff --git a/ip-address/include/std/net/detail/system_errors.hpp b/ip-address/include/std/net/detail/system_errors.hpp
new file mode 100644
index 0000000..4aa5c44
--- /dev/null
+++ b/ip-address/include/std/net/detail/system_errors.hpp
@@ -0,0 +1,221 @@
+//
+// system_errors.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_SYSTEM_ERRORS_HPP
+#define STDNET_DETAIL_SYSTEM_ERRORS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <system_error>
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# include <winerror.h>
+#else
+# include <cerrno>
+#endif
+
+#if defined(GENERATING_DOCUMENTATION)
+/// INTERNAL ONLY.
+# define STDNET_NATIVE_ERROR(e) implementation_defined
+/// INTERNAL ONLY.
+# define STDNET_SOCKET_ERROR(e) implementation_defined
+/// INTERNAL ONLY.
+# define STDNET_NETDB_ERROR(e) implementation_defined
+/// INTERNAL ONLY.
+# define STDNET_GETADDRINFO_ERROR(e) implementation_defined
+/// INTERNAL ONLY.
+# define STDNET_WIN_OR_POSIX(e_win, e_posix) implementation_defined
+#elif defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# define STDNET_NATIVE_ERROR(e) e
+# define STDNET_SOCKET_ERROR(e) WSA ## e
+# define STDNET_NETDB_ERROR(e) WSA ## e
+# define STDNET_GETADDRINFO_ERROR(e) WSA ## e
+# define STDNET_WIN_OR_POSIX(e_win, e_posix) e_win
+#else
+# define STDNET_NATIVE_ERROR(e) e
+# define STDNET_SOCKET_ERROR(e) e
+# define STDNET_NETDB_ERROR(e) e
+# define STDNET_GETADDRINFO_ERROR(e) e
+# define STDNET_WIN_OR_POSIX(e_win, e_posix) e_posix
+#endif
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace syserrc {
+
+enum system_errors
+{
+  /// Permission denied.
+  access_denied = STDNET_SOCKET_ERROR(EACCES),
+
+  /// Address family not supported by protocol.
+  address_family_not_supported = STDNET_SOCKET_ERROR(EAFNOSUPPORT),
+
+  /// Address already in use.
+  address_in_use = STDNET_SOCKET_ERROR(EADDRINUSE),
+
+  /// Transport endpoint is already connected.
+  already_connected = STDNET_SOCKET_ERROR(EISCONN),
+
+  /// Operation already in progress.
+  already_started = STDNET_SOCKET_ERROR(EALREADY),
+
+  /// Broken pipe.
+  broken_pipe = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_BROKEN_PIPE),
+      STDNET_NATIVE_ERROR(EPIPE)),
+
+  /// A connection has been aborted.
+  connection_aborted = STDNET_SOCKET_ERROR(ECONNABORTED),
+
+  /// Connection refused.
+  connection_refused = STDNET_SOCKET_ERROR(ECONNREFUSED),
+
+  /// Connection reset by peer.
+  connection_reset = STDNET_SOCKET_ERROR(ECONNRESET),
+
+  /// Bad file descriptor.
+  bad_descriptor = STDNET_SOCKET_ERROR(EBADF),
+
+  /// Bad address.
+  fault = STDNET_SOCKET_ERROR(EFAULT),
+
+  /// No route to host.
+  host_unreachable = STDNET_SOCKET_ERROR(EHOSTUNREACH),
+
+  /// Operation now in progress.
+  in_progress = STDNET_SOCKET_ERROR(EINPROGRESS),
+
+  /// Interrupted system call.
+  interrupted = STDNET_SOCKET_ERROR(EINTR),
+
+  /// Invalid argument.
+  invalid_argument = STDNET_SOCKET_ERROR(EINVAL),
+
+  /// Message too long.
+  message_size = STDNET_SOCKET_ERROR(EMSGSIZE),
+
+  /// The name was too long.
+  name_too_long = STDNET_SOCKET_ERROR(ENAMETOOLONG),
+
+  /// Network is down.
+  network_down = STDNET_SOCKET_ERROR(ENETDOWN),
+
+  /// Network dropped connection on reset.
+  network_reset = STDNET_SOCKET_ERROR(ENETRESET),
+
+  /// Network is unreachable.
+  network_unreachable = STDNET_SOCKET_ERROR(ENETUNREACH),
+
+  /// Too many open files.
+  no_descriptors = STDNET_SOCKET_ERROR(EMFILE),
+
+  /// No buffer space available.
+  no_buffer_space = STDNET_SOCKET_ERROR(ENOBUFS),
+
+  /// Cannot allocate memory.
+  no_memory = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_OUTOFMEMORY),
+      STDNET_NATIVE_ERROR(ENOMEM)),
+
+  /// Operation not permitted.
+  no_permission = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_ACCESS_DENIED),
+      STDNET_NATIVE_ERROR(EPERM)),
+
+  /// Protocol not available.
+  no_protocol_option = STDNET_SOCKET_ERROR(ENOPROTOOPT),
+
+  /// Transport endpoint is not connected.
+  not_connected = STDNET_SOCKET_ERROR(ENOTCONN),
+
+  /// Socket operation on non-socket.
+  not_socket = STDNET_SOCKET_ERROR(ENOTSOCK),
+
+  /// Operation cancelled.
+  operation_aborted = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_OPERATION_ABORTED),
+      STDNET_NATIVE_ERROR(ECANCELED)),
+
+  /// Operation not supported.
+  operation_not_supported = STDNET_SOCKET_ERROR(EOPNOTSUPP),
+
+  /// Cannot send after transport endpoint shutdown.
+  shut_down = STDNET_SOCKET_ERROR(ESHUTDOWN),
+
+  /// Connection timed out.
+  timed_out = STDNET_SOCKET_ERROR(ETIMEDOUT),
+
+  /// Resource temporarily unavailable.
+  try_again = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_RETRY),
+      STDNET_NATIVE_ERROR(EAGAIN)),
+
+  /// The socket is marked non-blocking and the requested operation would block.
+  would_block = STDNET_SOCKET_ERROR(EWOULDBLOCK)
+};
+
+} // namespace syserrc
+
+/// Returns the error category used for the system errors.
+extern STDNET_DECL const std::error_category& system_category();
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+namespace std {
+
+template<> struct is_error_code_enum<
+  std::experimental::net::detail::syserrc::system_errors>
+{
+  static const bool value = true;
+};
+
+} // namespace std
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace syserrc {
+
+inline std::error_code make_error_code(system_errors e)
+{
+  return std::error_code(static_cast<int>(e),
+      std::experimental::net::detail::system_category());
+}
+
+} // namespace syserrc
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#undef STDNET_NATIVE_ERROR
+#undef STDNET_SOCKET_ERROR
+#undef STDNET_NETDB_ERROR
+#undef STDNET_GETADDRINFO_ERROR
+#undef STDNET_WIN_OR_POSIX
+
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/detail/impl/system_errors.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_DETAIL_SYSTEM_ERRORS_HPP
diff --git a/ip-address/include/std/net/detail/throw_error.hpp b/ip-address/include/std/net/detail/throw_error.hpp
new file mode 100644
index 0000000..4067cb7
--- /dev/null
+++ b/ip-address/include/std/net/detail/throw_error.hpp
@@ -0,0 +1,57 @@
+//
+// detail/throw_error.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_THROW_ERROR_HPP
+#define STDNET_DETAIL_THROW_ERROR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <system_error>
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+STDNET_DECL void do_throw_error(const std::error_code& err);
+
+STDNET_DECL void do_throw_error(const std::error_code& err,
+    const char* location);
+
+inline void throw_error(const std::error_code& err)
+{
+  if (err)
+    do_throw_error(err);
+}
+
+inline void throw_error(const std::error_code& err,
+    const char* location)
+{
+  if (err)
+    do_throw_error(err, location);
+}
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/detail/impl/throw_error.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_DETAIL_THROW_ERROR_HPP
diff --git a/ip-address/include/std/net/detail/throw_exception.hpp b/ip-address/include/std/net/detail/throw_exception.hpp
new file mode 100644
index 0000000..0903df1
--- /dev/null
+++ b/ip-address/include/std/net/detail/throw_exception.hpp
@@ -0,0 +1,45 @@
+//
+// detail/throw_exception.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_THROW_EXCEPTION_HPP
+#define STDNET_DETAIL_THROW_EXCEPTION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+// Declare the throw_exception function for all targets.
+template <typename Exception>
+void throw_exception(const Exception& e);
+
+// Only define the throw_exception function when exceptions are enabled.
+// Otherwise, it is up to the application to provide a definition of this
+// function.
+# if !defined(STDNET_NO_EXCEPTIONS)
+template <typename Exception>
+void throw_exception(const Exception& e)
+{
+  throw e;
+}
+# endif // !defined(STDNET_NO_EXCEPTIONS)
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#endif // STDNET_DETAIL_THROW_EXCEPTION_HPP
diff --git a/ip-address/include/std/net/detail/winsock_init.hpp b/ip-address/include/std/net/detail/winsock_init.hpp
new file mode 100644
index 0000000..fc008de
--- /dev/null
+++ b/ip-address/include/std/net/detail/winsock_init.hpp
@@ -0,0 +1,94 @@
+//
+// detail/winsock_init.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_WINSOCK_INIT_HPP
+#define STDNET_DETAIL_WINSOCK_INIT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+class winsock_init_base
+{
+protected:
+  // Structure to track result of initialisation and number of uses. POD is used
+  // to ensure that the values are zero-initialised prior to any code being run.
+  struct data
+  {
+    long init_count_;
+    long result_;
+  };
+
+  STDNET_DECL static void startup(data& d,
+      unsigned char major, unsigned char minor);
+
+  STDNET_DECL static void cleanup(data& d);
+
+  STDNET_DECL static void throw_on_error(data& d);
+};
+
+template <int Major = 2, int Minor = 0>
+class winsock_init : private winsock_init_base
+{
+public:
+  winsock_init(bool allow_throw = true)
+  {
+    startup(data_, Major, Minor);
+    if (allow_throw)
+      throw_on_error(data_);
+  }
+
+  winsock_init(const winsock_init&)
+  {
+    startup(data_, Major, Minor);
+    throw_on_error(data_);
+  }
+
+  ~winsock_init()
+  {
+    cleanup(data_);
+  }
+
+private:
+  static data data_;
+};
+
+template <int Major, int Minor>
+winsock_init_base::data winsock_init<Major, Minor>::data_;
+
+// Static variable to ensure that winsock is initialised before main, and
+// therefore before any other threads can get started.
+static const winsock_init<>& winsock_init_instance = winsock_init<>(false);
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/detail/impl/winsock_init.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#endif // STDNET_DETAIL_WINSOCK_INIT_HPP
diff --git a/ip-address/include/std/net/ip/address.hpp b/ip-address/include/std/net/ip/address.hpp
new file mode 100644
index 0000000..8a5e75a
--- /dev/null
+++ b/ip-address/include/std/net/ip/address.hpp
@@ -0,0 +1,328 @@
+//
+// ip/address.hpp
+// ~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_ADDRESS_HPP
+#define STDNET_IP_ADDRESS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <string>
+#include <system_error>
+#include <type_traits>
+#include "std/net/ip/fwd.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/address_v6.hpp"
+
+#if !defined(STDNET_NO_IOSTREAM)
+# include <iosfwd>
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+namespace detail {
+
+template <class T, class = void>
+struct is_convertible_to_address_1 : false_type {};
+
+template <class T>
+struct is_convertible_to_address_1<T,
+  typename enable_if<is_same<address,
+    decltype(address_cast<address>(declval<T>()))>::value>::type> : true_type {};
+
+template <class T>
+struct is_convertible_to_address : is_convertible_to_address_1<T> {};
+
+template <>
+struct is_convertible_to_address<address> : false_type {};
+
+} // namespace detail
+
+//template <> struct is_convertible_to_address<address> : false_type {};
+
+/// Implements version-independent IP addresses.
+/**
+ * The ip::address class provides the ability to use either IP version 4 or
+ * version 6 addresses.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class address
+{
+public:
+  /// Default constructor.
+  STDNET_CONSTEXPR address() STDNET_NOEXCEPT
+    : type_(invalid),
+      ipv4_address_(),
+      ipv6_address_()
+  {
+  }
+
+  /// Construct from another address type.
+  template <typename T,
+    typename = typename enable_if<
+      detail::is_convertible_to_address<T>::value>::type>
+  STDNET_CONSTEXPR address(const T& t) STDNET_NOEXCEPT;
+
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  /// Explicitly construct from a list of arguments.
+  template <typename... T,
+    typename = typename enable_if<is_same<address,
+      decltype(make_address(declval<T>()...))>::value>::type>
+  explicit STDNET_CONSTEXPR address(T&&... t);
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  template <typename T1>
+  explicit address(T1& t1, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1&>()))>::value>::type* = 0)
+      { *this = make_address(t1); }
+  template <typename T1>
+  explicit address(const T1& t1, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1>()))>::value>::type* = 0)
+      { *this = make_address(t1); }
+  template <typename T1, typename T2>
+  address(T1& t1, T2& t2, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1&>(), declval<T2&>()))>::value>::type* = 0)
+      { *this = make_address(t1, t2); }
+  template <typename T1, typename T2>
+  address(T1& t1, const T2& t2, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1&>(), declval<T2>()))>::value>::type* = 0)
+      { *this = make_address(t1, t2); }
+  template <typename T1, typename T2>
+  address(const T1& t1, T2& t2, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1>(), declval<T2&>()))>::value>::type* = 0)
+      { *this = make_address(t1, t2); }
+  template <typename T1, typename T2>
+  address(const T1& t1, const T2& t2, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1>(), declval<T2>()))>::value>::type* = 0)
+      { *this = make_address(t1, t2); }
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+  /// Copy constructor.
+  STDNET_CONSTEXPR address(const address& other) STDNET_NOEXCEPT
+    : type_(other.type_),
+      ipv4_address_(other.ipv4_address_),
+      ipv6_address_(other.ipv6_address_)
+  {
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move constructor.
+  address(address&& other) STDNET_NOEXCEPT
+    : type_(other.type_),
+      ipv4_address_(other.ipv4_address_),
+      ipv6_address_(other.ipv6_address_)
+  {
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Assign from another address.
+  address& operator=(const address& other) STDNET_NOEXCEPT
+  {
+    type_ = other.type_;
+    ipv4_address_ = other.ipv4_address_;
+    ipv6_address_ = other.ipv6_address_;
+    return *this;
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move-assign from another address.
+  address& operator=(address&& other) STDNET_NOEXCEPT
+  {
+    type_ = other.type_;
+    ipv4_address_ = other.ipv4_address_;
+    ipv6_address_ = other.ipv6_address_;
+    return *this;
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Get whether the address is an IP version 4 address.
+  STDNET_CONSTEXPR bool is_v4() const STDNET_NOEXCEPT
+  {
+    return type_ == ipv4;
+  }
+
+  /// Get whether the address is an IP version 6 address.
+  STDNET_CONSTEXPR bool is_v6() const STDNET_NOEXCEPT
+  {
+    return type_ == ipv6;
+  }
+
+  /// Get the address as a string in dotted decimal format.
+  STDNET_DECL std::string to_string() const;
+
+  /// Get the address as a string in dotted decimal format.
+  STDNET_DECL std::string to_string(std::error_code& ec) const;
+
+  /// Determine whether the address is a loopback address.
+  STDNET_CONSTEXPR bool is_loopback() const STDNET_NOEXCEPT
+  {
+    return (type_ == ipv4) ? ipv4_address_.is_loopback() :
+      (type_ == ipv6) ? ipv6_address_.is_loopback() : false;
+  }
+
+  /// Determine whether the address is unspecified.
+  STDNET_CONSTEXPR bool is_unspecified() const STDNET_NOEXCEPT
+  {
+    return (type_ == ipv4) ? ipv4_address_.is_unspecified() :
+      (type_ == ipv6) ? ipv6_address_.is_unspecified() : false;
+  }
+
+  /// Determine whether the address is a multicast address.
+  STDNET_CONSTEXPR bool is_multicast() const STDNET_NOEXCEPT
+  {
+    return (type_ == ipv4) ? ipv4_address_.is_multicast() :
+      (type_ == ipv6) ? ipv6_address_.is_multicast() : false;
+  }
+
+  /// Compare two addresses for equality.
+  friend bool operator==(const address& a1,
+      const address& a2) STDNET_NOEXCEPT
+  {
+    if (a1.type_ != a2.type_)
+      return false;
+    if (a1.type_ == address::ipv4)
+      return a1.ipv4_address_ == a2.ipv4_address_;
+    if (a1.type_ == address::ipv6)
+      return a1.ipv4_address_ == a2.ipv4_address_;
+    return true;
+  }
+
+  /// Compare two addresses for inequality.
+  friend bool operator!=(const address& a1, const address& a2) STDNET_NOEXCEPT
+  {
+    return !(a1 == a2);
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<(const address& a1,
+      const address& a2) STDNET_NOEXCEPT
+  {
+    if (a1.type_ < a2.type_)
+      return true;
+    if (a1.type_ > a2.type_)
+      return false;
+    if (a1.type_ == address::ipv4)
+      return a1.ipv4_address_ < a2.ipv4_address_;
+    if (a1.type_ == address::ipv6)
+      return a1.ipv6_address_ < a2.ipv6_address_;
+    return false;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>(const address& a1, const address& a2) STDNET_NOEXCEPT
+  {
+    return a2 < a1;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<=(const address& a1, const address& a2) STDNET_NOEXCEPT
+  {
+    return !(a2 < a1);
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>=(const address& a1, const address& a2) STDNET_NOEXCEPT
+  {
+    return !(a1 < a2);
+  }
+
+private:
+  friend class address_v4;
+  friend class address_v6;
+
+  // The type of the address.
+  enum address_type { invalid, ipv4, ipv6 } type_;
+
+  // The underlying IPv4 address.
+  address_v4 ipv4_address_;
+
+  // The underlying IPv6 address.
+  address_v6 ipv6_address_;
+
+  // Helper constructor for address_cast.
+  STDNET_CONSTEXPR address(address_type type,
+      const address_v4& v4, const address_v6& v6)
+    : type_(type),
+      ipv4_address_(v4),
+      ipv6_address_(v6)
+  {
+  }
+
+  template <class T> friend STDNET_CONSTEXPR T address_cast(const address&,
+    typename enable_if<is_same<T, address_v4>::value>::type*);
+  template <class T> friend STDNET_CONSTEXPR T address_cast(const address&,
+    typename enable_if<is_same<T, address_v6>::value>::type*);
+  template <class T> friend STDNET_CONSTEXPR T address_cast(const address_v4&,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT;
+  template <class T> friend STDNET_CONSTEXPR T address_cast(const address_v6&,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT;
+};
+
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
+STDNET_DECL address make_address(const char* str);
+
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
+STDNET_DECL address make_address(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
+STDNET_DECL address make_address(const std::string& str);
+
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
+STDNET_DECL address make_address(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+/// Output an address as a string.
+/**
+ * Used to output a human-readable string for a specified address.
+ *
+ * @param os The output stream to which the string will be written.
+ *
+ * @param addr The address to be written.
+ *
+ * @return The output stream.
+ *
+ * @relates std::experimental::net::ip::address
+ */
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address& addr);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#include "std/net/ip/impl/address.hpp"
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/ip/impl/address.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#include "std/net/ip/address_cast.hpp"
+
+#endif // STDNET_IP_ADDRESS_HPP
diff --git a/ip-address/include/std/net/ip/address_cast.hpp b/ip-address/include/std/net/ip/address_cast.hpp
new file mode 100644
index 0000000..dae3d02
--- /dev/null
+++ b/ip-address/include/std/net/ip/address_cast.hpp
@@ -0,0 +1,106 @@
+//
+// ip/address_cast.hpp
+// ~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_ADDRESS_CAST_HPP
+#define STDNET_IP_ADDRESS_CAST_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include "std/net/detail/throw_exception.hpp"
+#include "std/net/ip/fwd.hpp"
+#include "std/net/ip/address.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/address_v6.hpp"
+#include "std/net/ip/bad_address_cast.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+/// Cast a version-independent address to itself.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address& addr,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT
+{
+  return addr;
+}
+
+/// Cast a version-independent address to an IPv4 address.
+/**
+ * @throws bad_address_cast if @c a does not represent an IPv4 address.
+ */
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address& addr,
+    typename enable_if<is_same<T, address_v4>::value>::type*)
+{
+  return (addr.type_ != address::ipv4)
+    ? throw bad_address_cast()
+    : addr.ipv4_address_;
+}
+
+/// Cast a version-independent address to an IPv6 address.
+/**
+ * @throws bad_address_cast if @c a does not represent an IPv6 address.
+ */
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address& addr,
+    typename enable_if<is_same<T, address_v6>::value>::type*)
+{
+  return (addr.type_ != address::ipv6)
+    ? throw bad_address_cast()
+    : addr.ipv6_address_;
+}
+
+/// Cast an IPv4 address to a version-independent address.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address_v4& addr,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT
+{
+  return address(address::ipv4, addr, address_v6());
+}
+
+/// Cast an IPv4 address to itself.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address_v4& addr,
+    typename enable_if<is_same<T, address_v4>::value>::type*) STDNET_NOEXCEPT
+{
+  return addr;
+}
+
+/// Cast an IPv6 address to a version-independent address.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address_v6& addr,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT
+{
+  return address(address::ipv6, address_v4(), addr);
+}
+
+/// Cast an IPv6 address to itself.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address_v6& addr,
+    typename enable_if<is_same<T, address_v6>::value>::type*) STDNET_NOEXCEPT
+{
+  return addr;
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_ADDRESS_CAST_HPP
diff --git a/ip-address/include/std/net/ip/address_v4.hpp b/ip-address/include/std/net/ip/address_v4.hpp
new file mode 100644
index 0000000..a7b9234
--- /dev/null
+++ b/ip-address/include/std/net/ip/address_v4.hpp
@@ -0,0 +1,376 @@
+//
+// ip/address_v4.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_ADDRESS_V4_HPP
+#define STDNET_IP_ADDRESS_V4_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <array>
+#include <string>
+#include <system_error>
+#include "std/net/ip/fwd.hpp"
+#include "std/net/detail/winsock_init.hpp"
+
+#if !defined(STDNET_NO_IOSTREAM)
+# include <iosfwd>
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+class address;
+
+/// Implements IP version 4 style addresses.
+/**
+ * The ip::address_v4 class provides the ability to use and manipulate IP
+ * version 4 addresses.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class address_v4
+{
+public:
+  /// A standard-layout type used to represent an address as an array of bytes.
+  struct bytes_type : std::array<unsigned char, 4>
+  {
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+    template <class... T>
+    explicit STDNET_CONSTEXPR bytes_type(T... t)
+      : std::array<unsigned char, 4>{{static_cast<unsigned char>(t)...}}
+    {
+    }
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+    explicit STDNET_CONSTEXPR bytes_type(unsigned char a = 0,
+        unsigned char b = 0, unsigned char c = 0, unsigned char d = 0)
+# if defined(STDNET_HAS_CONSTEXPR)
+      : std::array<unsigned char, 4>{{a, b, c, d}}
+    {
+    }
+# else // defined(STDNET_HAS_CONSTEXPR)
+    {
+      (*this)[0] = a, (*this)[1] = b, (*this)[2] = c, (*this)[3] = d;
+    }
+# endif // defined(STDNET_HAS_CONSTEXPR)
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  };
+
+  /// Default constructor.
+  STDNET_CONSTEXPR address_v4() STDNET_NOEXCEPT
+    : bytes_(0, 0, 0, 0)
+  {
+  }
+
+  /// Implicit construction from bytes, in network byte order.
+  STDNET_CONSTEXPR address_v4(const bytes_type& bytes)
+    : bytes_(
+#if UCHAR_MAX > 0xFF
+        (bytes[0] > 0xFF || bytes[1] > 0xFF || bytes[2] > 0xFF || bytes[3] > 0xFF)
+        ? throw std::out_of_range("address_v4 from bytes_type") :
+#endif // UCHAR_MAX > 0xFF
+        bytes)
+  {
+  }
+
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  /// Explicitly construct from a list of arguments.
+  template <typename... T,
+    typename = typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T>()...))>::value>::type>
+  explicit STDNET_CONSTEXPR address_v4(T&&... t)
+    : address_v4(make_address_v4(static_cast<T&&>(t)...))
+  {
+  }
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  template <typename T1>
+  explicit STDNET_CONSTEXPR address_v4(T1& t1,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1&>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1).to_bytes()) {}
+  template <typename T1>
+  explicit STDNET_CONSTEXPR address_v4(const T1& t1,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v4(T1& t1, T2& t2,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1&>(), declval<T2&>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v4(T1& t1, const T2& t2,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1&>(), declval<T2>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v4(const T1& t1, T2& t2,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1>(), declval<T2&>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v4(const T1& t1, const T2& t2,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1>(), declval<T2>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1, t2).to_bytes()) {}
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+  /// Copy constructor.
+  STDNET_CONSTEXPR address_v4(const address_v4& other) STDNET_NOEXCEPT
+    : bytes_(other.bytes_)
+  {
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move constructor.
+  address_v4(address_v4&& other) STDNET_NOEXCEPT
+    : bytes_(other.bytes_)
+  {
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Assign from another address.
+  address_v4& operator=(const address_v4& other) STDNET_NOEXCEPT
+  {
+    bytes_ = other.bytes_;
+    return *this;
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move-assign from another address.
+  address_v4& operator=(address_v4&& other) STDNET_NOEXCEPT
+  {
+    bytes_ = other.bytes_;
+    return *this;
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Get the address in bytes, in network byte order.
+  STDNET_CONSTEXPR bytes_type to_bytes() const STDNET_NOEXCEPT
+  {
+    return bytes_;
+  }
+
+  /// Get the address as an unsigned long in host byte order
+  STDNET_CONSTEXPR unsigned long to_ulong() const STDNET_NOEXCEPT
+  {
+    return (static_cast<unsigned long>(bytes_[0]) << 24)
+      | (static_cast<unsigned long>(bytes_[1]) << 16)
+      | (static_cast<unsigned long>(bytes_[2]) << 8)
+      | static_cast<unsigned long>(bytes_[3]);
+  }
+
+  /// Get the address as a string in dotted decimal format.
+  STDNET_DECL std::string to_string() const;
+
+  /// Get the address as a string in dotted decimal format.
+  STDNET_DECL std::string to_string(std::error_code& ec) const;
+
+  /// Determine whether the address is a loopback address.
+  STDNET_CONSTEXPR bool is_loopback() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0xFF000000) == 0x7F000000;
+  }
+
+  /// Determine whether the address is unspecified.
+  STDNET_CONSTEXPR bool is_unspecified() const STDNET_NOEXCEPT
+  {
+    return to_ulong() == 0;
+  }
+
+  /// Determine whether the address is a class A address.
+  STDNET_CONSTEXPR bool is_class_a() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0x80000000) == 0;
+  }
+
+  /// Determine whether the address is a class B address.
+  STDNET_CONSTEXPR bool is_class_b() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0xC0000000) == 0x80000000;
+  }
+
+  /// Determine whether the address is a class C address.
+  STDNET_CONSTEXPR bool is_class_c() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0xE0000000) == 0xC0000000;
+  }
+
+  /// Determine whether the address is a multicast address.
+  STDNET_CONSTEXPR bool is_multicast() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0xF0000000) == 0xE0000000;
+  }
+
+  /// Compare two addresses for equality.
+  friend bool operator==(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.bytes_ == a2.bytes_;
+  }
+
+  /// Compare two addresses for inequality.
+  friend bool operator!=(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.bytes_ == a2.bytes_;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.to_ulong() < a2.to_ulong();
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.to_ulong() > a2.to_ulong();
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<=(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.to_ulong() <= a2.to_ulong();
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>=(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.to_ulong() >= a2.to_ulong();
+  }
+
+  /// Obtain an address object that represents any address.
+  static STDNET_CONSTEXPR address_v4 any() STDNET_NOEXCEPT
+  {
+    return address_v4();
+  }
+
+  /// Obtain an address object that represents the loopback address.
+  static STDNET_CONSTEXPR address_v4 loopback() STDNET_NOEXCEPT
+  {
+    return address_v4(0x7F000001);
+  }
+
+  /// Obtain an address object that represents the broadcast address.
+  static STDNET_CONSTEXPR address_v4 broadcast() STDNET_NOEXCEPT
+  {
+    return address_v4(0xFFFFFFFF);
+  }
+
+  /// Obtain an address object that represents the broadcast address that
+  /// corresponds to the specified address and netmask.
+  static STDNET_CONSTEXPR address_v4 broadcast(const address_v4& addr,
+      const address_v4& mask) STDNET_NOEXCEPT
+  {
+    return address_v4(addr.to_ulong() | (mask.to_ulong() ^ 0xFFFFFFFF));
+  }
+
+private:
+  // The underlying IPv4 address.
+  bytes_type bytes_;
+};
+
+/// Construct an address_v4 from raw bytes.
+inline STDNET_CONSTEXPR address_v4 make_address_v4(const address_v4::bytes_type& bytes)
+{
+  return bytes;
+}
+
+/// Construct an address_v4 from a unsigned long in host byte order.
+inline STDNET_CONSTEXPR address_v4 make_address_v4(unsigned long addr)
+{
+  return
+#if ULONG_MAX > 0xFFFFFFFF
+    (addr > 0xFFFFFFFF)
+    ? throw std::out_of_range("address_v4 from unsigned long") :
+#endif // ULONG_MAX > 0xFFFFFFFF
+    address_v4::bytes_type((addr >> 24) & 0xFF,
+      (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF);
+}
+
+/// Create an address_v4 from an IPv4 address string in dotted decimal form.
+STDNET_DECL address_v4 make_address_v4(const char* str);
+
+/// Create an address_v4 from an IPv4 address string in dotted decimal form.
+STDNET_DECL address_v4 make_address_v4(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+/// Create an address_v4 from an IPv4 address string in dotted decimal form.
+STDNET_DECL address_v4 make_address_v4(const std::string& str);
+
+/// Create an address_v4 from an IPv4 address string in dotted decimal form.
+STDNET_DECL address_v4 make_address_v4(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+#if defined(STDNET_HAS_CONSTEXPR)
+
+/// The IPv4 unspecified address.
+STDNET_CONSTEXPR address_v4 any_v4(0);
+
+/// The IPv4 loopback address.
+STDNET_CONSTEXPR address_v4 loopback_v4(0x7F000001);
+
+/// The IPv4 broadcast address.
+STDNET_CONSTEXPR address_v4 broadcast_v4(0xFFFFFFFF);
+
+#else // defined(STDNET_HAS_CONSTEXPR)
+
+static const address_v4 any_v4(0);
+static const address_v4 loopback_v4(0x7F000001);
+static const address_v4 broadcast_v4(0xFFFFFFFF);
+
+#endif // defined(STDNET_HAS_CONSTEXPR)
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+/// Output an address as a string.
+/**
+ * Used to output a human-readable string for a specified address.
+ *
+ * @param os The output stream to which the string will be written.
+ *
+ * @param addr The address to be written.
+ *
+ * @return The output stream.
+ *
+ * @relates std::experimental::net::ip::address_v4
+ */
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address_v4& addr);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#include "std/net/ip/impl/address_v4.hpp"
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/ip/impl/address_v4.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_IP_ADDRESS_V4_HPP
diff --git a/ip-address/include/std/net/ip/address_v6.hpp b/ip-address/include/std/net/ip/address_v6.hpp
new file mode 100644
index 0000000..3c4f440
--- /dev/null
+++ b/ip-address/include/std/net/ip/address_v6.hpp
@@ -0,0 +1,440 @@
+//
+// ip/address_v6.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_ADDRESS_V6_HPP
+#define STDNET_IP_ADDRESS_V6_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <array>
+#include <string>
+#include <system_error>
+#include "std/net/ip/fwd.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/bad_address_cast.hpp"
+#include "std/net/detail/winsock_init.hpp"
+
+#if !defined(STDNET_NO_IOSTREAM)
+# include <iosfwd>
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+class address;
+class address_v4;
+
+/// Implements IP version 6 style addresses.
+/**
+ * The ip::address_v6 class provides the ability to use and manipulate IP
+ * version 6 addresses.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class address_v6
+{
+public:
+  /// A standard-layout type used to represent an address as an array of bytes.
+  struct bytes_type : std::array<unsigned char, 16>
+  {
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+    template <class... T>
+    explicit STDNET_CONSTEXPR bytes_type(T... t)
+      : std::array<unsigned char, 16>{{static_cast<unsigned char>(t)...}}
+    {
+    }
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+    explicit STDNET_CONSTEXPR bytes_type(
+        unsigned char a = 0, unsigned char b = 0,
+        unsigned char c = 0, unsigned char d = 0,
+        unsigned char e = 0, unsigned char f = 0,
+        unsigned char g = 0, unsigned char h = 0,
+        unsigned char i = 0, unsigned char j = 0,
+        unsigned char k = 0, unsigned char l = 0,
+        unsigned char m = 0, unsigned char n = 0,
+        unsigned char o = 0, unsigned char p = 0)
+# if defined(STDNET_HAS_CONSTEXPR)
+      : std::array<unsigned char, 16>{{a, b, c, d, e, f, g, h, i, h, k, l, m, n, o, p}}
+    {
+    }
+# else // defined(STDNET_HAS_CONSTEXPR)
+    {
+      (*this)[0] = a, (*this)[1] = b, (*this)[2] = c, (*this)[3] = d;
+      (*this)[4] = e, (*this)[5] = f, (*this)[6] = g, (*this)[7] = h;
+      (*this)[8] = i, (*this)[9] = j, (*this)[10] = k, (*this)[11] = l;
+      (*this)[12] = m, (*this)[13] = n, (*this)[14] = o, (*this)[15] = p;
+    }
+# endif // defined(STDNET_HAS_CONSTEXPR)
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  };
+
+  /// Default constructor.
+  STDNET_CONSTEXPR address_v6() STDNET_NOEXCEPT
+    : bytes_(0),
+      scope_id_(0)
+  {
+  }
+
+  /// Implicit construction from bytes, in network byte order.
+  STDNET_CONSTEXPR address_v6(const bytes_type& bytes, unsigned long scope = 0)
+    : bytes_(
+#if UCHAR_MAX > 0xFF
+        (bytes[0] > 0xFF || bytes[1] > 0xFF || bytes[2] > 0xFF || bytes[3] > 0xFF
+        || bytes[4] > 0xFF || bytes[5] > 0xFF || bytes[6] > 0xFF || bytes[7] > 0xFF
+        || bytes[8] > 0xFF || bytes[9] > 0xFF || bytes[10] > 0xFF || bytes[11] > 0xFF
+        || bytes[12] > 0xFF || bytes[13] > 0xFF || bytes[14] > 0xFF || bytes[15] > 0xFF)
+        ? throw std::out_of_range("address_v6 from bytes_type") :
+#endif // UCHAR_MAX > 0xFF
+        bytes),
+      scope_id_(scope)
+  {
+  }
+
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  /// Explicitly construct from a list of arguments.
+  template <typename... T,
+    typename = typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T>()...))>::value>::type>
+  explicit STDNET_CONSTEXPR address_v6(T&&... t)
+    : address_v6(make_address_v6(static_cast<T&&>(t)...))
+  {
+  }
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  template <typename T1>
+  explicit STDNET_CONSTEXPR address_v6(T1& t1,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1&>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1).to_bytes()) {}
+  template <typename T1>
+  explicit STDNET_CONSTEXPR address_v6(const T1& t1,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v6(T1& t1, T2& t2,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1&>(), declval<T2&>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v6(T1& t1, const T2& t2,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1&>(), declval<T2>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v6(const T1& t1, T2& t2,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1>(), declval<T2&>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v6(const T1& t1, const T2& t2,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1>(), declval<T2>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1, t2).to_bytes()) {}
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+  /// Copy constructor.
+  STDNET_CONSTEXPR address_v6(const address_v6& other) STDNET_NOEXCEPT
+    : bytes_(other.bytes_), scope_id_(other.scope_id_)
+  {
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move constructor.
+  address_v6(address_v6&& other) STDNET_NOEXCEPT
+    : bytes_(other.bytes_), scope_id_(other.scope_id_)
+  {
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Assign from another address.
+  address_v6& operator=(const address_v6& other) STDNET_NOEXCEPT
+  {
+    bytes_ = other.bytes_;
+    scope_id_ = other.scope_id_;
+    return *this;
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move-assign from another address.
+  address_v6& operator=(address_v6&& other) STDNET_NOEXCEPT
+  {
+    bytes_ = other.bytes_;
+    scope_id_ = other.scope_id_;
+    return *this;
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// The scope ID of the address.
+  /**
+   * Returns the scope ID associated with the IPv6 address.
+   */
+  STDNET_CONSTEXPR unsigned long scope_id() const STDNET_NOEXCEPT
+  {
+    return scope_id_;
+  }
+
+  /// The scope ID of the address.
+  /**
+   * Modifies the scope ID associated with the IPv6 address.
+   */
+  void scope_id(unsigned long id) STDNET_NOEXCEPT
+  {
+    scope_id_ = id;
+  }
+
+  /// Get the address in bytes, in network byte order.
+  STDNET_CONSTEXPR bytes_type to_bytes() const STDNET_NOEXCEPT
+  {
+    return bytes_;
+  }
+
+  /// Get the address as a string.
+  STDNET_DECL std::string to_string() const;
+
+  /// Get the address as a string.
+  STDNET_DECL std::string to_string(std::error_code& ec) const;
+
+  /// Determine whether the address is a loopback address.
+  STDNET_CONSTEXPR bool is_loopback() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0) && (bytes_[1] == 0)
+        && (bytes_[2] == 0) && (bytes_[3] == 0)
+        && (bytes_[4] == 0) && (bytes_[5] == 0)
+        && (bytes_[6] == 0) && (bytes_[7] == 0)
+        && (bytes_[8] == 0) && (bytes_[9] == 0)
+        && (bytes_[10] == 0) && (bytes_[11] == 0)
+        && (bytes_[12] == 0) && (bytes_[13] == 0)
+        && (bytes_[14] == 0) && (bytes_[15] == 1));
+  }
+
+  /// Determine whether the address is unspecified.
+  STDNET_CONSTEXPR bool is_unspecified() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0) && (bytes_[1] == 0)
+        && (bytes_[2] == 0) && (bytes_[3] == 0)
+        && (bytes_[4] == 0) && (bytes_[5] == 0)
+        && (bytes_[6] == 0) && (bytes_[7] == 0)
+        && (bytes_[8] == 0) && (bytes_[9] == 0)
+        && (bytes_[10] == 0) && (bytes_[11] == 0)
+        && (bytes_[12] == 0) && (bytes_[13] == 0)
+        && (bytes_[14] == 0) && (bytes_[15] == 0));
+  }
+
+  /// Determine whether the address is link local.
+  STDNET_CONSTEXPR bool is_link_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xfe) && ((bytes_[1] & 0xc0) == 0x80));
+  }
+
+  /// Determine whether the address is site local.
+  STDNET_CONSTEXPR bool is_site_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xfe) && ((bytes_[1] & 0xc0) == 0xc0));
+  }
+
+  /// Determine whether the address is a mapped IPv4 address.
+  STDNET_CONSTEXPR bool is_v4_mapped() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0) && (bytes_[1] == 0)
+        && (bytes_[2] == 0) && (bytes_[3] == 0)
+        && (bytes_[4] == 0) && (bytes_[5] == 0)
+        && (bytes_[6] == 0) && (bytes_[7] == 0)
+        && (bytes_[8] == 0) && (bytes_[9] == 0)
+        && (bytes_[10] == 0xff) && (bytes_[11] == 0xff));
+  }
+
+  /// Determine whether the address is a multicast address.
+  STDNET_CONSTEXPR bool is_multicast() const STDNET_NOEXCEPT
+  {
+    return (bytes_[0] == 0xff);
+  }
+
+  /// Determine whether the address is a global multicast address.
+  STDNET_CONSTEXPR bool is_multicast_global() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x0e));
+  }
+
+  /// Determine whether the address is a link-local multicast address.
+  STDNET_CONSTEXPR bool is_multicast_link_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x02));
+  }
+
+  /// Determine whether the address is a node-local multicast address.
+  STDNET_CONSTEXPR bool is_multicast_node_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x01));
+  }
+
+  /// Determine whether the address is a org-local multicast address.
+  STDNET_CONSTEXPR bool is_multicast_org_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x08));
+  }
+
+  /// Determine whether the address is a site-local multicast address.
+  STDNET_CONSTEXPR bool is_multicast_site_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x05));
+  }
+
+  /// Compare two addresses for equality.
+  friend bool operator==(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return a1.bytes_ == a2.bytes_ && a1.scope_id_ == a2.scope_id_;
+  }
+
+  /// Compare two addresses for inequality.
+  friend bool operator!=(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return !(a1 == a2);
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    if (a1.bytes_ < a2.bytes_)
+      return true;
+    if (a1.bytes_ > a2.bytes_)
+      return false;
+    return a1.scope_id_ < a2.scope_id_;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return a2 < a1;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<=(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return !(a2 < a1);
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>=(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return !(a1 < a2);
+  }
+
+  /// Obtain an address object that represents any address.
+  static STDNET_CONSTEXPR address_v6 any() STDNET_NOEXCEPT
+  {
+    return address_v6();
+  }
+
+  /// Obtain an address object that represents the loopback address.
+  static STDNET_CONSTEXPR address_v6 loopback() STDNET_NOEXCEPT
+  {
+    return bytes_type(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+  }
+
+private:
+  friend STDNET_CONSTEXPR address_v4 make_address_v4(
+      v4_mapped_t, const address_v6&);
+
+  // The underlying IPv6 address.
+  bytes_type bytes_;
+
+  // The scope ID associated with the address.
+  unsigned long scope_id_;
+};
+
+/// Construct an address_v6 from raw bytes.
+inline STDNET_CONSTEXPR address_v6 make_address_v6(
+    const address_v6::bytes_type& bytes, unsigned long scope_id = 0)
+{
+  return address_v6(bytes, scope_id);
+}
+
+/// Create an address_v6 from an IPv6 address string.
+STDNET_DECL address_v6 make_address_v6(const char* str);
+
+/// Create an address_v6 from an IPv6 address string.
+STDNET_DECL address_v6 make_address_v6(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+/// Create an address_v6 from an IPv6 address string.
+STDNET_DECL address_v6 make_address_v6(const std::string& str);
+
+/// Create an address_v6 from an IPv6 address string.
+STDNET_DECL address_v6 make_address_v6(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+/// Create an IPv4-mapped address_v6 from an IPv4 address.
+inline STDNET_CONSTEXPR address_v6 make_address_v6(
+    v4_mapped_t, const address_v4& addr) STDNET_NOEXCEPT
+{
+  return address_v6::bytes_type(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF,
+      static_cast<const address_v4::bytes_type>(addr.to_bytes())[0],
+      static_cast<const address_v4::bytes_type>(addr.to_bytes())[1],
+      static_cast<const address_v4::bytes_type>(addr.to_bytes())[2],
+      static_cast<const address_v4::bytes_type>(addr.to_bytes())[3]);
+}
+
+/// Create an address_v4 from an IPv4-mapped address_v6.
+inline STDNET_CONSTEXPR address_v4 make_address_v4(
+    v4_mapped_t, const address_v6& addr)
+{
+  return !addr.is_v4_mapped() ? throw bad_address_cast() :
+    address_v4::bytes_type(addr.bytes_[12], addr.bytes_[13],
+        addr.bytes_[14], addr.bytes_[15]);
+}
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+/// Output an address as a string.
+/**
+ * Used to output a human-readable string for a specified address.
+ *
+ * @param os The output stream to which the string will be written.
+ *
+ * @param addr The address to be written.
+ *
+ * @return The output stream.
+ *
+ * @relates std::experimental::net::ip::address_v6
+ */
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address_v6& addr);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#include "std/net/ip/impl/address_v6.hpp"
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/ip/impl/address_v6.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_IP_ADDRESS_V6_HPP
diff --git a/ip-address/include/std/net/ip/bad_address_cast.hpp b/ip-address/include/std/net/ip/bad_address_cast.hpp
new file mode 100644
index 0000000..bc330c2
--- /dev/null
+++ b/ip-address/include/std/net/ip/bad_address_cast.hpp
@@ -0,0 +1,46 @@
+//
+// ip/bad_address_cast.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_BAD_ADDRESS_CAST_HPP
+#define STDNET_IP_BAD_ADDRESS_CAST_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <typeinfo>
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+/// Exception thrown on a failed address_cast.
+class bad_address_cast
+  : public bad_cast
+{
+public:
+  virtual const char* what() const STDNET_NOEXCEPT
+  {
+    return "bad address cast";
+  }
+};
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_BAD_ADDRESS_CAST_HPP
diff --git a/ip-address/include/std/net/ip/fwd.hpp b/ip-address/include/std/net/ip/fwd.hpp
new file mode 100644
index 0000000..2c8f929
--- /dev/null
+++ b/ip-address/include/std/net/ip/fwd.hpp
@@ -0,0 +1,149 @@
+//
+// ip/fwd.hpp
+// ~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_FWD_HPP
+#define STDNET_IP_FWD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <array>
+#include <string>
+#include <system_error>
+#include <type_traits>
+
+#if !defined(STDNET_NO_IOSTREAM)
+# include <iosfwd>
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+#if defined(STDNET_HAS_CONSTEXPR)
+struct v4_mapped_t { STDNET_CONSTEXPR v4_mapped_t() {} };
+STDNET_CONSTEXPR v4_mapped_t v4_mapped;
+#else // !defined(STDNET_HAS_CONSTEXPR)
+enum v4_mapped_t { v4_mapped };
+#endif // !defined(STDNET_HAS_CONSTEXPR)
+
+class address;
+class address_v4;
+class address_v6;
+
+// address comparisons:
+bool operator==(const address&, const address&) STDNET_NOEXCEPT;
+bool operator!=(const address&, const address&) STDNET_NOEXCEPT;
+bool operator< (const address&, const address&) STDNET_NOEXCEPT;
+bool operator> (const address&, const address&) STDNET_NOEXCEPT;
+bool operator<=(const address&, const address&) STDNET_NOEXCEPT;
+bool operator>=(const address&, const address&) STDNET_NOEXCEPT;
+
+// address creation:
+address make_address(const char*);
+address make_address(const char*, std::error_code&) STDNET_NOEXCEPT;
+address make_address(const std::string&);
+address make_address(const std::string&, std::error_code&) STDNET_NOEXCEPT;
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+// address I/O:
+template<class CharT, class Traits>
+  basic_ostream<CharT, Traits>& operator<<(
+    basic_ostream<CharT, Traits>&, const address&);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+// address_v4 comparisons:
+bool operator==(const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator!=(const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator< (const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator> (const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator<=(const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator>=(const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+
+// address_v4 creation:
+//STDNET_CONSTEXPR address_v4 make_address_v4(const address_v4::octets&);
+STDNET_CONSTEXPR address_v4 make_address_v4(unsigned long);
+STDNET_CONSTEXPR address_v4 make_address_v4(v4_mapped_t, const address_v6&);
+address_v4 make_address_v4(const char*);
+address_v4 make_address_v4(const char*, error_code&) STDNET_NOEXCEPT;
+address_v4 make_address_v4(const std::string&);
+address_v4 make_address_v4(const std::string&, std::error_code&) STDNET_NOEXCEPT;
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+// address_v4 I/O:
+template<class CharT, class Traits>
+  basic_ostream<CharT, Traits>& operator<<(
+    basic_ostream<CharT, Traits>&, const address_v4&);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+// address_v6 comparisons:
+bool operator==(const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator!=(const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator< (const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator> (const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator<=(const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator>=(const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+
+// address_v6 creation:
+//STDNET_CONSTEXPR address_v6 make_address_v6(const address_v6::octets&, unsigned long = 0);
+STDNET_CONSTEXPR address_v6 make_address_v6(v4_mapped_t, const address_v4&) STDNET_NOEXCEPT;
+address_v6 make_address_v6(const char*);
+address_v6 make_address_v6(const char*, error_code&) STDNET_NOEXCEPT;
+address_v6 make_address_v6(const std::string&);
+address_v6 make_address_v6(const std::string&, error_code&) STDNET_NOEXCEPT;
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+// address_v6 I/O:
+template<class CharT, class Traits>
+  basic_ostream<CharT, Traits>& operator<<(
+    basic_ostream<CharT, Traits>&, const address_v6&);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+class bad_address_cast;
+
+// address conversion:
+template <class T> STDNET_CONSTEXPR T address_cast(const address&,
+  typename enable_if<is_same<T, address>::value>::type* = 0) STDNET_NOEXCEPT;
+template <class T> STDNET_CONSTEXPR T address_cast(const address&,
+  typename enable_if<is_same<T, address_v4>::value>::type* = 0);
+template <class T> STDNET_CONSTEXPR T address_cast(const address&,
+  typename enable_if<is_same<T, address_v6>::value>::type* = 0);
+template <class T> STDNET_CONSTEXPR T address_cast(const address_v4&,
+  typename enable_if<is_same<T, address>::value>::type* = 0) STDNET_NOEXCEPT;
+template <class T> STDNET_CONSTEXPR T address_cast(const address_v4&,
+  typename enable_if<is_same<T, address_v4>::value>::type* = 0) STDNET_NOEXCEPT;
+template <class T> T address_cast(const address_v4&,
+  typename enable_if<is_same<T, address_v6>::value>::type* = 0) STDNET_DELETED;
+template <class T> STDNET_CONSTEXPR T address_cast(const address_v6&,
+  typename enable_if<is_same<T, address>::value>::type* = 0) STDNET_NOEXCEPT;
+template <class T> T address_cast(const address_v6&,
+  typename enable_if<is_same<T, address_v4>::value>::type* = 0) STDNET_DELETED;
+template <class T> STDNET_CONSTEXPR T address_cast(const address_v6&,
+  typename enable_if<is_same<T, address_v6>::value>::type* = 0) STDNET_NOEXCEPT;
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_FWD_HPP
diff --git a/ip-address/include/std/net/ip/impl/address.hpp b/ip-address/include/std/net/ip/impl/address.hpp
new file mode 100644
index 0000000..82dc09c
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address.hpp
@@ -0,0 +1,74 @@
+//
+// ip/impl/address.hpp
+// ~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_HPP
+#define STDNET_IP_IMPL_ADDRESS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/ip/address_cast.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+template <typename T, typename>
+inline STDNET_CONSTEXPR address::address(const T& t) STDNET_NOEXCEPT
+  : address(address_cast<address>(t))
+{
+}
+
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+template <typename... T, typename>
+inline STDNET_CONSTEXPR address::address(T&&... t)
+  : address(make_address(static_cast<T&&>(t)...))
+{
+}
+
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address& addr)
+{
+  std::error_code ec;
+  std::string s = addr.to_string(ec);
+  if (ec)
+  {
+    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
+      std::experimental::net::detail::throw_error(ec);
+    else
+      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
+  }
+  else
+    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
+      os << os.widen(*i);
+  return os;
+}
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_IMPL_ADDRESS_HPP
diff --git a/ip-address/include/std/net/ip/impl/address.ipp b/ip-address/include/std/net/ip/impl/address.ipp
new file mode 100644
index 0000000..b74189c
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address.ipp
@@ -0,0 +1,91 @@
+//
+// ip/impl/address.ipp
+// ~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_IPP
+#define STDNET_IP_IMPL_ADDRESS_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <system_error>
+#include <typeinfo>
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/detail/throw_exception.hpp"
+#include "std/net/detail/system_errors.hpp"
+#include "std/net/ip/address.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+std::string address::to_string() const
+{
+  if (type_ == ipv4)
+    return ipv4_address_.to_string();
+  if (type_ == ipv6)
+    return ipv6_address_.to_string();
+  throw bad_address_cast();
+}
+
+std::string address::to_string(std::error_code& ec) const
+{
+  if (type_ == ipv4)
+    return ipv4_address_.to_string(ec);
+  if (type_ == ipv6)
+    return ipv6_address_.to_string(ec);
+  throw bad_address_cast();
+}
+
+address make_address(const char* str)
+{
+  std::error_code ec;
+  address addr = make_address(str, ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+address make_address(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  address_v6 ipv6_address = make_address_v6(str, ec);
+  if (!ec)
+    return ipv6_address;
+
+  address_v4 ipv4_address = make_address_v4(str, ec);
+  if (!ec)
+    return ipv4_address;
+
+  return address();
+}
+
+address make_address(const std::string& str)
+{
+  return make_address(str.c_str());
+}
+
+address make_address(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  return make_address(str.c_str(), ec);
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_IMPL_ADDRESS_IPP
diff --git a/ip-address/include/std/net/ip/impl/address_v4.hpp b/ip-address/include/std/net/ip/impl/address_v4.hpp
new file mode 100644
index 0000000..8544419
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address_v4.hpp
@@ -0,0 +1,57 @@
+//
+// ip/impl/address_v4.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_V4_HPP
+#define STDNET_IP_IMPL_ADDRESS_V4_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/throw_error.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address_v4& addr)
+{
+  std::error_code ec;
+  std::string s = addr.to_string(ec);
+  if (ec)
+  {
+    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
+      std::experimental::net::detail::throw_error(ec);
+    else
+      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
+  }
+  else
+    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
+      os << os.widen(*i);
+  return os;
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#endif // STDNET_IP_IMPL_ADDRESS_V4_HPP
diff --git a/ip-address/include/std/net/ip/impl/address_v4.ipp b/ip-address/include/std/net/ip/impl/address_v4.ipp
new file mode 100644
index 0000000..1ed99f7
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address_v4.ipp
@@ -0,0 +1,90 @@
+//
+// ip/impl/address_v4.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_V4_IPP
+#define STDNET_IP_IMPL_ADDRESS_V4_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <climits>
+#include <stdexcept>
+#include "std/net/detail/socket_ops.hpp"
+#include "std/net/detail/system_errors.hpp"
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/detail/throw_exception.hpp"
+#include "std/net/ip/address_v4.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+std::string address_v4::to_string() const
+{
+  std::error_code ec;
+  std::string addr = to_string(ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+std::string address_v4::to_string(std::error_code& ec) const
+{
+  char addr_str[std::experimental::net::detail::max_addr_v4_str_len];
+  const char* addr =
+    std::experimental::net::detail::socket_ops::inet_ntop(
+        AF_INET, bytes_.data(), addr_str,
+        std::experimental::net::detail::max_addr_v4_str_len, 0, ec);
+  if (addr == 0)
+    return std::string();
+  return addr;
+}
+
+address_v4 make_address_v4(const char* str)
+{
+  std::error_code ec;
+  address_v4 addr = make_address_v4(str, ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+address_v4 make_address_v4(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  address_v4::bytes_type bytes;
+  if (std::experimental::net::detail::socket_ops::inet_pton(
+        AF_INET, str, bytes.data(), 0, ec) <= 0)
+    return address_v4();
+  return address_v4(bytes);
+}
+
+address_v4 make_address_v4(const std::string& str)
+{
+  return make_address_v4(str.c_str());
+}
+
+address_v4 make_address_v4(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  return make_address_v4(str.c_str(), ec);
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_IMPL_ADDRESS_V4_IPP
diff --git a/ip-address/include/std/net/ip/impl/address_v6.hpp b/ip-address/include/std/net/ip/impl/address_v6.hpp
new file mode 100644
index 0000000..1b3fd23
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address_v6.hpp
@@ -0,0 +1,57 @@
+//
+// ip/impl/address_v6.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_V6_HPP
+#define STDNET_IP_IMPL_ADDRESS_V6_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/throw_error.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address_v6& addr)
+{
+  std::error_code ec;
+  std::string s = addr.to_string(ec);
+  if (ec)
+  {
+    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
+      std::experimental::net::detail::throw_error(ec);
+    else
+      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
+  }
+  else
+    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
+      os << os.widen(*i);
+  return os;
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#endif // STDNET_IP_IMPL_ADDRESS_V6_HPP
diff --git a/ip-address/include/std/net/ip/impl/address_v6.ipp b/ip-address/include/std/net/ip/impl/address_v6.ipp
new file mode 100644
index 0000000..682160b
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address_v6.ipp
@@ -0,0 +1,90 @@
+//
+// ip/impl/address_v6.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_V6_IPP
+#define STDNET_IP_IMPL_ADDRESS_V6_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include "std/net/detail/socket_ops.hpp"
+#include "std/net/detail/system_errors.hpp"
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/detail/throw_exception.hpp"
+#include "std/net/ip/address_v6.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+std::string address_v6::to_string() const
+{
+  std::error_code ec;
+  std::string addr = to_string(ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+std::string address_v6::to_string(std::error_code& ec) const
+{
+  char addr_str[std::experimental::net::detail::max_addr_v6_str_len];
+  const char* addr =
+    std::experimental::net::detail::socket_ops::inet_ntop(
+        AF_INET6, bytes_.data(), addr_str,
+        std::experimental::net::detail::max_addr_v6_str_len,
+        scope_id_, ec);
+  if (addr == 0)
+    return std::string();
+  return addr;
+}
+
+address_v6 make_address_v6(const char* str)
+{
+  std::error_code ec;
+  address_v6 addr = make_address_v6(str, ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+address_v6 make_address_v6(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  address_v6::bytes_type bytes;
+  unsigned long scope_id = 0;
+  if (std::experimental::net::detail::socket_ops::inet_pton(
+        AF_INET6, str, bytes.data(), &scope_id, ec) <= 0)
+    return address_v6();
+  return address_v6(bytes, scope_id);
+}
+
+address_v6 make_address_v6(const std::string& str)
+{
+  return make_address_v6(str.c_str());
+}
+
+address_v6 make_address_v6(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  return make_address_v6(str.c_str(), ec);
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_IMPL_ADDRESS_V6_IPP
diff --git a/ip-address/include/std/net/literals.hpp b/ip-address/include/std/net/literals.hpp
new file mode 100644
index 0000000..2f10279
--- /dev/null
+++ b/ip-address/include/std/net/literals.hpp
@@ -0,0 +1,51 @@
+//
+// literals.hpp
+// ~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_LITERALS_HPP
+#define STDNET_LITERALS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/ip/address.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/address_v6.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+inline namespace literals {
+inline namespace net_literals {
+
+inline net::ip::address operator"" _ip(const char* str, std::size_t)
+{
+  return net::ip::make_address(str);
+}
+
+inline net::ip::address_v4 operator"" _ipv4(const char* str, std::size_t)
+{
+  return net::ip::make_address_v4(str);
+}
+
+inline net::ip::address_v6 operator"" _ipv6(const char* str, std::size_t)
+{
+  return net::ip::make_address_v6(str);
+}
+
+} // inline namespace net_literals
+} // inline namespace literals
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_LITERALS_HPP
diff --git a/ip_prefix.cc b/ip_prefix.cc
new file mode 100644
index 0000000..93b59ca
--- /dev/null
+++ b/ip_prefix.cc
@@ -0,0 +1,171 @@
+// ip_prefix.cc: IP_prefix class definition
+//
+// Jiri Matousek, 2014
+// imatousek@fit.vutbr.cz
+
+
+// User includes
+#include "ip_prefix.h"
+
+// Library includes
+#include <network>
+#include <string>
+#include <cstdlib>
+
+
+// Namespace aliases
+namespace ip = std::experimental::net::ip;
+
+// Deafult namespace
+using namespace std;
+
+
+// ****************************************************************************
+//                            Function definitions
+// ****************************************************************************
+
+
+// ***** Private functions ****************************************************
+
+
+string IP_prefix::to_bitstring(unsigned short int byte) {
+   string result = "00000000";
+   for (int i = 7; i >= 0; i--) {
+      if (byte > 0) {
+         if (byte % 2 == 0) {
+            result[i] = '0';
+         } else {
+            result[i] = '1';
+         }
+         byte /= 2;
+      }
+   }
+   return result;
+} // end to_bitstring()
+
+
+// ***** Public functions *****************************************************
+
+
+IP_prefix::IP_prefix(const string& str, bool bitstring) {
+   if (bitstring) { // str represents bits of an IPv4/IPv6 prefix
+      prefix = str;
+   } else { // str represents a valid IPv4/IPv6 prefix in the standard notation
+      // extract prefix
+      string pref = str.substr(0, str.find('/'));
+      // extract prefix length
+      int len = atoi(str.substr(str.find('/')+1).c_str());
+
+      // transform address part of the prefix into generic format
+      ip::address addr(pref);
+
+      // transform generic format into bitstring format
+      string addr_bitstring;
+      if (addr.is_v4()) { // IPv4
+         ip::address_v4 addr_v4(pref);
+         ip::address_v4::bytes_type addr_v4_bytes = addr_v4.to_bytes();
+         for (ip::address_v4::bytes_type::iterator it = addr_v4_bytes.begin(); it != addr_v4_bytes.end(); ++it) {
+            addr_bitstring.append(to_bitstring(*it));
+         }
+      } else if (addr.is_v6()){ // IPv6
+         ip::address_v6 addr_v6(pref);
+         ip::address_v6::bytes_type addr_v6_bytes = addr_v6.to_bytes();
+         for (ip::address_v6::bytes_type::iterator it = addr_v6_bytes.begin(); it != addr_v6_bytes.end(); ++it) {
+            addr_bitstring.append(to_bitstring(*it));
+         }
+      }
+
+      // store only bits actually involved in IP prefix
+      prefix = addr_bitstring.substr(0, len);
+   }
+} // end IP_prefix()
+
+
+IP_prefix::IP_prefix(unsigned addr, int len) {
+   // bitstring representation of addr
+   string addr_bitstring;
+
+   // convert addr into bitstring representation
+   addr_bitstring.append(to_bitstring(addr >> 24));
+   addr_bitstring.append(to_bitstring(addr >> 16));
+   addr_bitstring.append(to_bitstring(addr >>  8));
+   addr_bitstring.append(to_bitstring(addr));
+
+   // store only bits actually involved in IP prefix
+   prefix = addr_bitstring.substr(0, len);
+} // end IP_prefix()
+
+
+IP_prefix::IP_prefix(uint128_t addr, int len) {
+   // bitstring representation of addr
+   string addr_bitstring;
+
+   // convert addr into bitstring representation
+   addr_bitstring.append(to_bitstring(addr >> 120));
+   addr_bitstring.append(to_bitstring(addr >> 112));
+   addr_bitstring.append(to_bitstring(addr >> 104));
+   addr_bitstring.append(to_bitstring(addr >> 96));
+   addr_bitstring.append(to_bitstring(addr >> 88));
+   addr_bitstring.append(to_bitstring(addr >> 80));
+   addr_bitstring.append(to_bitstring(addr >> 72));
+   addr_bitstring.append(to_bitstring(addr >> 64));
+   addr_bitstring.append(to_bitstring(addr >> 56));
+   addr_bitstring.append(to_bitstring(addr >> 48));
+   addr_bitstring.append(to_bitstring(addr >> 40));
+   addr_bitstring.append(to_bitstring(addr >> 32));
+   addr_bitstring.append(to_bitstring(addr >> 24));
+   addr_bitstring.append(to_bitstring(addr >> 16));
+   addr_bitstring.append(to_bitstring(addr >>  8));
+   addr_bitstring.append(to_bitstring(addr));
+
+   // store only bits actually involved in IP prefix
+   prefix = addr_bitstring.substr(0, len);
+} // end IP_prefix()
+
+
+IP_prefix& IP_prefix::operator= (const IP_prefix& orig) {
+   // create a copy of class members
+   prefix = orig.get_prefix();
+   // return the created object
+   return *this;
+} // end operator= ()
+
+
+unsigned IP_prefix::get_prefix_unsigned() const {
+   // initialize auxiliary variables
+   unsigned prefix_uns = 0;
+   unsigned pow = 1;
+
+   // iterate over all bits of an unsigned integer from right to left
+   for (int i = 31; i >= 0; i--) {
+      if (i < (int)prefix.length()) {
+         if (prefix[i] == '1') {
+            prefix_uns += pow;
+         }
+      }
+      pow += pow;
+   }
+
+   // return the prefix value
+   return prefix_uns;
+} // end get_prefix_unsigned();
+
+
+uint128_t IP_prefix::get_prefix_uint128_t() const {
+   // initialize auxiliary variables
+   uint128_t prefix_uns128 = 0;
+   uint128_t pow = 1;
+
+   // iterate over all bits of a 128-bit unsigned integer from right to left
+   for (int i = 127; i >= 0; i--) {
+      if (i < (int)prefix.length()) {
+         if (prefix[i] == '1') {
+            prefix_uns128 += pow;
+         }
+      }
+      pow += pow;
+   }
+
+   // return the prefix value
+   return prefix_uns128;
+} // end get_prefix_uint128_t();
diff --git a/ip_prefix.h b/ip_prefix.h
new file mode 100644
index 0000000..59efa2c
--- /dev/null
+++ b/ip_prefix.h
@@ -0,0 +1,146 @@
+// ip_prefix.h: header file for IP_prefix class
+//
+// Jiri Matousek, 2014
+// imatousek@fit.vutbr.cz
+
+
+#ifndef IP_PREFIX_H
+#define IP_PREFIX_H
+
+
+#include "uint128_t.h"
+#include <string>
+
+// Deafult namespace
+using namespace std;
+
+
+// ****************************************************************************
+//                              Class declaration
+// ****************************************************************************
+
+/*
+ * Class for representation of IPv4/IPv6 prefixes.
+ *
+ * IP prefixes are represented as bitstrings where the first character
+ * represents the MSB of an IP address. Prefix length is determined by the
+ * length of the bitstring.
+ */
+class IP_prefix {
+
+
+   // ***** Private members ***************************************************
+
+
+   private:
+      /*
+       * String of bits representing the prefix.
+       * The first character represents the MSB of the prefix and the prefix
+       * length is given by the length of this string.
+       */
+      string prefix;
+
+      /*
+       * Static function for conversion of a single byte into a bitstring.
+       * @param byte   Byte to be converted.
+       * @return       Byte converted into bitstring.
+       */
+      static string to_bitstring(unsigned short int byte);
+
+
+   // ***** Public members ****************************************************
+
+
+   public:
+      /*
+       * Default constructor.
+       * Constructs an empty object of the IP_prefix class
+       */
+      inline IP_prefix() {};
+
+      /*
+       * Constructor.
+       * Constructs an object of the IP_prefix class from a given string
+       * representing either bits of an IPv4/IPv6 prefix (the length of the
+       * string being the lenght of the prefix) or a valid IPv4/IPv6 prefix in
+       * the standard notation.
+       * @param str         String representing an IPv4/IPv6 prefix in a format
+       *                    determined by the bitsring parameter.
+       * @param bitstring   str represents bits of an IPv4/IPv6 prefix (TRUE)
+       *                    or a valid IPv4/IPv6 prefix in the standard
+       *                    notation (FALSE).
+       */
+      IP_prefix(const string& str, bool bitsring);
+
+      /*
+       * Constructor.
+       * Constructs an object of the IP_prefix class from a given IPv4 prefix
+       * represented by its address part (unsigned integer) and length
+       * (integer).
+       * @param addr   Address part of the IPv4 prefix.
+       * @param len    Prefix length.
+       */
+      IP_prefix(unsigned addr, int len);
+
+      /*
+       * Constructor.
+       * Constructs an object of the IP_prefix class from a given IPv4/IPv6
+       * prefix represented by its address part (128-bit unsigned integer) and
+       * length (integer).
+       * @param addr   Address part of the IPv4/IPv6 prefix.
+       * @param len    Prefix length.
+       */
+      IP_prefix(uint128_t addr, int len);
+
+      /*
+       * Copy assignment.
+       * Constructs a new IP prefix object by asigning a copy of the original
+       * IP prefix object.
+       * @param orig   Reference to the original IP prefix object.
+       * @return       Reference to the new IP prefix object.
+       */
+      IP_prefix& operator= (const IP_prefix& orig);
+
+      /*
+       * Comparison operator.
+       * Compares the current IP prefix object with the given IP prefix object.
+       * @param rhs_prefix   IP prefix object to be compared with the current
+       *                     IP prefix object.
+       * @return             TRUE if IP prefixes are equal,
+       *                     FALSE otherwise.
+       */
+      inline bool operator== (const IP_prefix& rhs_prefix) const {
+         return (prefix == rhs_prefix.get_prefix());
+      }
+
+      /*
+       * Get function for the prefix bitstring.
+       * @return   Bitstring representing IPv4/IPv6 prefix.
+       */
+      inline string get_prefix() const {
+         return prefix;
+      } // end get_prefix()
+
+      /*
+       * Get function for the prefix in the form of an unsigned integer.
+       * @return   Unsigned integer representing IPv4 prefix.
+       */
+      unsigned get_prefix_unsigned() const;
+
+      /*
+       * Get function for the prefix in the form of a 128-bit unsigned
+       * integer.
+       * @return   128-bit unsigned integer representing IPv4/IPv6 prefix.
+       */
+      uint128_t get_prefix_uint128_t() const;
+
+      /*
+       * Get function for the prefix length.
+       * @return   Prefix length.
+       */
+      inline int get_length() const {
+         return prefix.length();
+      } // end get_prefix()
+};
+
+#endif
diff --git a/makefile b/makefile
old mode 100755
new mode 100644
index 773f4c1..3cfcce6
--- a/makefile
+++ b/makefile
@@ -9,15 +9,16 @@
 ## See README file for details
  
 CC = g++
+LIB = -I./ip-address/include
 ##CFLAGS = -g -pg
-CFLAGS = -O2
+CFLAGS = -O2 -std=c++11 $(LIB)
 .cc.o:
 	${CC} ${CFLAGS} -c $*.cc 
 
 sbintree.o : stdinc.h dlist.h sbintree.h
 dbintree.o : stdinc.h dlist.h dbintree.h
 random_db.o : stdinc.h FilterList.h random_db.h
-custom_db.o : stdinc.h FilterList.h ProtList.h FlagList.h ExtraList.h PortList.h PrefixList.h dlist.h sbintree.h dbintree.h redundant_filter_check.h TupleBST.h custom_db.h
+custom_db.o : stdinc.h FilterList.h ProtList.h FlagList.h ExtraList.h PortList.h PrefixList.h dlist.h sbintree.h dbintree.h redundant_filter_check.h TupleBST.h custom_db.h ip_prefix.h trie.h filter_graph.h
 dlist.o : stdinc.h dlist.h
 redundant_filter_check.o : stdinc.h redundant_filter_check.h
 ## nesting_filter_check.o : stdinc.h nesting_filter_check.h
@@ -29,8 +30,16 @@ PrefixList.o : stdinc.h PrefixList.h
 FilterList.o : stdinc.h FilterList.h
 TupleBST.o : stdinc.h dlist.h TupleBST.h
 db_generator.o : stdinc.h random_db.h PortList.h FilterList.h custom_db.h
+uint128_t.o : uint128_t.h
+ip_prefix.o : ip_prefix.h
+trie.o : trie.h
+flow_network.o : flow_network.h
+filter_graph.o : stdinc.h filter_graph.h
 
-db_generator:	db_generator.o random_db.o dlist.o ProtList.o FlagList.o ExtraList.o PortList.o PrefixList.o sbintree.o dbintree.o redundant_filter_check.o FilterList.o TupleBST.o custom_db.o
-	${CC} ${CFLAGS} db_generator.o random_db.o dlist.o sbintree.o dbintree.o ProtList.o FlagList.o ExtraList.o PortList.o PrefixList.o FilterList.o redundant_filter_check.o TupleBST.o custom_db.o -o db_generator
+db_generator:	db_generator.o random_db.o dlist.o ProtList.o FlagList.o ExtraList.o PortList.o PrefixList.o sbintree.o dbintree.o redundant_filter_check.o FilterList.o TupleBST.o custom_db.o uint128_t.o ip_prefix.o trie.o flow_network.o filter_graph.o
+	${CC} ${CFLAGS} db_generator.o random_db.o dlist.o sbintree.o dbintree.o ProtList.o FlagList.o ExtraList.o PortList.o PrefixList.o FilterList.o redundant_filter_check.o TupleBST.o custom_db.o uint128_t.o ip_prefix.o trie.o flow_network.o filter_graph.o -o db_generator
 
 all:	db_generator
+
+clean:
+	rm -rf *.o db_generator
diff --git a/random_db.cc b/random_db.cc
index 8da4c37..b71ff3e 100644
--- a/random_db.cc
+++ b/random_db.cc
@@ -16,28 +16,66 @@ int random_db_gen(int num_filters, FilterList* filters){
   int i;
   unsigned temp1;
   unsigned temp2;
+  uint128_t temp1_128;
+  uint128_t temp2_128;
+  uint128_t temp3_128;
+  uint128_t temp4_128;
   struct filter temp_filter;
 
   for (i = 0; i < num_filters; i++) {
-    // Source Address
-    temp1 = 0;
-    temp1 = mrand48();
-    temp_filter.sa = temp1;
+    if (ADDRLEN == 32) { //IPv4
+       // Source Address
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.sa = temp1;
 
-    // Source Address Length
-    temp1 = 0;
-    temp1 = mrand48();
-    temp_filter.sa_len = (temp1 >> 27);
+       // Source Address Length
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.sa_len = (temp1 >> 27);
 
-    // Destination Address
-    temp1 = 0;
-    temp1 = mrand48();
-    temp_filter.da = temp1;
+       // Destination Address
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.da = temp1;
 
-    // Destination Address Length
-    temp1 = 0;
-    temp1 = mrand48();
-    temp_filter.da_len = (temp1 >> 27);
+       // Destination Address Length
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.da_len = (temp1 >> 27);
+    } else { // IPv6
+       // Source Address
+       temp1_128 = temp2_128 = temp3_128 = temp4_128 = 0;
+       temp1_128 = lrand48();
+       temp2_128 = lrand48();
+       temp3_128 = lrand48();
+       temp4_128 = lrand48();
+       temp2_128 <<= 32;
+       temp3_128 <<= 64;
+       temp4_128 <<= 96;
+       temp_filter.sa = temp4_128 | temp3_128 | temp2_128 | temp1_128;
+
+       // Source Address Length
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.sa_len = (temp1 >> 25);
+
+       // Destination Address
+       temp1_128 = temp2_128 = temp3_128 = temp4_128 = 0;
+       temp1_128 = lrand48();
+       temp2_128 = lrand48();
+       temp3_128 = lrand48();
+       temp4_128 = lrand48();
+       temp2_128 <<= 32;
+       temp3_128 <<= 64;
+       temp4_128 <<= 96;
+       temp_filter.da = temp4_128 | temp3_128 | temp2_128 | temp1_128;
+
+       // Destination Address Length
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.da_len = (temp1 >> 25);
+    }
 
     // Source Port Ranges
     temp1 = 0;
diff --git a/redundant_filter_check.cc b/redundant_filter_check.cc
index 38771e7..fbac9d3 100644
--- a/redundant_filter_check.cc
+++ b/redundant_filter_check.cc
@@ -21,7 +21,7 @@ int redundant_check(struct filter filt1, struct filter filt2){
 
 int sa_prefix_match(struct filter filt1, struct filter filt2){
 
-  unsigned addr1, addr2;
+  uint128_t addr1, addr2;
   int len;
 
   len = filt1.sa_len;
@@ -33,11 +33,11 @@ int sa_prefix_match(struct filter filt1, struct filter filt2){
       // Check source address prefixes
       addr1 = filt1.sa;
       // mask bits
-      addr1 = ((addr1 >> (32-len)) << (32-len));
+      addr1 = ((addr1 >> (128-len)) << (128-len));
       
       addr2 = filt2.sa;
       // mask bits
-      addr2 = ((addr2 >> (32-len)) << (32-len));
+      addr2 = ((addr2 >> (128-len)) << (128-len));
     }
     // Check source address match
     if (addr1 == addr2) return 1;
@@ -47,7 +47,7 @@ int sa_prefix_match(struct filter filt1, struct filter filt2){
 
 int da_prefix_match(struct filter filt1, struct filter filt2){
 
-  unsigned addr1, addr2;
+  uint128_t addr1, addr2;
   int len;
 
   len = filt1.da_len;
@@ -59,11 +59,11 @@ int da_prefix_match(struct filter filt1, struct filter filt2){
       // Check source address prefixes
       addr1 = filt1.da;
       // mask bits
-      addr1 = ((addr1 >> (32-len)) << (32-len));
+      addr1 = ((addr1 >> (128-len)) << (128-len));
       
       addr2 = filt2.da;
       // mask bits
-      addr2 = ((addr2 >> (32-len)) << (32-len));
+      addr2 = ((addr2 >> (128-len)) << (128-len));
     }
     
     // Check source address match
diff --git a/sbintree.cc b/sbintree.cc
index d755099..062fbaf 100644
--- a/sbintree.cc
+++ b/sbintree.cc
@@ -13,12 +13,12 @@
 
 sbintree::sbintree() {
 // Initialize to graph with N vertices and no edges.
-  skew = new float[33];
-  p1child = new float[33];
-  p2child = new float[33];
+  skew = new float[129];
+  p1child = new float[129];
+  p2child = new float[129];
   num_stnodes = 0;
   root = NULL;
-  for (int u = 0; u < 33; u++) {
+  for (int u = 0; u < 129; u++) {
     skew[u] = 0;
     p1child[u] = 0;
     p2child[u] = 0;
@@ -26,9 +26,9 @@ sbintree::sbintree() {
 }
 
 sbintree::~sbintree() {
-  delete(skew);
-  delete(p1child);
-  delete(p2child);
+  delete[] (skew);
+  delete[] (p1child);
+  delete[] (p2child);
   // call recursive node destructor
   if (root != NULL) delete_node(root);
 }
@@ -96,13 +96,13 @@ void sbintree::read_skew(FILE* fp_in){
     // printf("matches = %d\n",matches);
     // printf("level = %d, skew = %.4f\n",level,skew);
     if (matches == 4) {
-      if (level <= 32) {
+      if (level <= 128) {
 	p1child[level] = p1_t;
 	p2child[level] = p2_t;
 	skew[level] = f_skew;
       }
       else {
-	fprintf(stderr,"Level for source address skew is greater than 32.\n");
+	fprintf(stderr,"Level for source address skew is greater than 128.\n");
 	exit(1);
       }
       // printf("Read line: %d\t%.4f\t%.4f\t%.4f\n",level,p1_t,p2_t,f_skew);
@@ -117,7 +117,7 @@ void sbintree::read_skew(FILE* fp_in){
 void sbintree::print_skew(FILE *fp) {
   
   fprintf(fp,"Level\tp1\tp2\tSkew\n");
-  for (int i = 0; i < 33; i++) {
+  for (int i = 0; i < 129; i++) {
     fprintf(fp,"%d\t%.4f\t%.4f\t%.4f\n",
 	    i,p1child[i],p2child[i],skew[i]);
   }
@@ -125,7 +125,7 @@ void sbintree::print_skew(FILE *fp) {
 }
 
 void sbintree::build_tree(dlist* Flist, struct filter filters[]){
-  unsigned int addr = 0;
+  uint128_t addr = 0;
   // Create copy of list
   dlist* temp_list = new dlist;
   (*temp_list)=(Flist);
@@ -138,7 +138,7 @@ void sbintree::build_tree(dlist* Flist, struct filter filters[]){
   return;
 }
 
-void sbintree::add_node(struct stnode *prnt, int lev, int dir, unsigned int addr, dlist* Flist, struct filter filters[], int CurrNest){
+void sbintree::add_node(struct stnode *prnt, int lev, int dir, uint128_t addr, dlist* Flist, struct filter filters[], int CurrNest){
   int Flist_size = 0;
   /*
   printf("add_node:\n");
@@ -215,7 +215,7 @@ void sbintree::add_node(struct stnode *prnt, int lev, int dir, unsigned int addr
 
   double temp;
   int path;
-  unsigned int addr0, addr1;
+  uint128_t addr0, addr1;
   int lev1;
 
   // If list is empty, return
@@ -231,19 +231,19 @@ void sbintree::add_node(struct stnode *prnt, int lev, int dir, unsigned int addr
     if (lev == 0) {
       addr0 = 0;
       addr1 = 1;
-      addr1 = addr1 << 31;
+      addr1 = addr1 << 127;
     } else {
-      addr0 = addr >> (32 - lev);
-      addr0 = addr0 << (32 - lev);
-      addr1 = addr >> (32 - lev);
+      addr0 = addr >> (128 - lev);
+      addr0 = addr0 << (128 - lev);
+      addr1 = addr >> (128 - lev);
       addr1 = addr1 << 1;
       addr1 += 1;
-      addr1 = addr1 << (31 - lev);
+      addr1 = addr1 << (127 - lev);
     }
     // If at the nesting threshold and list has more than one child,
     //   then split list (allocate all nodes with level == lev1 to one path)
     // printf("lev = %d, MyNest = %d, Nest = %d, lev1_flag = %d\n",lev,MyNest,Nest,lev1_flag);
-    if ((Flist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 31)){
+    if ((Flist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 127)){
       // Allocate nest_list
       dlist *nest_list = new dlist();
       dlist *other_list = new dlist();
@@ -291,6 +291,10 @@ void sbintree::add_node(struct stnode *prnt, int lev, int dir, unsigned int addr
 	  add_node(me, lev1, 1, addr1, other_list, filters, MyNest);
 	}
       }	  
+
+      // Deallocate nest_list
+      delete(nest_list);
+      delete(other_list);
     }
     else {
       // Othewise, branch based on branching probability and skew  
diff --git a/sbintree.h b/sbintree.h
index b085696..8130000 100644
--- a/sbintree.h
+++ b/sbintree.h
@@ -31,7 +31,7 @@ class sbintree {
   float *p1child; // probability that a node at a given level has one child
   float *p2child; // probability that a node at a given level has two children
   int num_stnodes; // number of tree nodes 
-  void add_node(struct stnode *prnt, int lev, int dir, unsigned int addr, dlist* Flist, struct filter filters[], int CurrNest);
+  void add_node(struct stnode *prnt, int lev, int dir, uint128_t addr, dlist* Flist, struct filter filters[], int CurrNest);
   int Nest; // Maximum allowed nesting
  public:
   sbintree();
@@ -43,6 +43,17 @@ class sbintree {
   void scale_skew(float scale_factor); // scale branching and skew according to scaling factor
   void print_skew(FILE*); // print average skew per level
   void build_tree(dlist* Flist, struct filter filters[]);
+
+  // get methods for selected private members
+  inline float* get_skew() {
+     return skew;
+  };
+  inline float* get_p1child() {
+     return p1child;
+  };
+  inline float* get_p2child() {
+     return p2child;
+  };
 };
 
 #endif
diff --git a/stdinc.h b/stdinc.h
index f566e0f..3c2f685 100644
--- a/stdinc.h
+++ b/stdinc.h
@@ -10,6 +10,7 @@
 #include <string.h>
 #include <strings.h>
 #include <math.h>
+#include "uint128_t.h"
 
 typedef char bit;
 // const int false = 0;
@@ -24,7 +25,7 @@ inline double max(double x, double y) { return x > y ? x : y; }
 inline int min(int x, int y) { return x < y ? x : y; }
 inline double min(double x, double y) { return x < y ? x : y; }
 inline int abs(int x) { return x < 0 ? -x : x; }
-inline bit isdigit(int c) { return (c >= '0') && (c <= '9'); }
+// inline bit isdigit(int c) { return (c >= '0') && (c <= '9'); }
 
 inline void warning(char* p) { fprintf(stderr,"Warning:%s \n",p); }
 inline void fatal(char* string) {fprintf(stderr,"Fatal:%s\n",string); exit(1); }
@@ -49,15 +50,15 @@ inline int randgeo(double p) { return int(.999999 + log(randfrac())/log(1-p)); }
 
 // Filter database stuff
 
-#define ADDRLEN 32 // IPv4 
+extern int ADDRLEN; // set in db_generator.cc
 #define ADDRBYTES ADDRLEN/8
 #define MAXFILTERS 130000
 #define MAXSTR 100
 // #define NULL 0
 
 struct filter {
-  unsigned sa; // IP source address
-  unsigned da; // IP destination address
+  uint128_t sa; // IP source address
+  uint128_t da; // IP destination address
   int sa_len; // IP source address mask length
   int da_len; // IP destination address mask length
   int sp[2]; // Transport source port range [low,high]
@@ -69,6 +70,30 @@ struct filter {
   int *ext_field; // Pointer to array of extra header fields
 };
 
+// Do a deep copy of orig filter
+inline void copy_filter(struct filter& copy, struct filter orig) {
+  copy.sa            = orig.sa;
+  copy.da            = orig.da;
+  copy.sa_len        = orig.sa_len;
+  copy.da_len        = orig.da_len;
+  copy.sp[0]         = orig.sp[0];
+  copy.sp[1]         = orig.sp[1];
+  copy.dp[0]         = orig.dp[0];
+  copy.dp[1]         = orig.dp[1];
+  copy.prot_num      = orig.prot_num;
+  copy.flags         = orig.flags;
+  copy.flags_mask    = orig.flags_mask;
+  copy.num_ext_field = orig.num_ext_field;
+  if (copy.num_ext_field > 0) {
+    copy.ext_field   = new int[copy.num_ext_field];
+    for (int i = 0; i < copy.num_ext_field; i++) {
+      copy.ext_field[i] = orig.ext_field[i];
+    }
+  } else {
+    copy.ext_field   = NULL;
+  }
+}
+
 struct range {
   int low;
   int high;
diff --git a/trie.cc b/trie.cc
new file mode 100644
index 0000000..12f15de
--- /dev/null
+++ b/trie.cc
@@ -0,0 +1,1190 @@
+// trie.cc: trie class definition
+//
+// Jiri Matousek, 2014
+// imatousek@fit.vutbr.cz
+
+
+// User includes
+#include "trie.h"
+
+// Library includes
+#include <vector>
+#include <queue>
+#include <stack>
+#include <string>
+#include <cmath>
+#include <climits>
+
+
+// Default namespace
+using namespace std;
+
+
+// ****************************************************************************
+//                        Auxiliary class definitions
+// ****************************************************************************
+
+class trie_nodes_greater_than_prefixes {
+public:
+    // implements operation "node1 is GREATER THAN node2"
+    // according to the number of prefixes
+    bool operator()(trie_node* node1, trie_node* node2)
+    {
+       if (node2->prefixes < node1->prefixes) {
+          return true;
+       } else {
+          return false;
+       }
+    }
+};
+
+class trie_nodes_greater_than_weight {
+public:
+    // implements operation "node1 is GREATER THAN node2"
+    // according to the total weight of nodes' subtrees
+    bool operator()(trie_node* node1, trie_node* node2)
+    {
+       if ((node2->zero_weight + node2->one_weight) <
+           (node1->zero_weight + node1->one_weight)) {
+          return true;
+       } else {
+          return false;
+       }
+    }
+};
+
+
+// ****************************************************************************
+//                            Function definitions
+// ****************************************************************************
+
+
+// ***** Private functions ****************************************************
+
+
+trie_node* Trie::copy(const trie_node* node, int level) {
+   // create a pointer to the root of a new trie
+   trie_node* copy_root;
+   // copy the given subtree
+   if (node != NULL) { // non-empty subtree
+      copy_root = new trie_node;
+      copy_root->level = level;
+      copy_root->prefixes = node->prefixes;
+      copy_root->prefix_nesting_branches = node->prefix_nesting_branches;
+      copy_root->zero = copy(node->zero, level+1);
+      copy_root->zero_weight = node->zero_weight;
+      copy_root->one  = copy(node->one, level+1);
+      copy_root->one_weight = node->one_weight;
+   } else { // empty subtree
+      copy_root = NULL;
+   }
+   // return the pointer to the root node of the copy
+   return copy_root;
+} // end copy()
+
+
+void Trie::destruct(trie_node* node) {
+   if (node != NULL) { // non-empty subtree
+      destruct(node->zero);
+      destruct(node->one);
+      delete node;
+   }
+   return;
+} // end destruct()
+
+
+int Trie::compute_weights(trie_node* node) {
+   if (node != NULL) { // non-empty subtree
+      node->zero_weight = compute_weights(node->zero);
+      node->one_weight = compute_weights(node->one);
+      return node->zero_weight + node->one_weight + node->prefixes;
+   } else { // empty subtree
+      return 0;
+   }
+} // end compute_weights()
+
+
+float Trie::compute_skew(trie_node* node) {
+   if (node->zero_weight > node->one_weight) { // lighter 1-subtree
+      return 1 - ((float)node->one_weight / (float)node->zero_weight);
+   } else { // lighter 0-subtree
+      return 1 - ((float)node->zero_weight / (float)node->one_weight);
+   }
+} // end compute_skew()
+
+
+int Trie::get_prefix_nesting(const trie_node* node) {
+   if (node != NULL) { // non-empty subtree
+      // get prefix nesting from successor nodes
+      int zero_nesting = get_prefix_nesting(node->zero);
+      int one_nesting = get_prefix_nesting(node->one);
+      // will this node increase prefix nesting?
+      int is_prefix;
+      if (node->prefixes > 0) { // this is a prefix node
+         is_prefix = 1;
+      } else {
+         is_prefix = 0;
+      }
+      // return maximum of successors' nesting, possibly incremented
+      if (zero_nesting > one_nesting) {
+         return zero_nesting + is_prefix;
+      } else {
+         return one_nesting + is_prefix;
+      }
+   } else { // empty subtree
+      return 0;
+   }
+} // end get_prefix_nesting()
+
+
+void Trie::remove_lightest_subtree(queue<trie_node*> q, bool one_child,
+                                   int prefix_nesting_branches) {
+   trie_node** lightest_subtree_ptr = NULL;
+   int* lightest_weight_ptr = NULL;
+   // find the lightest subtree of nodes stored in the queue
+   while (!q.empty()) {
+      // dequeue front element
+      trie_node* node = q.front();
+      q.pop();
+      // auxiliary variables
+      trie_node** subtree_ptr = NULL;
+      int* weight_ptr = NULL;
+      if (one_child) { // consider only nodes with one child
+         // consider only nodes that can become a valid leaf node
+         if (node->prefixes > 0) {
+            // one-subtree only
+            if ((node->zero == NULL) && (node->one != NULL)) {
+               // the last maximum prefix nesting branch is not going through
+               // the one-subtree
+               if (node->one->prefix_nesting_branches <
+                   prefix_nesting_branches) {
+                  subtree_ptr = &(node->one);
+                  weight_ptr = &(node->one_weight);
+               }
+            // zero-subtree only
+            } else if ((node->zero != NULL) && (node->one == NULL)) {
+               // the last maximum prefix nesting branch is not going through
+               // the zero-subtree
+               if (node->zero->prefix_nesting_branches <
+                   prefix_nesting_branches) {
+                  subtree_ptr = &(node->zero);
+                  weight_ptr = &(node->zero_weight);
+               }
+            }
+         }
+      } else { // consider only nodes with two children
+         if ((node->zero != NULL) && (node->one != NULL)) {
+            // determine lighter subtree
+            if (node->zero_weight <= node->one_weight) {
+               // the last maximum prefix nesting branch is not going through
+               // the zero-subtree
+               if (node->zero->prefix_nesting_branches <
+                   prefix_nesting_branches) {
+                  subtree_ptr = &(node->zero);
+                  weight_ptr = &(node->zero_weight);
+               }
+            } else {
+               // the last maximum prefix nesting branch is not going through
+               // the one-subtree
+               if (node->one->prefix_nesting_branches <
+                   prefix_nesting_branches) {
+                  subtree_ptr = &(node->one);
+                  weight_ptr = &(node->one_weight);
+               }
+            }
+         }
+      }
+      // no lightest subtree has been found so far
+      if (lightest_weight_ptr == NULL) {
+         if (weight_ptr != NULL) { // new candidate for the lightest subtree
+            lightest_subtree_ptr = subtree_ptr;
+            lightest_weight_ptr = weight_ptr;
+         }
+      } else { // a candidate for the lightest subtree has already been found
+         if (weight_ptr != NULL) { // new candidate for the lightest subtree
+            // new lightest subtree
+            if ((*weight_ptr) < (*lightest_weight_ptr)) {
+               lightest_subtree_ptr = subtree_ptr;
+               lightest_weight_ptr = weight_ptr;
+            }
+         }
+      }
+   } // end of while (!q.empty())
+   // if lightest subtree, which can be removed, has been found
+   if (lightest_subtree_ptr != NULL) {
+      destruct(*lightest_subtree_ptr);
+      *lightest_subtree_ptr = NULL;
+      *lightest_weight_ptr = 0;
+   }
+   return;
+} // end remove_lightest_subtree()
+
+
+int Trie::mark_prefix_nesting_branches(trie_node* node, int prefix_nesting,
+                                       int seen_prefixes) {
+   if (node == NULL) { // empty subtree
+      return 0;
+   }
+   if (node->prefixes > 0) { // the current root node is a prefix node
+      seen_prefixes++;
+   }
+   // when a prefix nesting branch has been found
+   if (seen_prefixes == prefix_nesting) {
+      node->prefix_nesting_branches = 1;
+   } else { // look for maximum prefix nesting branches in subtrees
+      int branches_zero = mark_prefix_nesting_branches(node->zero,
+                                                       prefix_nesting,
+                                                       seen_prefixes);
+      int branches_one = mark_prefix_nesting_branches(node->one,
+                                                      prefix_nesting,
+                                                      seen_prefixes);
+      node->prefix_nesting_branches = branches_zero + branches_one;
+   }
+   return node->prefix_nesting_branches;
+} // end mark_refix_nesting_branches()
+
+
+int Trie::get_removable_prefixes(trie_node* node) {
+   if (node == NULL) {
+      return 0;
+   }
+   int removable_prefixes_zero = get_removable_prefixes(node->zero);
+   int removable_prefixes_one  = get_removable_prefixes(node->one);
+   int removable_prefixes_this = node->prefixes;
+   // keep at least one prefix in a leaf node
+   if ((node->zero == NULL) && (node->one == NULL)) {
+      removable_prefixes_this--;
+   }
+   // different handling for 2-children node
+   if ((node->zero != NULL) && (node->one != NULL)) {
+      // allow removing prefixes from subtrees only if both subtrees contain
+      // removable prefixes
+      if ((removable_prefixes_zero > 0) && (removable_prefixes_one > 0)) {
+         // initialize auxiliar variables
+         int zero_weight = node->zero_weight;
+         int one_weight = node->one_weight;
+         int d = 1; // divisor of zero_weight and one_weight
+         int x = 0; // to be removed prefixes from zero subtree
+         int y = 0; // to be removed prefixes from one subtree
+         // find x and y such that
+         //    a) x <= removable_prefixes_zero
+         //    b) y <= removable_prefixes_one
+         // where
+         //    x = zero_weight - (zero_weight / gcd)
+         //    y = one_weight - (one_weight / gcd)
+         // and gcd is the gratest common divisor of zero_weight and one_weight
+         while ((d <= zero_weight) && (d <= one_weight)) {
+            // if d is the gcd
+            if (((zero_weight % d) == 0) && ((one_weight % d) == 0)) {
+               // if to be removed prefixes from both zero and one subtrees is
+               // smaller than removable prefixes from these subtrees
+               if ((zero_weight - zero_weight / d <= removable_prefixes_zero)
+                   &&
+                   (one_weight - one_weight / d <= removable_prefixes_one)) {
+                  x = zero_weight - (zero_weight / d);
+                  y = one_weight - (one_weight / d);
+               } else {
+                  break;
+               }
+            }
+            d++;
+         }
+         // return the total number of prefixes that can be removed without
+         // altering the skew
+         return removable_prefixes_this +
+                x +
+                y;
+      } else {
+         return removable_prefixes_this;
+      }
+   } else {
+      return removable_prefixes_this +
+             removable_prefixes_zero +
+             removable_prefixes_one;
+   }
+} // end get_removable_prefixes
+
+
+void Trie::adjust_node_skew(trie_node* node, float target_skew) {
+   // initialize lighter_* and heavier_* variables
+   int lighter_weight;
+   int heavier_weight;
+   trie_node* lighter_subtree;
+   trie_node* heavier_subtree;
+   // initialize auxiliary variables for skew computation
+   float skew;
+   int zero_weight = node->zero_weight;
+   int one_weight = node->one_weight;
+   // compute skew of the given node and set lighter_* and heavier_* variables
+   if (zero_weight > one_weight) { // zero subtree is heavier
+      skew = 1 - ((float)one_weight / (float)zero_weight);
+      lighter_weight = one_weight;
+      heavier_weight = zero_weight;
+      lighter_subtree = node->one;
+      heavier_subtree = node->zero;
+   } else { // one subtree is heavier
+      skew = 1 - ((float)zero_weight / (float)one_weight);
+      lighter_weight = zero_weight;
+      heavier_weight = one_weight;
+      lighter_subtree = node->zero;
+      heavier_subtree = node->one;
+   }
+   // initialize auxiliary variables
+   double new_weight_real;
+   int weight;
+   trie_node* subtree;
+   // decrease working skew - remove prefixes from heavier subtree
+   if ((skew - target_skew) > 0) {
+      new_weight_real = lighter_weight / (1 - target_skew);
+      weight = heavier_weight;
+      subtree = heavier_subtree;
+   // increase working skew - remove prefixes from lighter subtree
+   } else {
+      new_weight_real = heavier_weight * (1 - target_skew);
+      weight = lighter_weight;
+      subtree = lighter_subtree;
+   }
+   // determine new integer weight of a selected subtree
+   int new_weight = round(new_weight_real);
+   // determine number of prefixes that will be removed
+   int remove_prefixes = weight - new_weight;
+   int removable_prefixes = get_removable_prefixes(subtree);
+   if (remove_prefixes > removable_prefixes) {
+      // decrease the number of removed prefixes to the maximum number of
+      // prefixes that can be removed
+      remove_prefixes = removable_prefixes;
+   }
+   // make the selected subtree lighter by removing the given number of
+   //prefixes
+   make_subtree_lighter(subtree, remove_prefixes);
+   compute_weights(node);
+   return;
+} // end adjust_node_skew()
+
+
+void Trie::make_subtree_lighter(trie_node* root, int remove_prefixes) {
+   // nothing to do when the subtree is empty or 0 prefixes are to be removed
+   if ((root == NULL) || (remove_prefixes == 0)) {
+      return;
+   }
+   // auxiliary variables for counting statistics
+   trie_node* node = root;
+   int removable_prefixes_node = 0;
+   int removable_prefixes_branch = 0;
+   // in priority queue, nodes with less prefixes have higher priority
+   priority_queue<trie_node*,
+                  vector<trie_node*>,
+                  trie_nodes_greater_than_prefixes> pq;
+   // initialize auxiliary variables (keep at least one prefix in a leaf node)
+   removable_prefixes_node = node->prefixes;
+   if ((node->zero == NULL) && (node->one == NULL)) {
+      removable_prefixes_node--;
+   }
+   if (removable_prefixes_node > 0) {
+      removable_prefixes_branch = removable_prefixes_node;
+      pq.push(node);
+   }
+   // traverse a non-branching part of the subtree (i.e. up to the closest
+   // 2-children node or a leaf node) and compute basic statistics about it
+   while (((node->zero == NULL) && (node->one != NULL)) ||
+          ((node->zero != NULL) && (node->one == NULL))) {
+      // determine the next step
+      if (node->zero == NULL) {
+         node = node->one;
+      } else {
+         node = node->zero;
+      }
+      // compute statistics (keep at least one prefix in a leaf node)
+      removable_prefixes_node = node->prefixes;
+      if ((node->zero == NULL) && (node->one == NULL)) {
+         removable_prefixes_node--;
+      }
+      if (removable_prefixes_node > 0) {
+         removable_prefixes_branch += removable_prefixes_node;
+         pq.push(node);
+      }
+   }
+   // get the number of removable prefixes in the remaining subtree
+   int removable_prefixes_subtree = get_removable_prefixes(node);
+   int removable_prefixes_zero = 0;
+   // adjust it to not contain removable prefixes of the subtree's root node
+   if ((node->zero == NULL) && (node->one == NULL)) {
+      removable_prefixes_subtree = 0;
+   } else {
+      removable_prefixes_subtree -= node->prefixes;
+   }
+   // get the number of removable prefixes in branches of the remaining subtree
+   if (removable_prefixes_subtree > 0) {
+      int subtree_weight = node->zero_weight + node->one_weight;
+      removable_prefixes_zero =
+         round(((float)node->zero_weight / (float)subtree_weight) *
+               removable_prefixes_subtree);
+   }
+   // do not continue when no removable prefixes in the branch nor the subtree
+   if ((removable_prefixes_branch + removable_prefixes_subtree) == 0) {
+      return;
+   }
+   // distribute prefixes that are to be removed between the branch and the
+   // subtree
+   int remove_prefixes_branch = round(((float)removable_prefixes_branch /
+                                       (float)(removable_prefixes_subtree +
+                                               removable_prefixes_branch)) *
+                                      remove_prefixes);
+   int remove_prefixes_subtree = remove_prefixes - remove_prefixes_branch;
+   // initialize auxiliary variable for test purposes
+   int removed_prefixes_branch = 0;
+   // while there are some prefix nodes in the branch, remove prefixes
+   // proportionally from all these nodes
+   while (!pq.empty()) {
+      // deque the front element from the priority queue
+      trie_node* working_node = pq.top();
+      pq.pop();
+      // determine the number of prefixes that are to be removed from this node
+      int remove_prefixes_node;
+      if (!pq.empty()) { // not the last node of the branch
+         // keep at least one prefix in a leaf node
+         removable_prefixes_node = working_node->prefixes;
+         if ((node->zero == NULL) && (node->one == NULL)) {
+            removable_prefixes_node--;
+         }
+         // the nuber of prefixes to be removed is computed proportionally
+         remove_prefixes_node = round(((float)removable_prefixes_node /
+                                       (float)removable_prefixes_branch) *
+                                      remove_prefixes_branch);
+      } else { // the last node of the branch
+         // the number of prefixes to be removed ensures removing all the remaining prefixes
+         remove_prefixes_node = remove_prefixes_branch - removed_prefixes_branch;
+      }
+      // remove the given number of prefixes
+      working_node->prefixes -= remove_prefixes_node;
+      // adjust the test variable
+      removed_prefixes_branch += remove_prefixes_node;
+   }
+   // the last node in the non-branching part of the subtree is a 2-children
+   // node
+   if ((node->zero != NULL) && (node->one != NULL)) {
+      // there are some prefixes to be removed from the subtree rooted at node
+      if (remove_prefixes_subtree > 0) {
+         // distribute prefixes that are to be removed from from the subtree
+         // between its zero and one subtrees
+         int remove_prefixes_zero = round(((float)removable_prefixes_zero /
+                                           (float)removable_prefixes_subtree) *
+                                          remove_prefixes_subtree);
+         int remove_prefixes_one  = remove_prefixes_subtree -
+                                    remove_prefixes_zero;
+         // remove prefixes from subtrees of the 2-children node
+         compute_weights(node);
+         make_subtree_lighter(node->zero, remove_prefixes_zero);
+         make_subtree_lighter(node->one, remove_prefixes_one);
+         compute_weights(node);
+      }
+   }
+   return;
+} // end make_subtree_lighter()
+
+
+trie_node* Trie::remove_nonprefix_branches(trie_node* node) {
+   if (node != NULL) { // non-empty subtree
+      node->zero = remove_nonprefix_branches(node->zero);
+      node->one = remove_nonprefix_branches(node->one);
+      if ((node->zero == NULL) && (node->one == NULL) &&
+          (node->prefixes == 0)) {
+         delete node;
+         return NULL;
+      }
+   }
+   return node;
+} //end remove_nonprefix_branches()
+
+
+void Trie::adjust_branching(vector<float> branching_one_child,
+                            vector<float> branching_two_children) {
+   // nothing to do when the trie is empty
+   if (root == NULL) {
+      return;
+   }
+   // recursively compute weight of all subtrees
+   compute_weights(root);
+   // recursively compute maximum prefix nesting
+   int prefix_nesting = get_prefix_nesting(root);
+   // mark branches with maximum prefix nesting
+   mark_prefix_nesting_branches(root, prefix_nesting, 0);
+   // initialize auxiliary variables
+   queue<trie_node*> q;
+   q.push(root);
+   int level = -1;
+   // do a breadth-first search
+   while (!q.empty()) {
+      // get pointer to the front element
+      trie_node* node = q.front();
+      // first node at this level - perform branching adjustment
+      // (all nodes from the current level are enqueued)
+      if (node->level != level) {
+         level = node->level;
+         // compute branching statistics for this level
+         queue<trie_node*> q_copy (q);
+         int one_child = 0;
+         int two_children = 0;
+         int sum = 0;
+         while (!q_copy.empty()) {
+            // dequeue front element from the auxiliary queue
+            trie_node* node_copy = q_copy.front();
+            q_copy.pop();
+            // increment correct counter
+            if ((node_copy->zero != NULL) && (node_copy->one != NULL)) {
+               two_children++;
+            } else if ((node_copy->zero != NULL) || (node_copy->one != NULL)) {
+               one_child++;
+            }
+         }
+         sum = one_child + two_children;
+         // branching probabilities are defined at this level
+         if (sum != 0) { // there is some branching at this level
+            float current_branching_two = (float) two_children / (float) (sum);
+            // adjust branching by reducing the number of two-children nodes
+            if (current_branching_two > branching_two_children[level]) {
+               // determine the ideal number of subtree removing steps
+               float remove_subtrees = two_children -
+                                       (branching_two_children[level] * sum);
+               // diff from ideal branching when remove min./max. subtrees
+               float diff_min = ((two_children - floor(remove_subtrees)) / sum)
+                                - branching_two_children[level];
+               float diff_max = branching_two_children[level] -
+                                ((two_children - ceil(remove_subtrees)) / sum);
+               // determine the number of subtree removing steps
+               int remove_steps = 0;
+               if (diff_min <= diff_max) {
+                  remove_steps = (int) floor(remove_subtrees);
+               } else {
+                  remove_steps = (int) ceil(remove_subtrees);
+               }
+               // remove the given number of "lightest" subtrees +
+               // actualize markers of maximum prefix nesting branches
+               for (int i = 0; i < remove_steps; i++) {
+                  remove_lightest_subtree(q, false,
+                                          root->prefix_nesting_branches);
+                  mark_prefix_nesting_branches(root, prefix_nesting, 0);
+               }
+               // adjust branching nodes count variables
+               one_child += remove_steps;
+               two_children -= remove_steps;
+            }
+            // removing subtree of one-child nodes can change branching
+            // probabilities
+            if (two_children != 0) {
+               float current_branching_one = (float) one_child / (float) (sum);
+               // adjust branching by reducing the number of one-child nodes
+               if (current_branching_one > branching_one_child[level]) {
+                  // determine the ideal number of subtree removing steps
+                  float remove_subtrees =
+                     ((branching_one_child[level] * sum) - one_child) /
+                     (branching_one_child[level] - 1);
+                  // diff from ideal branching when remove min./max. subtrees
+                  float diff_min = ((one_child - floor(remove_subtrees)) /
+                                    (sum - floor(remove_subtrees))) -
+                                   branching_one_child[level];
+                  float diff_max = branching_one_child[level] -
+                                   ((one_child - ceil(remove_subtrees)) /
+                                    (sum - ceil(remove_subtrees)));
+                  // determine the number of subtree removing steps
+                  int remove_steps = 0;
+                  if (diff_min <= diff_max) {
+                     remove_steps = (int) floor(remove_subtrees);
+                  } else {
+                     remove_steps = (int) ceil(remove_subtrees);
+                  }
+                  // remove the given number of "lightest" subtrees +
+                  // actualize markers of maximum prefix nesting branches
+                  for (int i = 0; i < remove_steps; i++) {
+                     remove_lightest_subtree(q, true,
+                                             root->prefix_nesting_branches);
+                     mark_prefix_nesting_branches(root, prefix_nesting, 0);
+                  }
+                  one_child -= remove_steps;
+                  sum -= remove_steps;
+               }
+            }
+         } // end of if (sum != 0)
+      } // end of if (node->level != level)
+      // enqueue possible successors of the current node
+      if (node->zero != NULL) {
+         q.push(node->zero);
+      }
+      if (node->one != NULL) {
+         q.push(node->one);
+      }
+      // remove the front element from the queue
+      q.pop();
+   } // end of while (!q.empty())
+   return;
+} // end adjust_branching()
+
+
+void Trie::adjust_skew(vector<float> skew, float skew_epsilon) {
+   // nothing to do when the trie is empty
+   if (root == NULL) {
+      return;
+   }
+   // initialize auxiliary variables
+   queue<trie_node*> q;
+   stack<trie_node*> s;
+   q.push(root);
+   // do a breadth-first search
+   while (!q.empty()) {
+      // dequeue front element from the queue
+      trie_node* node = q.front();
+      q.pop();
+      // store nodes with 2 children into a stack
+      if ((node->zero != NULL) && (node->one != NULL)) {
+         s.push(node);
+      }
+      // enqueue possible successors of the current node
+      if (node->zero != NULL) {
+         q.push(node->zero);
+      }
+      if (node->one != NULL) {
+         q.push(node->one);
+      }
+   }
+   // initialize auxiliary variables
+   // in priority queue, lighter nodes have higher priority
+   priority_queue<trie_node*,
+                  vector<trie_node*>,
+                  trie_nodes_greater_than_weight> pq;
+   float total_skew = 0.0;
+   int level;
+   if (!s.empty()) {
+      level = s.top()->level;
+   }
+   // do inverse breadth-first search on two-children nodes
+   while (!s.empty()) {
+      // pop top element from the stack
+      trie_node* node = s.top();
+      s.pop();
+      // next level - adjust total skew of the current level
+      if (level != node->level)  {
+         // store the number of 2-children nodes at current level
+         int two_children_nodes = pq.size();
+         // compute target total skew ("sum of all skew values at this level")
+         float target_total_skew = skew[level] * two_children_nodes;
+         // compute skew that is going to be added/removed
+         float skew_change = target_total_skew - total_skew;
+         // compute average skew that is going to be added/removed
+         float average_skew_change;
+         if (two_children_nodes > 0) {
+            average_skew_change = skew_change / (float)two_children_nodes;
+         } else {
+            average_skew_change = skew_change;
+         }
+         // iteratively adjust total skew at this level
+         while (!pq.empty()) {
+            // skip further skew adjustment when average_skew_change is less
+            // than the given skew_epsilon
+            if (abs(average_skew_change) < skew_epsilon) {
+               // remove remaining nodes from the priority queue
+               while (!pq.empty()) {
+                  pq.pop();
+               }
+               // end the outer "while (!pq.empty())" loop
+               break;
+            }
+            // pop the top element from the priority queue
+            trie_node* working_node = pq.top();
+            pq.pop();
+            // compute original skew of the working node
+            float original_skew = compute_skew(working_node);
+            float target_skew = original_skew + skew_change;
+            // adjust skew of the working node
+            if (target_skew < 0.0) {
+               target_skew = 0.0;
+            } else if (target_skew > 1.0) {
+               target_skew = 1.0;
+            }
+            adjust_node_skew(working_node, target_skew);
+            // recursively compute weight of node's subtrees
+            compute_weights(working_node);
+            // compute adjusted skew of the working node
+            float adjusted_skew = compute_skew(working_node);
+            // update total skew, skew that is going to be added/removed, and
+            // its average value
+            total_skew = total_skew - original_skew + adjusted_skew;
+            skew_change = target_total_skew - total_skew;
+            two_children_nodes = pq.size();
+            if (two_children_nodes > 0) {
+               average_skew_change = skew_change / (float)two_children_nodes;
+            } else {
+               average_skew_change = skew_change;
+            }
+         }
+         level = node->level;
+         total_skew = 0.0;
+      }
+      // recursively compute weight of node's subtrees
+      compute_weights(node);
+      // insert the node into the priority queue
+      pq.push(node);
+      // actualize total skew value
+      total_skew += compute_skew(node);
+   }
+   return;
+} // end adjust_skew()
+
+
+void Trie::adjust_prefixes(vector<float> prefixes_proportion,
+                           const int target_size) {
+   // nothing to do when the trie is empty
+   if (root == NULL) {
+      return;
+   }
+   // compute the total number of prefixes at each level
+   vector<int> all_prefixes(129,0);
+   queue<trie_node*> q;
+   q.push(root);
+   while (!q.empty()) {
+      // dequeue front element
+      trie_node* node = q.front();
+      q.pop();
+      // enqueue its possible successors
+      if (node->zero != NULL) {
+         q.push(node->zero);
+      }
+      if (node->one != NULL) {
+         q.push(node->one);
+      }
+      // update the total number of prefixes at current level
+      all_prefixes[node->level] += node->prefixes;
+   }
+   // compute the number of target and to be removed prefixes at each level
+   vector<int> target_prefixes(129,0);
+   vector<int> remove_prefixes(129,0);
+   int target_prefixes_total = 0;
+   int leaf_level = 0;
+   for (int i = 0; i < (int) prefixes_proportion.size(); i++) {
+      target_prefixes[i] = round(prefixes_proportion[i]*target_size);
+      target_prefixes_total += target_prefixes[i];
+      remove_prefixes[i] = all_prefixes[i] - target_prefixes[i];
+      if (target_prefixes[i] != 0) {
+         leaf_level = i;
+      }
+   }
+   // final correction to given target_size
+   if (target_prefixes_total != target_size) {
+      int diff = target_size - target_prefixes_total;
+      target_prefixes[leaf_level] += diff;
+      target_prefixes_total += diff;
+      remove_prefixes[leaf_level] -= diff;
+   }
+   // compute the number of prefixes to be removed at remaining levels
+   vector<int> remove_prefixes_remaining(129,0);
+   for (int i = 127; i >= 0; i--) {
+      remove_prefixes_remaining[i] = remove_prefixes_remaining[i+1] +
+                                     remove_prefixes[i+1];
+   }
+   // starting from the root, adjust prefixes distribution
+   queue<trie_node*> nodes;
+   nodes.push(root);
+   queue<int> remove_prefixes_subtrees;
+   remove_prefixes_subtrees.push(remove_prefixes[0] + remove_prefixes_remaining[0]);
+   int level = -1;
+   while (!nodes.empty()) {
+      // get the front element
+      // (from both nodes and remove_prefixes_subtrees queues)
+      trie_node* node = nodes.front();
+      // next level - adjust prefixes at this level
+      // (all nodes of this level are stored in nodes queue)
+      if (node->level != level) {
+         level = node->level;
+         // actualize subtrees' weight information in nodes
+         compute_weights(root);
+         // initialize vectors to contain all current elements of queues
+         queue<trie_node*> nodes_copy (nodes);
+         vector<trie_node*> nodes_vect;
+         queue<int> remove_prefixes_subtrees_copy (remove_prefixes_subtrees);
+         vector<int> remove_prefixes_subtrees_vect;
+         while (!nodes_copy.empty()) {
+            nodes_vect.push_back(nodes_copy.front());
+            nodes_copy.pop();
+            remove_prefixes_subtrees_vect.push_back(remove_prefixes_subtrees_copy.front());
+            remove_prefixes_subtrees_copy.pop();
+         }
+         // from all leaf nodes at this level
+         // remove prefixes that have to be removed
+         int i = 0;
+         while (i < (int) nodes_vect.size()) {
+            if ((nodes_vect[i]->zero == NULL) &&
+                (nodes_vect[i]->one == NULL)) {
+               // determine the real number of prefixes to be removed
+               // (do not remove the last prefix from a leaf node)
+               int remove_prefixes_node;
+               if (nodes_vect[i]->prefixes > remove_prefixes_subtrees_vect[i]) {
+                  remove_prefixes_node = remove_prefixes_subtrees_vect[i];
+               } else {
+                  remove_prefixes_node = nodes_vect[i]->prefixes - 1;
+               }
+               // consider all prefixes of this node and this subtree to be
+               // removed, regardless they are really removed or not
+               // (in any case, there are no other prefixes that could be
+               //  removed)
+               all_prefixes[level] -= nodes_vect[i]->prefixes;
+               remove_prefixes_subtrees_vect[i] = 0;
+               // remove the prefixes
+               nodes_vect[i]->prefixes -= remove_prefixes_node;
+               remove_prefixes[level] -= remove_prefixes_node;
+               // remove this node from both vectors
+               nodes_vect.erase(nodes_vect.begin()+i);
+               remove_prefixes_subtrees_vect.erase(remove_prefixes_subtrees_vect.begin()+i);
+            } else {
+               // the node has not been removed, thus increase the index
+               i++;
+            }
+         }
+         // if there are some nodes with prefixes that could be removed AND
+         // the number of prefixes to be removed is not negative
+         if ((all_prefixes[level] > 0) && (remove_prefixes[level] >= 0)) {
+            // initialize auxiliary constant (for this level)
+            float remove_all_ratio = (float)(remove_prefixes[level]) /
+                                     (float)(all_prefixes[level]);
+            // from all non-leaf nodes at this level
+            // remove prefixes that are to be removed at this level
+            for (int i = 0; i < (int) nodes_vect.size(); i++) {
+               int remove_prefixes_node = round((float)(nodes_vect[i]->prefixes) *
+                                                remove_all_ratio);
+               // do not remove more than all prefixes to be removed from this subtree
+               if (remove_prefixes_node > remove_prefixes_subtrees_vect[i]) {
+                  remove_prefixes_node = remove_prefixes_subtrees_vect[i];
+               }
+               // do not remove more than all prefixes of this node
+               if (remove_prefixes_node > nodes_vect[i]->prefixes) {
+                  remove_prefixes_node = nodes_vect[i]->prefixes;
+               }
+               // remove the prefixes and adjust other variables
+               nodes_vect[i]->prefixes -= remove_prefixes_node;
+               all_prefixes[level] -= remove_prefixes_node;
+               remove_prefixes[level] -= remove_prefixes_node;
+               remove_prefixes_subtrees_vect[i] -= remove_prefixes_node;
+            }
+         }
+         // for all nodes at this level
+         // distribute prefixes to be removed in a subtree rooted at this node
+         // into node's subtrees
+         for (int i = 0; i < (int) nodes_vect.size(); i++) {
+            // distribution for 2-children nodes
+            if ((nodes_vect[i]->zero != NULL) && (nodes_vect[i]->one != NULL)) {
+               // determine the distribution
+               int total_weight = nodes_vect[i]->zero_weight +
+                                  nodes_vect[i]->one_weight;
+               int remove_prefixes_zero = round(((float)(nodes_vect[i]->zero_weight) /
+                                                 (float)total_weight) *
+                                                (float)(remove_prefixes_subtrees_vect[i]));
+               int remove_prefixes_one = remove_prefixes_subtrees_vect[i] -
+                                         remove_prefixes_zero;
+               // do not remove more than all prefixes from zero subtree
+               if (remove_prefixes_zero > nodes_vect[i]->zero_weight) {
+                  remove_prefixes_zero = nodes_vect[i]->zero_weight;
+               }
+               // do not remove more than all prefixes from one subtree
+               if (remove_prefixes_one > nodes_vect[i]->one_weight) {
+                  remove_prefixes_one = nodes_vect[i]->one_weight;
+               }
+               // store the distribution into main queues
+               nodes.push(nodes_vect[i]->zero);
+               remove_prefixes_subtrees.push(remove_prefixes_zero);
+               nodes.push(nodes_vect[i]->one);
+               remove_prefixes_subtrees.push(remove_prefixes_one);
+            } else {
+               // distribution for 1-child nodes
+               if (nodes_vect[i]->zero != NULL) {
+                  nodes.push(nodes_vect[i]->zero);
+               } else if (nodes_vect[i]->one != NULL) {
+                  nodes.push(nodes_vect[i]->one);
+               }
+               remove_prefixes_subtrees.push(remove_prefixes_subtrees_vect[i]);
+            }
+         }
+      }
+      // remove the front elements from the main queues
+      nodes.pop();
+      remove_prefixes_subtrees.pop();
+   }
+   return;
+} // end adjust_prefixes()
+
+
+// ***** Public functions *****************************************************
+
+
+// Default constructor
+Trie::Trie() {
+   root = NULL;
+} // end Trie()
+
+
+// Copy constructor
+Trie::Trie(const Trie& orig) {
+   root = copy(orig.get_root(), 0);
+} // end Trie()
+
+
+// Destructor
+Trie::~Trie() {
+   destruct(root);
+} // end ~Trie()
+
+
+// Copy assignment
+Trie& Trie::operator= (const Trie& orig) {
+   // replace the original trie by a copy of the assigned trie
+   destruct(root);
+   root = copy(orig.get_root(), 0);
+   // return created object
+   return *this;
+} // end operator= ()
+
+
+void Trie::insert(const IP_prefix& pref) {
+   // insert at least a root node when the trie is empty
+   if (root == NULL) {
+      root = new trie_node;
+      root->level = 0;
+      root->prefixes = 0;
+      root->prefix_nesting_branches = 0;
+      root->zero = NULL;
+      root->zero_weight = 0;
+      root->one  = NULL;
+      root->one_weight = 0;
+   }
+   // insert the given prefix into the trie
+   if (pref.get_length() == 0) { // prefix of length 0
+      (root->prefixes)++;
+   } else { // prefix of length > 0
+      // auxiliary variables
+      trie_node* node = root;
+      trie_node** next_node_ptr;
+      string prefix = pref.get_prefix();
+      // trie traversal
+      for (int i = 0; i < pref.get_length(); i++) {
+         // determine the next node and store the pointer to it
+         if (prefix[i] == '0') {
+            next_node_ptr = &(node->zero);
+         } else { // (prefix[i] == '1')
+            next_node_ptr = &(node->one);
+         }
+         // insert the next node if it does not exist
+         if ((*next_node_ptr) == NULL) {
+            (*next_node_ptr) = new trie_node;
+            (*next_node_ptr)->level = i+1;
+            (*next_node_ptr)->prefixes = 0;
+            (*next_node_ptr)->prefix_nesting_branches = 0;
+            (*next_node_ptr)->zero = NULL;
+            (*next_node_ptr)->zero_weight = 0;
+            (*next_node_ptr)->one  = NULL;
+            (*next_node_ptr)->one_weight  = 0;
+         }
+         // move to the next node;
+         node = (*next_node_ptr);
+      }
+      // prefix insertion
+      (node->prefixes)++;
+   }
+   return;
+} // end insert()
+
+
+bool Trie::erase(const IP_prefix& pref) {
+   // nothing to do when the trie is empty
+   if (root == NULL) {
+      return root;
+   }
+   // search for the given prefix
+   if (pref.get_length() == 0) { // prefix of length 0
+      if (root->prefixes > 0) { // we have found the prefix node
+         (root->prefixes)--;
+         if ((root->prefixes == 0) &&
+             (root->zero == NULL) &&
+             (root->one  == NULL)) {
+            // all the conditions for removing the node were met
+            destruct(root);
+            root = NULL;
+         }
+         return true;
+      } else { // the corresponding node is a non-prefix node
+         return false;
+      }
+   } else { // prefix of length > 0
+      // auxiliary variables
+      trie_node* node = root;
+      trie_node** destruct_root = &(root);
+      string prefix = pref.get_prefix();
+      for (int i = 0; i < pref.get_length(); i++) {
+         // determine the next node
+         if (prefix[i] == '0') {
+            // adjust desctruct_root
+            if ((node->prefixes != 0) ||
+                (node->one != NULL)) { // this node cannot be removed
+               destruct_root = &(node->zero);
+            }
+            // move to the next node
+            node = node->zero;
+         } else { // (prefix[i] == '1')
+            // adjust desctruct_root
+            if ((node->prefixes != 0) ||
+                (node->zero != NULL)) { // this node cannot be removed
+               destruct_root = &(node->one);
+            }
+            // move to the next node
+            node = node->one;
+         }
+         // chceck whether the next node exists (terminate search if not)
+         if (node == NULL) {
+            return false;
+         }
+      }
+      if (node->prefixes > 0) { // we have found the prefix node
+         (node->prefixes)--;
+         if ((node->prefixes == 0) &&
+             (node->zero == NULL) &&
+             (node->one  == NULL)) {
+            // all the conditions for removing the node were met
+            destruct(*destruct_root);
+            *destruct_root = NULL;
+         }
+         return true;
+      } else { // the corresponding node is a non-prefix node
+         return false;
+      }
+   }
+} // end erase()
+
+
+void Trie::prune(const int target_size,
+                 const vector<float>& prefixes,
+                 const vector<float>& one_child,
+                 const vector<float>& two_children,
+                 const vector<float>& skew,
+                 const int iterations) {
+   // get original prefix set size
+   trie_stats s;
+   this->get_stats(s);
+   int orig_size = s.classbench.prefixes;
+
+   // adjust branching (1st step of trie pruning)
+   this->adjust_branching(one_child, two_children);
+
+   // iteratively adjust skew and prefixes proportion
+   // (multiple iterations help to reduce the negative effect of
+   //  adjust_prefixes function on skew)
+   for (int i = 1; i <= iterations; i++) {
+      // adjust skew (2nd step of trie pruning)
+      this->adjust_skew(skew);
+      // adjust prefixes proportion (3rd step of trie pruning)
+      if (i == iterations) {
+         this->adjust_prefixes(prefixes, target_size);
+      } else {
+         this->adjust_prefixes(prefixes, round((1-(float)i/4)*orig_size));
+      }
+   }
+} // end prune()
+
+
+void Trie::get_stats(trie_stats& stats) {
+   // initialize classbench statistics
+   stats.classbench.prefixes = 0;
+   stats.classbench.prefix_lengths = vector<int>(129,0);
+   stats.classbench.branching_one_child = vector<float>(129,0.0);
+   stats.classbench.branching_two_children = vector<float>(129,0.0);
+   stats.classbench.skew = vector<float>(129,0.0);
+   stats.classbench.prefix_nesting = 0;
+   // initialize nodes statistics
+   stats.nodes.leaf = vector<int>(129,0);
+   stats.nodes.one_child = vector<int>(129,0);
+   stats.nodes.two_children = vector<int>(129,0);
+   stats.nodes.prefix = vector<int>(129,0);
+   stats.nodes.non_prefix = vector<int>(129,0);
+   // nothing to do when the trie is empty
+   if (root == NULL) {
+      return;
+   }
+   // compute zero_weight and one_weight in each node of the trie
+   compute_weights(root);
+   // initialize auxiliary variables
+   queue<trie_node*> q;
+   q.push(root);
+   int level = root->level;
+   // do a breadth-first search
+   while (!q.empty()) {
+      // dequeue front element
+      trie_node* node = q.front();
+      q.pop();
+      // enqueue its possible successors
+      if (node->zero != NULL) {
+         q.push(node->zero);
+      }
+      if (node->one != NULL) {
+         q.push(node->one);
+      }
+      // level change - finish statistics computation for the previous level
+      if (node->level != level) {
+         // auxiliary variables
+         int one_child = stats.nodes.one_child[level];
+         int two_children = stats.nodes.two_children[level];
+         int sum = one_child + two_children;
+         // branching_one_child and branching_two_children
+         if (sum != 0) {
+            stats.classbench.branching_one_child[level] =
+               (float)one_child / (float)sum;
+            stats.classbench.branching_two_children[level] =
+               (float)two_children / (float)sum;
+         }
+         // skew
+         if (two_children != 0) {
+            stats.classbench.skew[level] /= (float)two_children;
+         }
+         // increment the level counter
+         level++;
+      }
+      // trie node visit - classbench statistics
+      stats.classbench.prefixes += node->prefixes;
+      stats.classbench.prefix_lengths[level] += node->prefixes;
+      if ((node->zero != NULL) && (node->one != NULL)) { // skew is defined
+         stats.classbench.skew[level] += compute_skew(node);
+      }
+      // trie node visit - nodes statistics
+      if (node->zero == NULL) {
+         if (node->one == NULL) { // leaf node
+            (stats.nodes.leaf[level])++;
+         } else { // one child node
+            (stats.nodes.one_child[level])++;
+         }
+      } else { // node->zero != NULL
+         if (node->one != NULL) { // two child node
+            (stats.nodes.two_children[level])++;
+         } else { // one child node
+            (stats.nodes.one_child[level])++;
+         }
+      }
+      if (node->prefixes > 0) { // prefix node
+         (stats.nodes.prefix[level])++;
+      } else { // non-prefix node
+         (stats.nodes.non_prefix[level])++;
+      }
+   } // end of while (!q.empty())
+   // finish statistics computation for the last level
+   // auxiliary variables
+   int one_child = stats.nodes.one_child[level];
+   int two_children = stats.nodes.two_children[level];
+   int sum = one_child + two_children;
+   // branching_one_child and branching_two_children
+   if (sum != 0) {
+      stats.classbench.branching_one_child[level] =
+         (float)one_child / (float)sum;
+      stats.classbench.branching_two_children[level] =
+         (float)two_children / (float)sum;
+   }
+   // skew
+   if (two_children != 0) {
+      stats.classbench.skew[level] /= (float)two_children;
+   }
+   // compute prefix nesting
+   stats.classbench.prefix_nesting = get_prefix_nesting(root);
+   return;
+} // end get_stats()
diff --git a/trie.h b/trie.h
new file mode 100644
index 0000000..4cbe414
--- /dev/null
+++ b/trie.h
@@ -0,0 +1,477 @@
+// trie.h: header file for trie class
+//
+// Jiri Matousek, 2014
+// imatousek@fit.vutbr.cz
+
+
+#ifndef TRIE_H
+#define TRIE_H
+
+
+// User includes
+#include "ip_prefix.h"
+
+// Library includes
+#include <vector>
+#include <queue>
+
+// Default namespace
+using namespace std;
+
+
+// ****************************************************************************
+//                            Structures declaration
+// ****************************************************************************
+
+/*
+ * Structure representing a node of a trie.
+ *
+ * Each node can be a prefix node (prefixes > 0) or a non-prefix node
+ * (prefixes = 0) and it can have at most two successors accessible using
+ * pointers zero (when the next bit of the prefix is 0) or one (when the next
+ * bit of the prefix is 1).
+ * Except these basic members, each trie node stores some other values that
+ * make the computation of trie characteristics easier. These values are
+ * further described directly in the trie node structure declaration.
+ */
+
+struct trie_node {
+   // trie level (i.e. distance from the root) at which the node resides
+   int level;
+
+   // number of occurences of the prefix
+   int prefixes;
+
+   // counter of branches with maximum prefix nesting that this node is part of
+   int prefix_nesting_branches;
+
+   // 0-subtree-related members
+   trie_node* zero; // pointer to the subtree root
+   int zero_weight; // number of prefixes in the subtree
+
+   // 1-subtree-related members
+   trie_node* one; // pointer to the subtree root
+   int one_weight; // number of prefixes in the subtree
+};
+
+/*
+ * Structure representing trie statistics proposed in the ClassBench tool.
+ *
+ * Vector members store statistics defined separately for each level of the
+ * trie. Prefix nesting is defined for the whole trie.
+ */
+struct classbench_stats {
+   // total number of prefixes
+   int prefixes;
+
+   // number of prefixes (not prefix nodes) with given length
+   vector<int> prefix_lengths;
+
+   // probability of node with only one child (from all non-leaf nodes)
+   vector<float> branching_one_child;
+   // probability of node with two children (from all non-leaf nodes)
+   vector<float> branching_two_children;
+
+   // average relative weight ratio of lighter vs heavier subtree
+   // (nodes with two children only)
+   vector<float> skew;
+
+   // maximum number of prefix nodes on an arbitrary path in the trie
+   int prefix_nesting;
+};
+
+/*
+ * Structure representing statistics related to trie nodes.
+ *
+ * All the statistics are stored separately for each level of the trie.
+ */
+struct node_stats {
+   vector<int> leaf;         // number of leaf nodes
+   vector<int> one_child;    // number of nodes with one child only
+   vector<int> two_children; // number of nodes with both children
+   vector<int> prefix;       // number of prefix nodes (not prefixes)
+   vector<int> non_prefix;   // number of non-prefix nodes
+};
+
+/*
+ * Structure representing statistics related to the trie.
+ *
+ * Statistics are divided into two groups:
+ *    1) statistics proposed in ClassBench tool and
+ *    2) statistics related to trie nodes.
+ */
+struct trie_stats {
+   classbench_stats classbench; // ClassBench statistics
+   node_stats nodes;            // nodes statistics
+};
+
+// ****************************************************************************
+//                              Class declaration
+// ****************************************************************************
+
+/*
+ * Class for representation of a binary prefix tree - trie.
+ *
+ * Class functions do not adjust zero_weight and one_weight counters in a trie
+ * node by default. These feilds are viewed as place holders and they can be
+ * set to the correct value by calling the compute_weights().
+ */
+class Trie {
+   private:
+      /*
+       * Pointer to the root node of the trie.
+       */
+      trie_node* root;
+
+// PROBABLY IT IS NOT NECESSARY TO HAVE THIS FUNCTION PRIVATE
+// (MAYBE JUST ONE REASON -- BY COPYING ONLY A SUBTREE YOU LOOSE THE
+// INFORMATION ABOUT THE COMMON PREFIX, I.E. PATH IN TRIE PRECEDING THIS
+// SUBTREE)
+      /*
+       * Private static function for copying a subtree of the trie, where the
+       * subtree is specified by a pointer to its root node.
+       * Trie node members prefixes, zero_weight, and one_weight are copied
+       * without any change, while the level member is set to the given value.
+       * This approach allows e.g. to create a new valid trie by copying the
+       * given subtree. (In such a case the level parameter have to be set to
+       * 0 during the initial function call.)
+       * Trie node members zero and one are set to the values returned by the
+       * recursive call of the copy() onto the 0-subtree and 1-subtree,
+       * respectively.
+       * CAUTION:
+       *    * This function uses recursive calls!
+       * @param node    Pointer to the root node of a subtree that is to be
+       *                copied.
+       * @param level   Value for the level member of the copied trie node.
+       * @return        Pointer to the root node of the copy.
+       */
+      static trie_node* copy(const trie_node* node, int level);
+
+      /*
+       * Private static function for destruction of a trie's subtree. The
+       * subtree is given by a pointer to its root node.
+       * CAUTION:
+       *    * This function uses recursive calls!
+       * @param node   Pointer to the root node of a subtree that is to be
+       *               destructed.
+       */
+      static void destruct(trie_node* node);
+
+      /*
+       * Private static function for computation of zero_weight and one_weight
+       * values of all the trie nodes in a given subtree. The subtree is given
+       * by a pointer to its root node.
+       * CAUTION:
+       *    * This function uses recursive calls!
+       * @param node   Pointer to the root node of the subtree in which the
+       *               weights are to be computed.
+       * @return       Weights of the given subtree.
+       */
+      static int compute_weights(trie_node* node);
+
+// PROBABLY IT IS NOT NECESSARY TO HAVE THIS FUNCTION PRIVATE
+      /*
+       * Private static function for computation of node's skew as defined in
+       * the ClassBench paper. This function expects that the pointed node is
+       * a 2-children node and that its fields zero_weight and one_weight
+       * contain valid values.
+       * @param node   Pointer to the node of which the skew is going to be
+       *               computed.
+       * @return       Skew of the given node.
+       */
+      static float compute_skew(trie_node* node);
+
+// PROBABLY IT IS NOT NECESSARY TO HAVE THIS FUNCTION PRIVATE
+      /*
+       * Private static function that determines the maximum prefix nesting in
+       * a given subtree, i.e. the maximum number of prefixes on any path from
+       * the root to the leaves in the subtree. The subtree is given by a
+       * pointer to its root node.
+       * CAUTION:
+       *    * This function uses recursive calls!
+       * @param node    Pointer to the root node of the subtree in which the
+       *                prefix nesting is to be computed.
+       * @return        Maximum prefix nesting in the given subtree.
+       */
+      static int get_prefix_nesting(const trie_node* node);
+
+      /*
+       * Private static function that removes the lightest subtree among trie
+       * nodes passed in a queue. The lightest subtree can be selected
+       * either among one-child nodes or two-children nodes. The selection is
+       * done in such a way that when the lightest subtree is removed, there
+       * is still at least one branch with maximum prefix nesting in the trie.
+       * After removing the lightest subtree, corresponding subtree weight is
+       * set to 0.
+       * @param q                         Queue with trie nodes that are to be
+       *                                  inspected.
+       * @param one_child                 Select lightest subtree either among
+       *                                  one-child nodes (TRUE) or
+       *                                  two-children nodes (FALSE).
+       * @param prefix_nesting_branches   The number of branches in the trie
+       *                                  with maximum prefix nesting.
+       */
+      static void remove_lightest_subtree(queue<trie_node*> q, bool one_child,
+                                          int prefix_nesting_branches);
+
+      /*
+       * Private static function for marking branches with maximum prefix
+       * nesting in a given subtree. The subtree is given by a pointer to its
+       * root node. Maximum prefix nesting is specified as a parameter of the
+       * function (therefore, it has to be computed outside the function).
+       * CAUTION:
+       *    * This function uses recursive calls!
+       * @param node             Pointer to the root node of the subtree in
+       *                         which prefix nesting branches are to be
+                                 marked.
+       * @param prefix_nesting   Maximum prefix nesting in the given subtree.
+       * @param seen_prefixes    Number of prefixes that has been seen so far.
+       * @return                 Weights of the given subtree.
+       */
+      static int mark_prefix_nesting_branches(trie_node* node,
+                                              int prefix_nesting,
+                                              int seen_prefixes);
+
+// PROBABLY IT IS NOT NECESSARY TO HAVE THIS FUNCTION PRIVATE
+      /*
+       * Private static function for computation of the maximum number of
+       * prefixes that can be removed from a given subtree. When computing the
+       * result of this function, the following contraints are taken into
+       * account:
+       *    * no prefix node within the subtree must not become a non-prefix
+       *      node after removing the prefixes;
+       *    * removing the prefixes from subtrees of 2-children node should not
+       *      alter the skew of this node.
+       * The subtree is given by a pointer to its root node.
+       * CAUTION:
+       *    * This function uses recursive calls!
+       * @param node   A Pointer to the root node of the subtree in which the
+                       number of removable prefixes is going to be computed.
+       * @return       The number of removable prefixes in the given subtree.
+       */
+      static int get_removable_prefixes(trie_node* node);
+
+      /*
+       * Private static function for adjusting skew of a specified node to the
+       * given value. The node is specified by it's pointer and the target
+       * skew is given as a float number.
+       * @param node          Pointer to the node whose skew is going to be
+       *                      adjusted.
+       * @param target_skew   The value to which the node's skew should be
+       *                      adjusted.
+       */
+      static void adjust_node_skew(trie_node* node, float target_skew);
+
+      /*
+       * Private static function that removes the given number of prefixes from
+       * a subtree specified by the pointer to its root node. Prefixes are
+       * removed as equally as possible while following a rule that no prefix
+       * node can be turned to a non-prefix node. Removing of prefixes is
+       * performed over all prefix nodes from the root node up to the closest
+       * 2-children node or a leaf node...
+       * @param root        Pointer to the root node of the subtree in which
+       *                    prefixes are going to be removed.
+       * @remove_prefixes   The number of prefixes that should be removed from
+       *                    the specified subtree.
+       */
+      static void make_subtree_lighter(trie_node* root, int remove_prefixes);
+
+      /*
+       * Private static function for removing branches without a prefix node
+       * from a given subtree. The subtree is given by a pointer to its root
+       * node.
+       * CAUTION:
+       *    * This function uses recursive calls!
+       * @param node   Pointer to the root node of the subtree in which
+       *               nonprefix are to be removed.
+       * @return       actualized pointer to the subtree's root node
+       *               (NULL when the whole subtree was removed)
+       */
+      static trie_node* remove_nonprefix_branches(trie_node* node);
+
+      /*
+       * Private function that removes some subtrees in order to achieve
+       * branching probabilities that are as close as possible to the given
+       * values.
+       * Modifications are done on a per level basis, starting from the root
+       * node. Changes at each level are done in two steps:
+       *    1) lightest subtrees of two-children nodes are removed to achieve
+       *       given branching_two_children probability
+       *    2) lightest subtrees of one-child nodes are removed to achieve
+       *       given branching_one_child probability
+       * @param branching_one_child      Vector specifying probability of
+       *                                 occurence of a trie node with one
+       *                                 child at the given level of the trie.
+       * @param branching_two_children   Vector specifying probability of
+       *                                 occurence of a trie node with two
+       *                                 children at the given level of the
+       *                                 trie.
+       */
+      void adjust_branching(vector<float> branching_one_child,
+                            vector<float> branching_two_children);
+
+      /*
+       * Private function that removes some prefixes in order to achieve an
+       * average skew that is as close as possible to the given values for
+       * particular levels.
+       * Prefixes are removed on a per level basis, starting from the lowest
+       * level. At each level, an average skew is increased/decreased by
+       * removing prefixes from lighter/heavier subtree of the level's nodes.
+       * This adjustment starts from nodes with the lightest subtrees
+       * (adjusting their skew requires removing of the lowest number of
+       * prefixes) and it is implemented such that it (almost) does not change
+       * a skew of nodes at lower levels.
+       * @param skew      Vector specifying an average skew at all levels of
+       *                  the trie.
+       * @ skew_epsilon   Threshold value for average skew change at not yet
+       *                  adjusted nodes (skew adjustment stops when average
+       *                  skew change is less than the given skew_epsilon).
+       */
+      void adjust_skew(vector<float> skew, float skew_epsilon = 0.01);
+
+      /*
+       * Private function that removes some prefixes in order to achieve
+       * prefixes distribution that is as close as possible to the given values
+       * for particular levels.
+       * Prefixes are removed on a per level basis, starting from the root
+       * node. Removing the prefixes consists of three steps:
+       *    1) removing the prefixes from leaf nodes (the last prefix
+       *       represented by a leaf node is never removed)
+       *    2) removing the prefixes from non-leaf nodes, proportionally to
+       *       their weight
+       *    3) distributing prefixes that are to be removed at lower levels to
+       *       subtrees of non-leaf nodes (this distribution is driven by skew)
+       * @param prefixes_proportion   Vector that for all trie levels specifies
+       *                              proportion of prefixes at the given level
+       *                              to all prefixes in the trie.
+       * @param target_size           Target total number of prefixes in the
+       *                              trie.
+       */
+      void adjust_prefixes(vector<float> prefixes_proportion,
+                           const int target_size);
+
+   public:
+      /*
+       * Default constructor.
+       * Pointer to the root node is initialized to NULL.
+       */
+      Trie();
+
+      /*
+       * Copy constructor.
+       * Pointer to the root node is initialized by the result of the private
+       * copy().
+       * @param orig   Reference to the original trie object.
+       */
+      Trie(const Trie& orig);
+
+      /*
+       * Destructor.
+       * Trie specified by the root pointer is destructed by the private
+       * destruct().
+       */
+      ~Trie();
+
+      /*
+       * Copy assignment.
+       * Original trie is destructed by the private destruct() and the new trie
+       * is created by the private copy().
+       * @param orig   Reference to the original trie object.
+       * @return       Reference to the new trie object.
+       */
+      Trie& operator= (const Trie& orig);
+
+      /*
+       * Get function for the root pointer.
+       * @return   Pointer to the root node of the trie.
+       */
+      inline const trie_node* get_root() const {
+         return root;
+      } // end get_root()
+
+      /*
+       * Inserts the specified prefix into the trie.
+       * The trie is non-recursively traversed to the corresponding trie node,
+       * where the prefix is newly inserted or at least the counter of its
+       * occurences is incremented.
+       * All the missing nodes on a way to the prefix node are newly created
+       * and inserted into the trie as non-prefix nodes.
+       * @param pref   Reference to the IP_prefix object representing the
+       *               prefix that is to be inserted.
+       */
+      void insert(const IP_prefix& pref);
+
+      /*
+       * Erases the specified prefix from the trie.
+       * The prefix is searched by non-recursively traversing the trie. If the
+       * erase() finds the prefix, the counter of its occurences is decremented
+       * and return value is set to TRUE.
+       * If the erased prefix was the last one (i.e. prefix node has changed to
+       * non-prefix node) and there is not more specific prefix (i.e. prefix
+       * node is a leaf node of the trie), its corresponding node and all its
+       * non-prefix predecessors (up to the closest node with two children) are
+       * removed from the trie using private destruct().
+       * If the erase() does not find the prefix, it silently ends without any
+       * further action and with return value set to FALSE.
+       * @param pref   Reference to the IP_prefix object representing the
+       *               prefix that is to be removed.
+       * @return       TRUE if the prefix was removed,
+       *               FALSE otherwise.
+       */
+      bool erase(const IP_prefix& pref);
+
+      /*
+       * Prunes the trie in order to achieve the given characteristics.
+       * The function first adjusts branching probability distributions at all
+       * trie levels. Next, average skew and prefix length distributions are
+       * adjusted while the number of prefixes in the trie is iteratively
+       * decreased towards the given target size.
+       * @param target_size    Target number of prefixes in the trie. The
+       *                       final number of prefixes in the pruned trie can
+       *                       be slightly different.
+       * @param prefixes       The vector of target prefix length distribution
+       *                       over the trie levels.
+       * @param one_child      The vector of target one-child branching
+       *                       probability distribution over the trie levels.
+       * @param two_children   The vector of target two-children branching
+       *                       probability distribution over the trie levels.
+       * @param skew           The vector of target average skew distribution
+       *                       over the trie levels.
+       * @param iterations     The number of iterations of average skew and
+       *                       prefix length distribution adjustment.
+       */
+      void prune(const int target_size,
+                 const vector<float>& prefixes,
+                 const vector<float>& one_child,
+                 const vector<float>& two_children,
+                 const vector<float>& skew,
+                 const int iterations = 4);
+
+      /*
+       * Computes all defined trie statistics and stores them into a given
+       * structure.
+       * Except prefix nesting, which is computed during separate recursive
+       * traversal, all the other statistics are computed during single
+       * breadth-first search. Following statistics are actualized when
+       * visiting the nodes:
+       *    * classbench.prefix_lengths
+       *    * classbench.skew
+       *    * nodes.leaf
+       *    * nodes.one_child
+       *    * nodes.two_children
+       *    * nodes.prefix
+       *    * nodes.non_prefix
+       * The value classbech.skew is also adjusted (divided by
+       * nodes.two_children) after visiting all the nodes at the current trie
+       * level.
+       * There are also two statistics (classbench.branching_one_child and
+       * classbench.branching_two_children) that are fully computed after
+       * visiting all the nodes at the current trie level. Their computation is
+       * based on values nodes.one_child and nodes.two_children.
+       * @param stats   Reference to a data structure for computed trie
+       *                statistics.
+       */
+      void get_stats(trie_stats& stats);
+};
+
+#endif
diff --git a/uint128_t.cc b/uint128_t.cc
new file mode 100644
index 0000000..1e16bbd
--- /dev/null
+++ b/uint128_t.cc
@@ -0,0 +1,372 @@
+#include "uint128_t.h"
+
+const uint128_t uint128_0(0);
+const uint128_t uint128_1(1);
+const uint128_t uint128_64(64);
+const uint128_t uint128_128(128);
+
+uint128_t::uint128_t(){
+    UPPER = 0;
+    LOWER = 0;
+}
+
+uint128_t::uint128_t(const uint128_t & rhs){
+    UPPER = rhs.UPPER;
+    LOWER = rhs.LOWER;
+}
+
+uint128_t uint128_t::operator=(const uint128_t & rhs){
+    UPPER = rhs.UPPER;
+    LOWER = rhs.LOWER;
+    return *this;
+}
+
+uint128_t::operator bool() const{
+    return (bool) (UPPER | LOWER);
+}
+
+uint128_t::operator char() const{
+    return (char) LOWER;
+}
+uint128_t::operator int() const{
+    return (int) LOWER;
+}
+
+uint128_t::operator uint8_t() const{
+    return (uint8_t) LOWER;
+}
+
+uint128_t::operator uint16_t() const{
+    return (uint16_t) LOWER;
+}
+
+uint128_t::operator uint32_t() const{
+    return (uint32_t) LOWER;
+}
+
+uint128_t::operator uint64_t() const{
+    return (uint64_t) LOWER;
+}
+
+uint128_t uint128_t::operator&(const uint128_t & rhs) const{
+return uint128_t(UPPER & rhs.UPPER, LOWER & rhs.LOWER);
+}
+
+uint128_t uint128_t::operator|(const uint128_t & rhs) const{
+    return uint128_t(UPPER | rhs.UPPER, LOWER | rhs.LOWER);
+}
+
+uint128_t uint128_t::operator^(const uint128_t & rhs) const{
+    return uint128_t(UPPER ^ rhs.UPPER, LOWER ^ rhs.LOWER);
+}
+
+uint128_t uint128_t::operator&=(const uint128_t & rhs){
+    UPPER &= rhs.UPPER;
+    LOWER &= rhs.LOWER;
+    return *this;
+}
+
+uint128_t uint128_t::operator|=(const uint128_t & rhs){
+    UPPER |= rhs.UPPER;
+    LOWER |= rhs.LOWER;
+    return *this;
+}
+
+uint128_t uint128_t::operator^=(const uint128_t & rhs){
+    UPPER ^= rhs.UPPER;
+    LOWER ^= rhs.LOWER;
+    return *this;
+}
+
+uint128_t uint128_t::operator~() const{
+    return uint128_t(~UPPER, ~LOWER);
+}
+
+uint128_t uint128_t::operator<<(const uint128_t & rhs) const{
+    uint64_t shift = rhs.LOWER;
+    if (((bool) rhs.UPPER) || (shift >= 128)){
+        return uint128_0;
+    }
+    else if (shift == 64){
+        return uint128_t(LOWER, 0);
+    }
+    else if (shift == 0){
+        return *this;
+    }
+    else if (shift < 64){
+        return uint128_t((UPPER << shift) + (LOWER >> (64 - shift)), LOWER << shift);
+    }
+    else if ((128 > shift) && (shift > 64)){
+        return uint128_t(LOWER << (shift - 64), 0);
+    }
+    else{
+        return uint128_0;
+    }
+}
+
+uint128_t uint128_t::operator>>(const uint128_t & rhs) const{
+    uint64_t shift = rhs.LOWER;
+    if (((bool) rhs.UPPER) || (shift >= 128)){
+        return uint128_0;
+    }
+    else if (shift == 64){
+        return uint128_t(0, UPPER);
+    }
+    else if (shift == 0){
+        return *this;
+    }
+    else if (shift < 64){
+        return uint128_t(UPPER >> shift, (UPPER << (64 - shift)) + (LOWER >> shift));
+    }
+    else if ((128 > shift) && (shift > 64)){
+        return uint128_t(0, (UPPER >> (shift - 64)));
+    }
+    else{
+        return uint128_0;
+    }
+}
+
+uint128_t uint128_t::operator<<=(const uint128_t & rhs){
+    *this = *this << rhs;
+    return *this;
+}
+
+uint128_t uint128_t::operator>>=(const uint128_t & rhs){
+    *this = *this >> rhs;
+    return *this;
+}
+
+bool uint128_t::operator!() const{
+    return !(bool) (UPPER | LOWER);
+}
+
+bool uint128_t::operator&&(const uint128_t & rhs) const{
+    return ((bool) *this && rhs);
+}
+
+bool uint128_t::operator||(const uint128_t & rhs) const{
+     return ((bool) *this || rhs);
+}
+
+bool uint128_t::operator==(const uint128_t & rhs) const{
+    return ((UPPER == rhs.UPPER) && (LOWER == rhs.LOWER));
+}
+
+bool uint128_t::operator!=(const uint128_t & rhs) const{
+    return ((UPPER != rhs.UPPER) | (LOWER != rhs.LOWER));
+}
+
+bool uint128_t::operator>(const uint128_t & rhs) const{
+    if (UPPER == rhs.UPPER){
+        return (LOWER > rhs.LOWER);
+    }
+    return (UPPER > rhs.UPPER);
+}
+
+bool uint128_t::operator<(const uint128_t & rhs) const{
+    if (UPPER == rhs.UPPER){
+        return (LOWER < rhs.LOWER);
+    }
+    return (UPPER < rhs.UPPER);
+}
+
+bool uint128_t::operator>=(const uint128_t & rhs) const{
+    return ((*this > rhs) | (*this == rhs));
+}
+
+bool uint128_t::operator<=(const uint128_t & rhs) const{
+    return ((*this < rhs) | (*this == rhs));
+}
+
+uint128_t uint128_t::operator+(const uint128_t & rhs) const{
+    return uint128_t(UPPER + rhs.UPPER + ((LOWER + rhs.LOWER) < LOWER), LOWER + rhs.LOWER);
+}
+
+uint128_t uint128_t::operator+=(const uint128_t & rhs){
+    UPPER = rhs.UPPER + UPPER + ((LOWER + rhs.LOWER) < LOWER);
+    LOWER += rhs.LOWER;
+    return *this;
+}
+
+uint128_t uint128_t::operator-(const uint128_t & rhs) const{
+    return uint128_t(UPPER - rhs.UPPER - ((LOWER - rhs.LOWER) > LOWER), LOWER - rhs.LOWER);
+}
+
+uint128_t uint128_t::operator-=(const uint128_t & rhs){
+    *this = *this - rhs;
+    return *this;
+}
+
+uint128_t uint128_t::operator*(const uint128_t & rhs) const{
+    // split values into 4 32-bit parts
+    uint64_t top[4] ={UPPER >> 32, UPPER & 0xffffffff, LOWER >> 32, LOWER & 0xffffffff};
+    uint64_t bottom[4] ={rhs.UPPER >> 32, rhs.UPPER & 0xffffffff, rhs.LOWER >> 32, rhs.LOWER & 0xffffffff};
+    uint64_t products[4][4];
+
+    for(int y = 3; y > -1; y--){
+        for(int x = 3; x > -1; x--){
+            products[3 - x][y] = top[x] * bottom[y];
+        }
+    }
+
+    // initial row
+    uint64_t fourth32 = products[0][3] & 0xffffffff;
+    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
+    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
+    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);
+
+    // second row
+    third32 += products[1][3] & 0xffffffff;
+    second32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
+    first32 += (products[1][1] & 0xffffffff) + (products[1][2] >> 32);
+
+    // third row
+    second32 += products[2][3] & 0xffffffff;
+    first32 += (products[2][2] & 0xffffffff) + (products[2][3] >> 32);
+
+    // fourth row
+    first32 += products[3][3] & 0xffffffff;
+
+    // combines the values, taking care of carry over
+    return uint128_t(first32 << 32, 0) + uint128_t(third32 >> 32, third32 << 32) + uint128_t(second32, 0) + uint128_t(fourth32);
+}
+
+uint128_t uint128_t::operator*=(const uint128_t & rhs){
+    *this = *this * rhs;
+    return *this;
+}
+
+std::pair <uint128_t, uint128_t> uint128_t::divmod(const uint128_t & lhs, const uint128_t & rhs) const{
+    // Save some calculations /////////////////////
+    if (rhs == uint128_0){
+        throw std::runtime_error("Error: division or modulus by 0");
+    }
+    else if (rhs == uint128_1){
+        return std::pair <uint128_t, uint128_t> (lhs, uint128_0);
+    }
+    else if (lhs == rhs){
+        return std::pair <uint128_t, uint128_t> (uint128_1, uint128_0);
+    }
+    else if ((lhs == uint128_0) || (lhs < rhs)){
+        return std::pair <uint128_t, uint128_t> (uint128_0, lhs);
+    }
+
+    std::pair <uint128_t, uint128_t> qr(uint128_0, lhs);
+    uint128_t copyd = rhs << (lhs.bits() - rhs.bits());
+    uint128_t adder = uint128_1 << (lhs.bits() - rhs.bits());
+    if (copyd > qr.second){
+        copyd >>= uint128_1;
+        adder >>= uint128_1;
+    }
+    while (qr.second >= rhs){
+        if (qr.second >= copyd){
+            qr.second -= copyd;
+            qr.first |= adder;
+        }
+        copyd >>= uint128_1;
+        adder >>= uint128_1;
+    }
+    return qr;
+}
+
+uint128_t uint128_t::operator/(const uint128_t & rhs) const{
+    return divmod(*this, rhs).first;
+}
+
+uint128_t uint128_t::operator/=(const uint128_t & rhs){
+    *this = *this / rhs;
+    return *this;
+}
+
+uint128_t uint128_t::operator%(const uint128_t & rhs) const{
+    return *this - (rhs * (*this / rhs));
+}
+
+uint128_t uint128_t::operator%=(const uint128_t & rhs){
+    *this = *this % rhs;
+    return *this;
+}
+
+uint128_t uint128_t::operator++(){
+    *this += uint128_1;
+    return *this;
+}
+
+uint128_t uint128_t::operator++(int){
+    uint128_t temp(*this);
+    ++*this;
+    return temp;
+}
+
+uint128_t uint128_t::operator--(){
+    *this -= uint128_1;
+    return *this;
+}
+
+uint128_t uint128_t::operator--(int){
+    uint128_t temp(*this);
+    --*this;
+    return temp;
+}
+
+uint64_t uint128_t::upper() const{
+    return UPPER;
+}
+
+uint64_t uint128_t::lower() const{
+    return LOWER;
+}
+
+uint8_t uint128_t::bits() const{
+    uint8_t out = 0;
+    if (UPPER){
+        out = 64;
+        uint64_t up = UPPER;
+        while (up){
+            up >>= 1;
+            out++;
+        }
+    }
+    else{
+        uint64_t low = LOWER;
+        while (low){
+            low >>= 1;
+            out++;
+        }
+    }
+    return out;
+}
+
+std::string uint128_t::str(uint8_t base, const unsigned int & len) const{
+    if ((base < 2) || (base > 16)){
+        throw std::invalid_argument("Base must be in th range 2-16");
+    }
+    std::string out = "";
+    if (!(*this)){
+        out = "0";
+    }
+    else{
+        std::pair <uint128_t, uint128_t> qr(*this, uint128_0);
+        do{
+            qr = divmod(qr.first, base);
+            out = "0123456789abcdef"[(uint8_t) qr.second] + out;
+        } while (qr.first);
+    }
+    if (out.size() < len){
+        out = std::string(len - out.size(), '0') + out;
+    }
+    return out;
+}
+
+std::ostream & operator<<(std::ostream & stream, const uint128_t & rhs){
+    if (stream.flags() & stream.oct){
+        stream << rhs.str(8);
+    }
+    else if (stream.flags() & stream.dec){
+        stream << rhs.str(10);
+    }
+    else if (stream.flags() & stream.hex){
+        stream << rhs.str(16);
+    }
+    return stream;
+}
diff --git a/uint128_t.h b/uint128_t.h
new file mode 100644
index 0000000..7da340a
--- /dev/null
+++ b/uint128_t.h
@@ -0,0 +1,384 @@
+/*
+uint128_t.h
+An unsigned 128 bit integer type for C++
+Copyright (c) 2014 Jason Lee @ calccrypto at gmail.com
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+With much help from Auston Sterling
+
+Thanks to Stefan Deigmller for finding
+a bug in operator*.
+
+Thanks to Franois Dessenne for convincing me
+to do a general rewrite of this class.
+*/
+
+#ifndef __UINT128_T__
+#define __UINT128_T__
+
+#include <iostream>
+#include <stdexcept>
+#include <stdint.h>
+#include <utility>
+
+class uint128_t{
+    private:
+        uint64_t UPPER, LOWER;
+
+    public:
+        // Constructors
+        uint128_t();
+        uint128_t(const uint128_t & rhs);
+
+        template <typename T> uint128_t(const T & rhs){
+            UPPER = 0;
+            LOWER = rhs;
+        }
+
+        template <typename S, typename T> uint128_t(const S & upper_rhs, const T & lower_rhs){
+            UPPER = upper_rhs;
+            LOWER = lower_rhs;
+        }
+
+        //  RHS input args only
+
+        // Assignment Operator
+        uint128_t operator=(const uint128_t & rhs);
+
+        template <typename T> uint128_t operator=(const T & rhs){
+            UPPER = 0;
+            LOWER = rhs;
+            return *this;
+        }
+
+        // Typecast Operators
+        operator bool() const;
+        operator char() const;
+        operator int() const;
+        operator uint8_t() const;
+        operator uint16_t() const;
+        operator uint32_t() const;
+        operator uint64_t() const;
+
+        // Bitwise Operators
+        uint128_t operator&(const uint128_t & rhs) const;
+        uint128_t operator|(const uint128_t & rhs) const;
+        uint128_t operator^(const uint128_t & rhs) const;
+        uint128_t operator&=(const uint128_t & rhs);
+        uint128_t operator|=(const uint128_t & rhs);
+        uint128_t operator^=(const uint128_t & rhs);
+        uint128_t operator~() const;
+
+        template <typename T> uint128_t operator&(const T & rhs) const{
+            return uint128_t(0, LOWER & (uint64_t) rhs);
+        }
+
+        template <typename T> uint128_t operator|(const T & rhs) const{
+            return uint128_t(UPPER, LOWER | (uint64_t) rhs);
+        }
+
+        template <typename T> uint128_t operator^(const T & rhs) const{
+            return uint128_t(UPPER, LOWER ^ (uint64_t) rhs);
+        }
+
+        template <typename T> uint128_t operator&=(const T & rhs){
+            UPPER = 0;
+            LOWER &= rhs;
+            return *this;
+        }
+
+        template <typename T> uint128_t operator|=(const T & rhs){
+            LOWER |= (uint64_t) rhs;
+            return *this;
+        }
+
+        template <typename T> uint128_t operator^=(const T & rhs){
+            LOWER ^= (uint64_t) rhs;
+            return *this;
+        }
+
+        // Bit Shift Operators
+        uint128_t operator<<(const uint128_t & rhs) const;
+        uint128_t operator>>(const uint128_t & rhs) const;
+        uint128_t operator<<=(const uint128_t & rhs);
+        uint128_t operator>>=(const uint128_t & rhs);
+
+        template <typename T>uint128_t operator<<(const T & rhs) const{
+            return *this << uint128_t(rhs);
+        }
+
+        template <typename T>uint128_t operator>>(const T & rhs) const{
+            return *this >> uint128_t(rhs);
+        }
+
+        template <typename T>uint128_t operator<<=(const T & rhs){
+            *this = *this << uint128_t(rhs);
+            return *this;
+        }
+
+        template <typename T>uint128_t operator>>=(const T & rhs){
+            *this = *this >> uint128_t(rhs);
+            return *this;
+        }
+
+        // Logical Operators
+        bool operator!() const;
+        bool operator&&(const uint128_t & rhs) const;
+        bool operator||(const uint128_t & rhs) const;
+
+        template <typename T> bool operator&&(const T & rhs){
+            return ((bool) *this && rhs);
+        }
+
+        template <typename T> bool operator||(const T & rhs){
+            return ((bool) *this || rhs);
+        }
+
+        // Comparison Operators
+        bool operator==(const uint128_t & rhs) const;
+        bool operator!=(const uint128_t & rhs) const;
+        bool operator>(const uint128_t & rhs) const;
+        bool operator<(const uint128_t & rhs) const;
+        bool operator>=(const uint128_t & rhs) const;
+        bool operator<=(const uint128_t & rhs) const;
+
+        template <typename T> bool operator==(const T & rhs) const{
+            return (!UPPER && (LOWER == (uint64_t) rhs));
+        }
+
+        template <typename T> bool operator!=(const T & rhs) const{
+            return (UPPER | (LOWER != (uint64_t) rhs));
+        }
+
+        template <typename T> bool operator>(const T & rhs) const{
+            return (UPPER || (LOWER > (uint64_t) rhs));
+        }
+
+        template <typename T> bool operator<(const T & rhs) const{
+            return (!UPPER)?(LOWER < (uint64_t) rhs):false;
+        }
+
+        template <typename T> bool operator>=(const T & rhs) const{
+            return ((*this > rhs) | (*this == rhs));
+        }
+
+        template <typename T> bool operator<=(const T & rhs) const{
+            return ((*this < rhs) | (*this == rhs));
+        }
+
+        // Arithmetic Operators
+        uint128_t operator+(const uint128_t & rhs) const;
+        uint128_t operator+=(const uint128_t & rhs);
+        uint128_t operator-(const uint128_t & rhs) const;
+        uint128_t operator-=(const uint128_t & rhs);
+        uint128_t operator*(const uint128_t & rhs) const;
+        uint128_t operator*=(const uint128_t & rhs);
+
+    private:
+        std::pair <uint128_t, uint128_t> divmod(const uint128_t & lhs, const uint128_t & rhs) const;
+
+    public:
+		uint128_t operator/(const uint128_t & rhs) const;
+        uint128_t operator/=(const uint128_t & rhs);
+        uint128_t operator%(const uint128_t & rhs) const;
+        uint128_t operator%=(const uint128_t & rhs);
+
+        template <typename T> uint128_t operator+(const T & rhs) const{
+            return uint128_t(UPPER + ((LOWER + (uint64_t) rhs) < LOWER), LOWER + (uint64_t) rhs);
+        }
+
+        template <typename T> uint128_t operator+=(const T & rhs){
+            UPPER = UPPER + ((LOWER + rhs) < LOWER);
+            LOWER = LOWER + rhs;
+            return *this;
+        }
+
+        template <typename T> uint128_t operator-(const T & rhs) const{
+            return uint128_t((uint64_t) (UPPER - ((LOWER - rhs) > LOWER)), (uint64_t) (LOWER - rhs));
+        }
+
+        template <typename T> uint128_t operator-=(const T & rhs){
+            *this = *this - rhs;
+            return *this;
+        }
+
+        template <typename T> uint128_t operator*(const T & rhs) const{
+            return (*this) * (uint128_t(rhs));
+        }
+
+        template <typename T> uint128_t operator*=(const T & rhs){
+            *this = *this * uint128_t(rhs);
+            return *this;
+        }
+
+        template <typename T> uint128_t operator/(const T & rhs) const{
+            return *this / uint128_t(rhs);
+        }
+
+        template <typename T> uint128_t operator/=(const T & rhs){
+            *this = *this / uint128_t(rhs);
+            return *this;
+        }
+
+        template <typename T> uint128_t operator%(const T & rhs) const{
+            return *this - (rhs * (*this / rhs));
+        }
+
+        template <typename T> uint128_t operator%=(const T & rhs){
+            *this = *this % uint128_t(rhs);
+            return *this;
+        }
+
+        // Increment Operator
+        uint128_t operator++();
+        uint128_t operator++(int);
+
+        // Decrement Operator
+        uint128_t operator--();
+        uint128_t operator--(int);
+
+        // Get private values
+        uint64_t upper() const;
+        uint64_t lower() const;
+
+        // Get bitsize of value
+        uint8_t bits() const;
+
+        // Get string representation of value
+        std::string str(uint8_t base = 10, const unsigned int & len = 0) const;
+};
+
+// Useful values
+extern const uint128_t uint128_0;
+extern const uint128_t uint128_1;
+extern const uint128_t uint128_64;
+extern const uint128_t uint128_128;
+
+// lhs type T as first arguemnt
+// If the output is not a bool, casts to type T
+
+// Bitwise Operators
+template <typename T> T operator&(const T & lhs, const uint128_t & rhs){
+    return (T) (lhs & (T) rhs.lower());
+}
+
+template <typename T> T operator|(const T & lhs, const uint128_t & rhs){
+    return (T) (lhs | (T) rhs.lower());
+}
+
+template <typename T> T operator^(const T & lhs, const uint128_t & rhs){
+    return (T) (lhs ^ (T) rhs.lower());
+}
+
+template <typename T> T operator&=(T & lhs, const uint128_t & rhs){
+    lhs &= (T) rhs.lower(); return lhs;
+}
+
+template <typename T> T operator|=(T & lhs, const uint128_t & rhs){
+    lhs |= (T) rhs.lower(); return lhs;
+}
+
+template <typename T> T operator^=(T & lhs, const uint128_t & rhs){
+    lhs ^= (T) rhs.lower(); return lhs;
+}
+
+// Comparison Operators
+template <typename T> bool operator==(const T & lhs, const uint128_t & rhs){
+    return (!rhs.upper() && ((uint64_t) lhs == rhs.lower()));
+}
+
+template <typename T> bool operator!=(const T & lhs, const uint128_t & rhs){
+    return (rhs.upper() | ((uint64_t) lhs != rhs.lower()));
+}
+
+template <typename T> bool operator>(const T & lhs, const uint128_t & rhs){
+    return (!rhs.upper()) && ((uint64_t) lhs > rhs.lower());
+}
+
+template <typename T> bool operator<(const T & lhs, const uint128_t & rhs){
+    if (rhs.upper()){
+        return true;
+    }
+    return ((uint64_t) lhs < rhs.lower());
+}
+
+template <typename T> bool operator>=(const T & lhs, const uint128_t & rhs){
+    if (rhs.upper()){
+            return false;
+    }
+    return ((uint64_t) lhs >= rhs.lower());
+}
+
+template <typename T> bool operator<=(const T & lhs, const uint128_t & rhs){
+    if (rhs.upper()){
+            return true;
+    }
+    return ((uint64_t) lhs <= rhs.lower());
+}
+
+// Arithmetic Operators
+template <typename T> T operator+(const T & lhs, const uint128_t & rhs){
+    return (T) (rhs + lhs);
+}
+
+template <typename T> T & operator+=(T & lhs, const uint128_t & rhs){
+    lhs = (T) (rhs + lhs);
+    return lhs;
+}
+
+template <typename T> T operator-(const T & lhs, const uint128_t & rhs){
+    return (T) (uint128_t(lhs) - rhs);
+}
+
+template <typename T> T & operator-=(T & lhs, const uint128_t & rhs){
+    lhs = (T) (uint128_t(lhs) - rhs);
+    return lhs;
+}
+
+template <typename T> T operator*(const T & lhs, const uint128_t & rhs){
+    return lhs * (T) rhs.lower();
+}
+
+template <typename T> T & operator*=(T & lhs, const uint128_t & rhs){
+    lhs *= (T) rhs.lower();
+    return lhs;
+}
+
+template <typename T> T operator/(const T & lhs, const uint128_t & rhs){
+    return (T) (uint128_t(lhs) / rhs);
+}
+
+template <typename T> T & operator/=(T & lhs, const uint128_t & rhs){
+    lhs = (T) (uint128_t(lhs) / rhs);
+    return lhs;
+}
+
+template <typename T> T operator%(const T & lhs, const uint128_t & rhs){
+    return (T) (uint128_t(lhs) % rhs);
+}
+
+template <typename T> T & operator%=(T & lhs, const uint128_t & rhs){
+    lhs = (T) (uint128_t(lhs) % rhs);
+    return lhs;
+}
+
+// IO Operator
+std::ostream & operator<<(std::ostream & stream, const uint128_t & rhs);
+#endif
