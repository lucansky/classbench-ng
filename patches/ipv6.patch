diff --git a/FilterList.cc b/FilterList.cc
index c123529..fce2c09 100644
--- a/FilterList.cc
+++ b/FilterList.cc
@@ -11,6 +11,9 @@
 
 #include "stdinc.h"
 #include "FilterList.h"
+#include <network>
+
+namespace ip = std::experimental::net::ip;
 
 FilterList::FilterList() {
   first = last = NULL;
@@ -125,35 +128,66 @@ void FilterList::push(struct filter filt) {
 
 // Print the contents of the FilterList.
 void FilterList::print(FILE* fp) {
-  int addr[4];
-  unsigned temp;
+  uint128_t temp;
   struct FilterList_item *tempfilt;
   
   for (tempfilt = first; tempfilt != NULL; tempfilt = tempfilt->next){
     // Print new filter character
     fprintf(fp,"@");
-    // Print source address
-    addr[0] = addr[1] = addr[2] = addr[3] = 0;
-    temp = 0;
-    temp = tempfilt->filt.sa;
-    addr[0] = (temp >> 24);
-    addr[1] = ((temp << 8) >> 24);
-    addr[2] = ((temp << 16) >> 24);
-    addr[3] = ((temp << 24) >> 24);
-    fprintf(fp, "%d.%d.%d.%d/%d\t",
-	    addr[0], addr[1], addr[2], addr[3],
-	    tempfilt->filt.sa_len);
-    // Print destination address 
-    addr[0] = addr[1] = addr[2] = addr[3] = 0;
-    temp = 0;
-    temp = tempfilt->filt.da;
-    addr[0] = (temp >> 24);
-    addr[1] = ((temp << 8) >> 24);
-    addr[2] = ((temp << 16) >> 24);
-    addr[3] = ((temp << 24) >> 24);
-    fprintf(fp, "%d.%d.%d.%d/%d\t",
-	    addr[0], addr[1], addr[2], addr[3],
-	    tempfilt->filt.da_len);
+    // Print source/destination addresses
+    if (ADDRLEN == 32) { // IPv4
+       // Source address
+       temp = tempfilt->filt.sa >> 96;
+       ip::address_v4 src_addr(temp);
+       fprintf(fp, "%s/%d\t", src_addr.to_string().c_str(), (tempfilt->filt.sa_len < 32) ? tempfilt->filt.sa_len : 32);
+       // Destination address
+       temp = tempfilt->filt.da >> 96;
+       ip::address_v4 dst_addr(temp);
+       fprintf(fp, "%s/%d\t", dst_addr.to_string().c_str(), (tempfilt->filt.da_len < 32) ? tempfilt->filt.da_len : 32);
+    } else { // IPv6
+       // Source address
+       temp = tempfilt->filt.sa;
+       const ip::address_v6::bytes_type src_temp_bytes_type(
+          (unsigned char) (temp.upper() >> 56),
+          (unsigned char) (temp.upper() >> 48),
+          (unsigned char) (temp.upper() >> 40),
+          (unsigned char) (temp.upper() >> 32),
+          (unsigned char) (temp.upper() >> 24),
+          (unsigned char) (temp.upper() >> 16),
+          (unsigned char) (temp.upper() >>  8),
+          (unsigned char)  temp.upper(),
+          (unsigned char) (temp.lower() >> 56),
+          (unsigned char) (temp.lower() >> 48),
+          (unsigned char) (temp.lower() >> 40),
+          (unsigned char) (temp.lower() >> 32),
+          (unsigned char) (temp.lower() >> 24),
+          (unsigned char) (temp.lower() >> 16),
+          (unsigned char) (temp.lower() >>  8),
+          (unsigned char)  temp.lower());
+       ip::address_v6 src_addr(src_temp_bytes_type);
+       fprintf(fp, "%s/%d\t", src_addr.to_string().c_str(), tempfilt->filt.sa_len);
+       // Destination address
+       temp = tempfilt->filt.da;
+       const ip::address_v6::bytes_type dst_temp_bytes_type(
+          (unsigned char) (temp.upper() >> 56),
+          (unsigned char) (temp.upper() >> 48),
+          (unsigned char) (temp.upper() >> 40),
+          (unsigned char) (temp.upper() >> 32),
+          (unsigned char) (temp.upper() >> 24),
+          (unsigned char) (temp.upper() >> 16),
+          (unsigned char) (temp.upper() >>  8),
+          (unsigned char)  temp.upper(),
+          (unsigned char) (temp.lower() >> 56),
+          (unsigned char) (temp.lower() >> 48),
+          (unsigned char) (temp.lower() >> 40),
+          (unsigned char) (temp.lower() >> 32),
+          (unsigned char) (temp.lower() >> 24),
+          (unsigned char) (temp.lower() >> 16),
+          (unsigned char) (temp.lower() >>  8),
+          (unsigned char)  temp.lower());
+       ip::address_v6 dst_addr(dst_temp_bytes_type);
+       fprintf(fp, "%s/%d\t", dst_addr.to_string().c_str(), tempfilt->filt.da_len);
+    }
     // Print source port 
     fprintf(fp, "%d : %d\t",
 	    tempfilt->filt.sp[0], tempfilt->filt.sp[1]);
diff --git a/PrefixList.cc b/PrefixList.cc
index a3df1dc..740d7ea 100644
--- a/PrefixList.cc
+++ b/PrefixList.cc
@@ -11,14 +11,14 @@
 #include "PrefixList.h"
 
 PrefixList::PrefixList() {
-  N = 65;
+  N = 257;
   cdist = 0;
   prefixes = new struct prefix*[25];
   for (int type = 0; type < 25; type++){
     prefixes[type] = new struct prefix[N];
     for (int i = 0; i < N; i++) {
       prefixes[type][i].prob = 0;
-      for (int j = 0; j < 33; j++) prefixes[type][i].sprob[j] = 0;
+      for (int j = 0; j < 129; j++) prefixes[type][i].sprob[j] = 0;
     }
   }
 }
@@ -102,14 +102,14 @@ void PrefixList::read_type(int type, FILE *fp) {
   int tlen = 0;
   int slen = 0;
   float prob = 0;
-  int lens[34];
-  float probs[34];
-  char scomm[500];
-  int scomm_len = 500;
+  int lens[130];
+  float probs[130];
+  char scomm[2000];
+  int scomm_len = 2000;
   while (done == 0) {
     fgets(scomm,scomm_len,fp);
     // Read a line of the input
-    matches = sscanf(scomm,"%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f",&lens[0],&probs[0],&lens[1],&probs[1],&lens[2],&probs[2],&lens[3],&probs[3],&lens[4],&probs[4],&lens[5],&probs[5],&lens[6],&probs[6],&lens[7],&probs[7],&lens[8],&probs[8],&lens[9],&probs[9],&lens[10],&probs[10],&lens[11],&probs[11],&lens[12],&probs[12],&lens[13],&probs[13],&lens[14],&probs[14],&lens[15],&probs[15],&lens[16],&probs[16],&lens[17],&probs[17],&lens[18],&probs[18],&lens[19],&probs[19],&lens[20],&probs[20],&lens[21],&probs[21],&lens[22],&probs[22],&lens[23],&probs[23],&lens[24],&probs[24],&lens[25],&probs[25],&lens[26],&probs[26],&lens[27],&probs[27],&lens[28],&probs[28],&lens[29],&probs[29],&lens[30],&probs[30],&lens[31],&probs[31],&lens[32],&probs[32],&lens[33],&probs[33]);
+    matches = sscanf(scomm,"%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f\t%d,%f",&lens[0],&probs[0],&lens[1],&probs[1],&lens[2],&probs[2],&lens[3],&probs[3],&lens[4],&probs[4],&lens[5],&probs[5],&lens[6],&probs[6],&lens[7],&probs[7],&lens[8],&probs[8],&lens[9],&probs[9],&lens[10],&probs[10],&lens[11],&probs[11],&lens[12],&probs[12],&lens[13],&probs[13],&lens[14],&probs[14],&lens[15],&probs[15],&lens[16],&probs[16],&lens[17],&probs[17],&lens[18],&probs[18],&lens[19],&probs[19],&lens[20],&probs[20],&lens[21],&probs[21],&lens[22],&probs[22],&lens[23],&probs[23],&lens[24],&probs[24],&lens[25],&probs[25],&lens[26],&probs[26],&lens[27],&probs[27],&lens[28],&probs[28],&lens[29],&probs[29],&lens[30],&probs[30],&lens[31],&probs[31],&lens[32],&probs[32],&lens[33],&probs[33],&lens[34],&probs[34],&lens[35],&probs[35],&lens[36],&probs[36],&lens[37],&probs[37],&lens[38],&probs[38],&lens[39],&probs[39],&lens[40],&probs[40],&lens[41],&probs[41],&lens[42],&probs[42],&lens[43],&probs[43],&lens[44],&probs[44],&lens[45],&probs[45],&lens[46],&probs[46],&lens[47],&probs[47],&lens[48],&probs[48],&lens[49],&probs[49],&lens[50],&probs[50],&lens[51],&probs[51],&lens[52],&probs[52],&lens[53],&probs[53],&lens[54],&probs[54],&lens[55],&probs[55],&lens[56],&probs[56],&lens[57],&probs[57],&lens[58],&probs[58],&lens[59],&probs[59],&lens[60],&probs[60],&lens[61],&probs[61],&lens[62],&probs[62],&lens[63],&probs[63],&lens[64],&probs[64],&lens[65],&probs[65],&lens[66],&probs[66],&lens[67],&probs[67],&lens[68],&probs[68],&lens[69],&probs[69],&lens[70],&probs[70],&lens[71],&probs[71],&lens[72],&probs[72],&lens[73],&probs[73],&lens[74],&probs[74],&lens[75],&probs[75],&lens[76],&probs[76],&lens[77],&probs[77],&lens[78],&probs[78],&lens[79],&probs[79],&lens[80],&probs[80],&lens[81],&probs[81],&lens[82],&probs[82],&lens[83],&probs[83],&lens[84],&probs[84],&lens[85],&probs[85],&lens[86],&probs[86],&lens[87],&probs[87],&lens[88],&probs[88],&lens[89],&probs[89],&lens[90],&probs[90],&lens[91],&probs[91],&lens[92],&probs[92],&lens[93],&probs[93],&lens[94],&probs[94],&lens[95],&probs[95],&lens[96],&probs[96],&lens[97],&probs[97],&lens[98],&probs[98],&lens[99],&probs[99],&lens[100],&probs[100],&lens[101],&probs[101],&lens[102],&probs[102],&lens[103],&probs[103],&lens[104],&probs[104],&lens[105],&probs[105],&lens[106],&probs[106],&lens[107],&probs[107],&lens[108],&probs[108],&lens[109],&probs[109],&lens[110],&probs[110],&lens[111],&probs[111],&lens[112],&probs[112],&lens[113],&probs[113],&lens[114],&probs[114],&lens[115],&probs[115],&lens[116],&probs[116],&lens[117],&probs[117],&lens[118],&probs[118],&lens[119],&probs[119],&lens[120],&probs[120],&lens[121],&probs[121],&lens[122],&probs[122],&lens[123],&probs[123],&lens[124],&probs[124],&lens[125],&probs[125],&lens[126],&probs[126],&lens[127],&probs[127],&lens[128],&probs[128],&lens[129],&probs[129]);
     // printf("matches = %d, tlen = %d, prob = %.4f\n",matches,lens[0],probs[0]);
     if (matches >= 4) {
       // Assign total probability
@@ -155,16 +155,16 @@ void PrefixList::smooth_type(int type, int s){
   double tp[129];
   double sp[129];
   double spj[129];
-  struct prefix temps[65];
+  struct prefix temps[N];
   int tlen, slen;
   int r, start, end;
   int delta;
 
   // printf("this = 0x%08x\n",this);
 
-  for (int i=0; i<65; i++) {
+  for (int i=0; i<N; i++) {
     temps[i].prob = 0;
-    for (int j=0; j<33; j++) {
+    for (int j=0; j<129; j++) {
       temps[i].sprob[j] = 0;
     }
   }
@@ -189,9 +189,9 @@ void PrefixList::smooth_type(int type, int s){
 	tlen = i - s; bdist = 0;
       }
       // printf("tlen = %d, bdist = %d\n",tlen,bdist);
-      while (tlen <= 64 && bdist <= tk) {
+      while (tlen <= 256 && bdist <= tk) {
 
-	if (tlen < 0 || tlen > 64){
+	if (tlen < 0 || tlen > 256){
 	  printf("Error 1 : tlen is out of range, tlen = %d\n",tlen);
 	  exit(1);
 	}
@@ -208,7 +208,7 @@ void PrefixList::smooth_type(int type, int s){
       // Spread spike in source distribution for total distribution i
       skj = ((int)floor((double)s/(double)2)) * 2;
       binomial(skj,spj);
-      for (int j = 0; j <= 32; j++){
+      for (int j = 0; j <= 128; j++){
 	// j = source length
 	// Find source spike
 	if (prefixes[type][i].sprob[j] > 0){
@@ -221,9 +221,9 @@ void PrefixList::smooth_type(int type, int s){
 	    slen = j - skj/2; bdist = 0;
 	  }
 	  // printf("slen = %d, bdist = %d\n",slen,bdist);
-	  while (slen <= 32 && bdist <= skj) {
+	  while (slen <= 128 && bdist <= skj) {
 	    
-	    if (i < 0 || i > 64 || slen < 0 || slen > 32){
+	    if (i < 0 || i > 256 || slen < 0 || slen > 128){
 	      printf("Error 2: i or slen is out of range, i = %d, slen = %d\n",i,slen);
 	      exit(1);
 	    }
@@ -242,7 +242,7 @@ void PrefixList::smooth_type(int type, int s){
 	  for (int m = 1; m <= s; m++) {
 	    // compute total length point
 	    r = i - m;
-	    if (0 <= r && r <= 64) {
+	    if (0 <= r && r <= 256) {
 	      // set start, end points for source distribution
 	      start = j - m;
 	      end = j;
@@ -268,9 +268,9 @@ void PrefixList::smooth_type(int type, int s){
 		bdist = 0;
 	      }
 	      // printf("start = %d, bdist = %d\n",start,bdist);
-	      while (start <= 32 && bdist <= sk) {
+	      while (start <= 128 && bdist <= sk) {
 		
-		if (r < 0 || r > 64 || start < 0 || start > 32){
+		if (r < 0 || r > 256 || start < 0 || start > 128){
 		  printf("Error 3: r or start is out of range, r = %d, start = %d\n",r,start);
 		  exit(1);
 		}
@@ -290,7 +290,7 @@ void PrefixList::smooth_type(int type, int s){
 	  for (int m = 1; m <= s; m++) {
 	    // compute total length point
 	    r = i + m;
-	    if (0 <= r && r <= 64) {
+	    if (0 <= r && r <= 256) {
 	      // set start, end points for source distribution
 	      start = j;
 	      end = j + m;
@@ -315,9 +315,9 @@ void PrefixList::smooth_type(int type, int s){
 		bdist = 0;
 	      }
 	      // printf("start = %d, bdist = %d\n",start,bdist);
-	      while (start <= 32 && bdist <= sk) {
+	      while (start <= 128 && bdist <= sk) {
 		
-		if (r < 0 || r > 64 || start < 0 || start > 32){
+		if (r < 0 || r > 256 || start < 0 || start > 128){
 		  printf("Error 4: r or start is out of range, start = %d, q = %d\n",r,start);
 		  exit(1);
 		}
@@ -345,25 +345,25 @@ void PrefixList::smooth_type(int type, int s){
       temps[i].prob = temps[i].prob / totw;
       if (temps[i].prob > 0) {
 	// Truncate source distribution
-	if (i < 32) {
-	  for (int j = i + 1; j <= 32; j++) temps[i].sprob[j] = 0;
+	if (i < 128) {
+	  for (int j = i + 1; j <= 128; j++) temps[i].sprob[j] = 0;
 	}
-	else if (i > 32) {
-	  for (int j = 0; j < i - 32; j++) temps[i].sprob[j] = 0; 
+	else if (i > 128) {
+	  for (int j = 0; j < i - 128; j++) temps[i].sprob[j] = 0;
 	}
 	// Normalize source distribution
 	tots = 0;
-	for (int j = 0; j <= 32; j++) tots += temps[i].sprob[j]; 
-	for (int j = 0; j <= 32; j++) temps[i].sprob[j] = temps[i].sprob[j] / tots; 
+	for (int j = 0; j <= 128; j++) tots += temps[i].sprob[j];
+	for (int j = 0; j <= 128; j++) temps[i].sprob[j] = temps[i].sprob[j] / tots;
       }
     }
     // Apply adjustments to prefixes data structure
     for (int i = 0; i < N; i++) {
       prefixes[type][i].prob = temps[i].prob;
       if (i == N-1) prefixes[type][i].prob = 1;
-      for (int j = 0; j < 33; j++) {
+      for (int j = 0; j < 129; j++) {
 	prefixes[type][i].sprob[j] = temps[i].sprob[j];
-	if (j == 32) prefixes[type][i].sprob[j] = 1;
+	if (j == 128) prefixes[type][i].sprob[j] = 1;
       }
     }
   }
@@ -382,7 +382,7 @@ struct ppair PrefixList::choose_prefix(int type, float rs, float rt) {
   for (int i = 0; (i < N && done == 0); i++) {
     // printf("rt = %.6f, prefixes[type][%d].prob = %.6f\n",rt,i,prefixes[type][i].prob);
     if (rt <= prefixes[type][i].prob) {
-      for (int j = 0; (j < 33 && done == 0); j++) {
+      for (int j = 0; (j < 129 && done == 0); j++) {
 	// printf("rs = %.6f, prefixes[type][%d].sprob[%d] = %.6f\n",rs,i,j,prefixes[type][i].sprob[j]);
 	if (rs <= prefixes[type][i].sprob[j]){
 	  pair.slen = j;
@@ -407,7 +407,7 @@ void PrefixList::build_cdist() {
       tp = prefixes[type][i].prob;
       // Cummulative source distribution
       sp = 0;
-      for (int j = 0; j < 33; j++){
+      for (int j = 0; j < 129; j++){
 	prefixes[type][i].sprob[j] += sp;
 	sp = prefixes[type][i].sprob[j];
       } 
@@ -421,7 +421,7 @@ void PrefixList::print(int type, FILE *fp) {
   for (int i = 0; i < N; i++){
     if (prefixes[type][i].prob != 0) {
       fprintf(fp,"%d,%.8f",i,prefixes[type][i].prob);
-      for (int j = 0; j <= 32; j++) {
+      for (int j = 0; j <= 128; j++) {
 	if (prefixes[type][i].sprob[j] != 0) {
 	  fprintf(fp,"\t%d,%.8f",j,prefixes[type][i].sprob[j]);
 	}
diff --git a/PrefixList.h b/PrefixList.h
index 2d39529..1df63a2 100644
--- a/PrefixList.h
+++ b/PrefixList.h
@@ -15,7 +15,7 @@
 
 struct prefix {
   float prob;
-  float sprob[33];
+  float sprob[129];
 };
 
 class PrefixList {
diff --git a/README b/README
index 116aac2..f104e85 100644
--- a/README
+++ b/README
@@ -75,17 +75,17 @@ PPC
 10	AR/WC	source port arbitrary range, destination port wildcard
 11	HI/AR	source port [1024:65535], destination port arbitrary range
 12	AR/HI	source port arbitrary range, destination port [1024:65535]
-13	LO/AR	source port [0:1023], destination port arbitrary range
-14	AR/LO	source port arbitrary range, destination port [0:1023]
-15	AR/AR	source port arbitrary range, destination port arbitrary range
-16	WC/EM	source port wildcard, destination port exact match
-17	EM/WC	source port exact match, destination port wildcard
-18	HI/EM	source port [1024:65535], destination port exact match
-19	EM/HI	source port exact match, destination port [1024:65535]
-20	LO/EM	source port [0:1023], destination port exact match
-21	EM/LO	source port exact match, destination port [0:1023]
+13	WC/EM	source port wildcard, destination port exact match
+14	EM/WC	source port exact match, destination port wildcard
+15	HI/EM	source port [1024:65535], destination port exact match
+16	EM/HI	source port exact match, destination port [1024:65535]
+17	LO/AR	source port [0:1023], destination port arbitrary range
+18	AR/LO	source port arbitraty range, destination port [0:1023]
+19	LO/EM	source port [0:1023], destination port exact match
+20	EM/LO	source port exact match, destination port [0:1023]
+21	AR/AR	source port arbitraty range, destination port arbitrary range
 22	AR/EM	source port arbitrary range, destination port exact match
-23	EM/AR	source port exact match, destination port exact match arbitrary range
+23	EM/AR	source port exact match, destination port arbitrary range
 24	EM/EM	source port exact match, destination port exact match
 
 -flags
diff --git a/TupleBST.cc b/TupleBST.cc
index 9163d9b..32e0cc8 100644
--- a/TupleBST.cc
+++ b/TupleBST.cc
@@ -34,7 +34,7 @@ void TupleBST::cleanup(TupleBST_item* node){
 
 int TupleBST::scope(FiveTuple* ftuple){
   double scope5d;
-  scope5d = (32 - ftuple->sa_len) + (32 - ftuple->da_len) + (log(ftuple->sp_wid)/log(2)) + (log(ftuple->dp_wid)/log(2)) + (8*(1 - ftuple->prot)) + (1 - ftuple->flag);
+  scope5d = (128 - ftuple->sa_len) + (128 - ftuple->da_len) + (log(ftuple->sp_wid)/log(2)) + (log(ftuple->dp_wid)/log(2)) + (8*(1 - ftuple->prot)) + (1 - ftuple->flag);
   return (int)scope5d;
 }
 
diff --git a/custom_db.cc b/custom_db.cc
index 6f8d193..0484e53 100644
--- a/custom_db.cc
+++ b/custom_db.cc
@@ -20,7 +20,9 @@
 #include "redundant_filter_check.h"
 #include "TupleBST.h"
 #include "custom_db.h"
+#include <network>
 
+namespace ip = std::experimental::net::ip;
 
 int custom_db_gen(int num_filters, FilterList* filters, FILE* fp_in, int smoothness, float addr_scope, float port_scope, int branch){
 
@@ -464,33 +466,64 @@ void select_ports(int port_type, struct filter *temp_filter, PortList *sparL, Po
 }
 
 void fprint_filter(FILE *fp, struct filter *filt){
-  int addr[4];
-  unsigned temp;
+  uint128_t temp;
 
   // Print new filter character
   fprintf(fp,"@");
-  // Print source address
-  addr[0] = addr[1] = addr[2] = addr[3] = 0;
-  temp = 0;
-  temp = filt->sa;
-  addr[0] = (temp >> 24);
-  addr[1] = ((temp << 8) >> 24);
-  addr[2] = ((temp << 16) >> 24);
-  addr[3] = ((temp << 24) >> 24);
-  fprintf(fp, "%d.%d.%d.%d/%d\t",
-	  addr[0], addr[1], addr[2], addr[3],
-	  filt->sa_len);
-  // Print destination address 
-  addr[0] = addr[1] = addr[2] = addr[3] = 0;
-  temp = 0;
-  temp = filt->da;
-  addr[0] = (temp >> 24);
-  addr[1] = ((temp << 8) >> 24);
-  addr[2] = ((temp << 16) >> 24);
-  addr[3] = ((temp << 24) >> 24);
-  fprintf(fp, "%d.%d.%d.%d/%d\t",
-	  addr[0], addr[1], addr[2], addr[3],
-	  filt->da_len);
+  // Print source/destination address
+  if (ADDRLEN == 32) { // IPv4
+     // Source address
+     temp = filt->sa >> 96;
+     ip::address_v4 src_addr(temp);
+     fprintf(fp, "%s/%d\t", src_addr.to_string().c_str(), (filt->sa_len < 32) ? filt->sa_len : 32);
+     // Destination address
+     temp = filt->da >> 96;
+     ip::address_v4 dst_addr(temp);
+     fprintf(fp, "%s/%d\t", dst_addr.to_string().c_str(), (filt->da_len < 32) ? filt->da_len : 32);
+  } else { // IPv6
+     // Source address
+     temp = filt->sa;
+     const ip::address_v6::bytes_type src_temp_bytes_type(
+        (unsigned char) (temp.upper() >> 56),
+        (unsigned char) (temp.upper() >> 48),
+        (unsigned char) (temp.upper() >> 40),
+        (unsigned char) (temp.upper() >> 32),
+        (unsigned char) (temp.upper() >> 24),
+        (unsigned char) (temp.upper() >> 16),
+        (unsigned char) (temp.upper() >>  8),
+        (unsigned char)  temp.upper(),
+        (unsigned char) (temp.lower() >> 56),
+        (unsigned char) (temp.lower() >> 48),
+        (unsigned char) (temp.lower() >> 40),
+        (unsigned char) (temp.lower() >> 32),
+        (unsigned char) (temp.lower() >> 24),
+        (unsigned char) (temp.lower() >> 16),
+        (unsigned char) (temp.lower() >>  8),
+        (unsigned char)  temp.lower());
+     ip::address_v6 src_addr(src_temp_bytes_type);
+     fprintf(fp, "%s/%d\t", src_addr.to_string().c_str(), filt->sa_len);
+     // Destination address
+     temp = filt->da;
+     const ip::address_v6::bytes_type dst_temp_bytes_type(
+        (unsigned char) (temp.upper() >> 56),
+        (unsigned char) (temp.upper() >> 48),
+        (unsigned char) (temp.upper() >> 40),
+        (unsigned char) (temp.upper() >> 32),
+        (unsigned char) (temp.upper() >> 24),
+        (unsigned char) (temp.upper() >> 16),
+        (unsigned char) (temp.upper() >>  8),
+        (unsigned char)  temp.upper(),
+        (unsigned char) (temp.lower() >> 56),
+        (unsigned char) (temp.lower() >> 48),
+        (unsigned char) (temp.lower() >> 40),
+        (unsigned char) (temp.lower() >> 32),
+        (unsigned char) (temp.lower() >> 24),
+        (unsigned char) (temp.lower() >> 16),
+        (unsigned char) (temp.lower() >>  8),
+        (unsigned char)  temp.lower());
+     ip::address_v6 dst_addr(dst_temp_bytes_type);
+     fprintf(fp, "%s/%d\t", dst_addr.to_string().c_str(), filt->da_len);
+  }
   // Print source port 
   fprintf(fp, "%d : %d\t",
 	  filt->sp[0], filt->sp[1]);
diff --git a/db_generator.cc b/db_generator.cc
index 3344759..afa53fb 100644
--- a/db_generator.cc
+++ b/db_generator.cc
@@ -15,6 +15,9 @@
 #include "custom_db.h"
 #include "sys/time.h"
 
+// IP address length in bits (global variable)
+int ADDRLEN = 32;
+
 main(int argc, char *argv[])
 {
   char filename[1024];  
@@ -24,19 +27,20 @@ main(int argc, char *argv[])
   FILE *fp_std; // output file pointer for standard form filter file 
 
   int num_filters = 0; // number of filters 
-  
+
   int smoothness = 0; // precision of database replication 
   float addr_scope = 0; // adjustment to average address scope 
   float port_scope = 0; // adjustment to average port scope 
   
   // Check for correct number of input arguments 
   if (argc > 8 || argc <= 1){
-    fprintf(stderr,"Usage: db_generator -hrb (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+    fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
     fprintf(stderr,"db_generator is a synthetic filter database generator.\n");
-    fprintf(stderr,"Usage: db_generator -hrb (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+    fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
     fprintf(stderr,"\t -h displays help menu\n");
     fprintf(stderr,"\t -r generates a random database\n");
     fprintf(stderr,"\t -b turns on address prefix scaling with database size; note that this alters the skew distribution in the parameter file\n");
+    fprintf(stderr,"\t -6 generates a database with IPv6 5-tuples\n");
     fprintf(stderr,"\t -c generates a custom database using an input parameter file\n");
     fprintf(stderr,"\t <smoothness> is a parameter [0:64] that injects structured randomness\n");
     fprintf(stderr,"\t <address scope> is a parameter [-1.0:1.0] that adjusts the average scope of the address prefix pairs\n");
@@ -65,12 +69,16 @@ main(int argc, char *argv[])
       case 'b':
 	branch = 1;
 	break;
+      case '6':
+	ADDRLEN = 128;
+	break;
       case 'h':
 	fprintf(stderr,"db_generator is a synthetic filter database generator.\n");
-	fprintf(stderr,"Usage: db_generator -hrb (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+	fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
 	fprintf(stderr,"\t -h displays help menu\n");
 	fprintf(stderr,"\t -r generates a random database\n");
 	fprintf(stderr,"\t -b turns on address prefix scaling with database size; note that this alters the skew distribution in the parameter file\n");
+	fprintf(stderr,"\t -6 generates a database with IPv6 5-tuples\n");
 	fprintf(stderr,"\t -c generates a custom database using an input parameter file\n");
 	fprintf(stderr,"\t <smoothness> is a parameter [0:64] that injects structured randomness\n");
 	fprintf(stderr,"\t <address scope> is a parameter [-1.0:1.0] that adjusts the average scope of the address prefixe pairs\n");
@@ -87,7 +95,7 @@ main(int argc, char *argv[])
       }
     }
   }
-  
+
   if (random == 1 && argc == 2){
     num_filters = atoi(argv[0]);
     strcpy(filename,argv[1]);
@@ -99,21 +107,21 @@ main(int argc, char *argv[])
     // printf("smoothness = %d\n",smoothness);
     if (smoothness < 0 || smoothness > 64) {
       fprintf(stderr,"Error smoothness must be a value in the range [0:64]\n");
-      fprintf(stderr,"Usage: db_generator -hr (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+      fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
       exit(1);
     }
     sscanf(argv[3],"%f",&addr_scope);
     // printf("addr_scope = %.4f\n",addr_scope);
     if (addr_scope < -1 || addr_scope > 1) {
       fprintf(stderr,"Error address scope must be a value in the range [-1:1]\n");
-      fprintf(stderr,"Usage: db_generator -hr (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+      fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
       exit(1);
     }
     sscanf(argv[4],"%f",&port_scope);
     // printf("addr_scope = %.4f\n",port_scope);
     if (port_scope < -1 || port_scope > 1) {
       fprintf(stderr,"Error port scope must be a value in the range [-1:1]\n");
-      fprintf(stderr,"Usage: db_generator -hr (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+      fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
       exit(1);
     }
     strcpy(filename,argv[5]);
@@ -121,7 +129,7 @@ main(int argc, char *argv[])
     fp_in = fopen(in_filename,"r");
     if (fp_in == NULL) {fprintf(stderr,"ERROR: cannot open seed file %s\n",in_filename); exit(1);}
   } else {
-    fprintf(stderr,"Usage: db_generator -hr (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
+    fprintf(stderr,"Usage: db_generator -hrb6 (-c <input parameter file>) <number of filters> <smoothness> <address scope> <port scope> <output filename>\n");
     exit(1);
   }
 
diff --git a/dbintree.cc b/dbintree.cc
index 9274710..a2f76d1 100644
--- a/dbintree.cc
+++ b/dbintree.cc
@@ -13,13 +13,13 @@
 
 dbintree::dbintree() {
 // Initialize to graph with N vertices and no edges.
-  skew = new float[33];
-  corr = new float[33];
-  p1child = new float[33];
-  p2child = new float[33];
+  skew = new float[129];
+  corr = new float[129];
+  p1child = new float[129];
+  p2child = new float[129];
   num_tnodes = 0;
   root = NULL;
-  for (int u = 0; u < 33; u++) {
+  for (int u = 0; u < 129; u++) {
     skew[u] = 0;
     corr[u] = 0;
     p1child[u] = 0;
@@ -99,13 +99,13 @@ void dbintree::read_skew(FILE* fp_in){
     // printf("matches = %d\n",matches);
     // printf("level = %d, skew = %.4f\n",level,skew);
     if (matches == 4) {
-      if (level <= 32) {
+      if (level <= 128) {
 	p1child[level] = p1_t;
 	p2child[level] = p2_t;
 	skew[level] = f_skew;
       }
       else {
-	fprintf(stderr,"Level for destination address skew is greater than 32.\n");
+	fprintf(stderr,"Level for destination address skew is greater than 128.\n");
 	exit(1);
       }
       // printf("Read line: %d\t%.4f\t%.4f\t%.4f\n",level,p1_t,p2_t,f_skew);
@@ -147,7 +147,7 @@ void dbintree::read_corr(FILE* fp_in){
 void dbintree::print_skew(FILE *fp) {
   
   fprintf(fp,"Level\tp1\tp2\tSkew\n");
-  for (int i = 0; i < 33; i++) {
+  for (int i = 0; i < 129; i++) {
     fprintf(fp,"%d\t%.4f\t%.4f\t%.4f\n",
 	    i,p1child[i],p2child[i],skew[i]);
   }
@@ -157,14 +157,14 @@ void dbintree::print_skew(FILE *fp) {
 void dbintree::print_corr(FILE *fp) {
   
   fprintf(fp,"Level\tCorr\n");
-  for (int i = 0; i < 33; i++) {
+  for (int i = 0; i < 129; i++) {
     fprintf(fp,"%d\t%.4f\n",i,corr[i]);
   }
   return;
 }
 
 void dbintree::build_tree(dlist* Flist, struct filter filters[]){
-  unsigned int addr = 0;
+  uint128_t addr = 0;
   // Create copy of list
   dlist *temp_list = new dlist();
   (*temp_list)=(Flist);
@@ -221,7 +221,7 @@ void dbintree::add2child_stublist(struct tnode *node, int dir, int filt){
   return;
 }
 
-void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, struct filter filters[], int CurrNest){
+void dbintree::add_stub(struct tnode *node, uint128_t addr, dlist* Flist, struct filter filters[], int CurrNest){
   int Flist_size = 0;
   int lev = node->lvl;
   
@@ -237,21 +237,21 @@ void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, str
   // printf("Flist_size = %d\n",Flist_size);
   
   double temp;
-  unsigned int sa;
+  uint128_t sa;
 
-  unsigned int addr0, addr1;
+  uint128_t addr0, addr1;
   // Adjust addresses
   if (lev == 0) {
     addr0 = 0;
     addr1 = 1;
-    addr1 = addr1 << 31;
+    addr1 = addr1 << 127;
   } else {
-    addr0 = addr >> (32 - lev);
-    addr0 = addr0 << (32 - lev);
-    addr1 = addr >> (32 - lev);
+    addr0 = addr >> (128 - lev);
+    addr0 = addr0 << (128 - lev);
+    addr1 = addr >> (128 - lev);
     addr1 = addr1 << 1;
     addr1 += 1;
-    addr1 = addr1 << (31 - lev);
+    addr1 = addr1 << (127 - lev);
   }
  
   // Allocate temp_list's
@@ -297,7 +297,7 @@ void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, str
   // printf("Flist_size = %d, tempList: ",Flist_size); tempList->print(stdout); printf("\n");
   // if lev1_flag == 1, dump all lev1 filters to one side
   // printf("lev = %d, MyNest = %d, Nest = %d, lev1_flag = %d\n",lev,MyNest,Nest,lev1_flag);
-  if ((Flist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 31)){
+  if ((Flist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 127)){
     // printf("add_stub: Enforcing nesting limit\n");
     // Add all filters to stublist and let the finish_node process distribute them
     int fptr;
@@ -331,7 +331,7 @@ void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, str
 	// sa_len > lvl
 	// Prevent prefix nesting
 	sa = sa << lev;
-	sa = sa >> 31;
+	sa = sa >> 127;
 	// sa now equals next "bit" of source address
 	if (filters[fptr].sa_len == (lev+1)) {
 	  // Source prefix will be exhausted at next level
@@ -407,7 +407,7 @@ void dbintree::add_stub(struct tnode *node, unsigned int addr, dlist* Flist, str
   return;
 }
 
-void dbintree::finish_node(struct tnode *node, unsigned int addr, dlist* Flist, struct filter filters[], int CurrNest){
+void dbintree::finish_node(struct tnode *node, uint128_t addr, dlist* Flist, struct filter filters[], int CurrNest){
   int Flist_size = 0;
   int stubList_size = 0;
   int lev = node->lvl;
@@ -479,20 +479,20 @@ void dbintree::finish_node(struct tnode *node, unsigned int addr, dlist* Flist,
 
   double temp;
   int path;
-  unsigned int addr0, addr1;
+  uint128_t addr0, addr1;
 
   // Adjust addresses
   if (lev == 0) {
     addr0 = 0;
     addr1 = 1;
-    addr1 = addr1 << 31;
+    addr1 = addr1 << 127;
   } else {
-    addr0 = addr >> (32 - lev);
-    addr0 = addr0 << (32 - lev);
-    addr1 = addr >> (32 - lev);
+    addr0 = addr >> (128 - lev);
+    addr0 = addr0 << (128 - lev);
+    addr1 = addr >> (128 - lev);
     addr1 = addr1 << 1;
     addr1 += 1;
-    addr1 = addr1 << (31 - lev);
+    addr1 = addr1 << (127 - lev);
   }
   
   // Create an empty list
@@ -519,7 +519,7 @@ void dbintree::finish_node(struct tnode *node, unsigned int addr, dlist* Flist,
     // If at the nesting threshold and list has more than one child,
     //   then split list (allocate all nodes with level == lev1 to one path)
     // printf("lev = %d, MyNest = %d, Nest = %d, lev1_flag = %d\n",lev,MyNest,Nest,lev1_flag);
-    if ((templist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 31)){
+    if ((templist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 127)){
       // Allocate nest_list
       dlist *nest_list = new dlist();
       dlist *other_list = new dlist();
diff --git a/dbintree.h b/dbintree.h
index 5509fc3..b3f87e5 100644
--- a/dbintree.h
+++ b/dbintree.h
@@ -33,10 +33,10 @@ class dbintree {
   float *p1child; // probability that a node at a given level has one child
   float *p2child; // probability that a node at a given level has two children
   int num_tnodes; // number of tree nodes 
-  void add_stub(struct tnode *node, unsigned int addr, dlist* Flist, struct filter filters[],int CurrNest);
+  void add_stub(struct tnode *node, uint128_t addr, dlist* Flist, struct filter filters[],int CurrNest);
   void add2child_stublist(struct tnode *node, int dir, int filt);
   void add_node(struct tnode *prnt, int lev, int dir);
-  void finish_node(struct tnode *node, unsigned int addr, dlist* Flist, struct filter filters[],int CurrNest);
+  void finish_node(struct tnode *node, uint128_t addr, dlist* Flist, struct filter filters[],int CurrNest);
   int Nest; // Maximum allowed nesting
 
  public: dbintree();
diff --git a/ip-address/COPYING b/ip-address/COPYING
new file mode 100644
index 0000000..03fc9f6
--- /dev/null
+++ b/ip-address/COPYING
@@ -0,0 +1,4 @@
+Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+
+Distributed under the Boost Software License, Version 1.0. (See accompanying
+file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff --git a/ip-address/LICENSE_1_0.txt b/ip-address/LICENSE_1_0.txt
new file mode 100644
index 0000000..36b7cd9
--- /dev/null
+++ b/ip-address/LICENSE_1_0.txt
@@ -0,0 +1,23 @@
+Boost Software License - Version 1.0 - August 17th, 2003
+
+Permission is hereby granted, free of charge, to any person or organization
+obtaining a copy of the software and accompanying documentation covered by
+this license (the "Software") to use, reproduce, display, distribute,
+execute, and transmit the Software, and to prepare derivative works of the
+Software, and to permit third-parties to whom the Software is furnished to
+do so, all subject to the following:
+
+The copyright notices in the Software and this entire statement, including
+the above license grant, this restriction and the following disclaimer,
+must be included in all copies of the Software, in whole or in part, and
+all derivative works of the Software, unless such copies or derivative
+works are solely in the form of machine-executable object code generated by
+a source language processor.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/ip-address/README.md b/ip-address/README.md
new file mode 100644
index 0000000..08ff928
--- /dev/null
+++ b/ip-address/README.md
@@ -0,0 +1,18 @@
+IP Address Proposal
+===================
+
+Proposed IP addresses classes for the standard C++ library.
+
+What's Included
+---------------
+
+* `./include` - Reference implementation.
+
+Tested Platforms
+----------------
+
+* Mac OS 10.8 using g++ 4.7 (requires `-std=c++11`)
+* Mac OS 10.8 using clang++ from Xcode 4.6 (requires `-std=c++11` and `-stdlib=libc++`)
+* Linux (CentOS 6.2) using g++ 4.7 (requires `-std=c++11`)
+* Windows 7 32-bit using Visual Studio 2010
+* Windows 7 x64 using Visual Studio 2010
diff --git a/ip-address/include/network b/ip-address/include/network
new file mode 100644
index 0000000..c97ea69
--- /dev/null
+++ b/ip-address/include/network
@@ -0,0 +1,25 @@
+//
+// network
+// ~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_NETWORK_HEADER_FILE
+#define STDNET_NETWORK_HEADER_FILE
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/ip/fwd.hpp"
+#include "std/net/ip/address.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/address_v6.hpp"
+#include "std/net/ip/address_cast.hpp"
+#include "std/net/literals.hpp"
+
+#endif // STDNET_NETWORK_HEADER_FILE
diff --git a/ip-address/include/std/net/detail/config.hpp b/ip-address/include/std/net/detail/config.hpp
new file mode 100644
index 0000000..c797490
--- /dev/null
+++ b/ip-address/include/std/net/detail/config.hpp
@@ -0,0 +1,666 @@
+//
+// detail/config.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_CONFIG_HPP
+#define STDNET_DETAIL_CONFIG_HPP
+
+// Default to a header-only implementation. The user must specifically request
+// separate compilation by defining either STDNET_SEPARATE_COMPILATION or
+// STDNET_DYN_LINK (as a DLL/shared library implies separate compilation).
+#if !defined(STDNET_HEADER_ONLY)
+# if !defined(STDNET_SEPARATE_COMPILATION)
+#  if !defined(STDNET_DYN_LINK)
+#   define STDNET_HEADER_ONLY 1
+#  endif // !defined(STDNET_DYN_LINK)
+# endif // !defined(STDNET_SEPARATE_COMPILATION)
+#endif // !defined(STDNET_HEADER_ONLY)
+
+#if defined(STDNET_HEADER_ONLY)
+# define STDNET_DECL inline
+#else // defined(STDNET_HEADER_ONLY)
+# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(__CODEGEARC__)
+// We need to import/export our code only if the user has specifically asked
+// for it by defining STDNET_DYN_LINK.
+#  if defined(STDNET_DYN_LINK)
+// Export if this is our own source, otherwise import.
+#   if defined(STDNET_SOURCE)
+#    define STDNET_DECL __declspec(dllexport)
+#   else // defined(STDNET_SOURCE)
+#    define STDNET_DECL __declspec(dllimport)
+#   endif // defined(STDNET_SOURCE)
+#  endif // defined(STDNET_DYN_LINK)
+# endif // defined(_MSC_VER) || defined(__BORLANDC__) || defined(__CODEGEARC__)
+#endif // defined(STDNET_HEADER_ONLY)
+
+// If STDNET_DECL isn't defined yet define it now.
+#if !defined(STDNET_DECL)
+# define STDNET_DECL
+#endif // !defined(STDNET_DECL)
+
+// Microsoft Visual C++ detection.
+#if !defined(STDNET_MSVC)
+# if defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__EDG_VERSION__)
+#  define STDNET_MSVC _MSC_VER
+# endif // defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__EDG_VERSION__)
+#endif // defined(STDNET_MSVC)
+
+// Support move construction and assignment on compilers known to allow it.
+#if !defined(STDNET_HAS_MOVE)
+# if !defined(STDNET_DISABLE_MOVE)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_MOVE 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_MOVE)
+#endif // !defined(STDNET_HAS_MOVE)
+
+// If STDNET_MOVE_CAST isn't defined, and move support is available, define
+// STDNET_MOVE_ARG and STDNET_MOVE_CAST to take advantage of rvalue
+// references and perfect forwarding.
+#if defined(STDNET_HAS_MOVE) && !defined(STDNET_MOVE_CAST)
+# define STDNET_MOVE_ARG(type) type&&
+# define STDNET_MOVE_CAST(type) static_cast<type&&>
+#endif // defined(STDNET_HAS_MOVE) && !defined(STDNET_MOVE_CAST)
+
+// If STDNET_MOVE_CAST still isn't defined, default to a C++03-compatible
+// implementation. Note that older g++ and MSVC versions don't like it when you
+// pass a non-member function through a const reference, so for most compilers
+// we'll play it safe and stick with the old approach of passing the handler by
+// value.
+#if !defined(STDNET_MOVE_CAST)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ > 4)
+#   define STDNET_MOVE_ARG(type) const type&
+#  else // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ > 4)
+#   define STDNET_MOVE_ARG(type) type
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ > 4)
+# elif defined(STDNET_MSVC)
+#  if (_MSC_VER >= 1400)
+#   define STDNET_MOVE_ARG(type) const type&
+#  else // (_MSC_VER >= 1400)
+#   define STDNET_MOVE_ARG(type) type
+#  endif // (_MSC_VER >= 1400)
+# else
+#  define STDNET_MOVE_ARG(type) type
+# endif
+# define STDNET_MOVE_CAST(type) static_cast<const type&>
+#endif // !defined_STDNET_MOVE_CAST
+
+// Support variadic templates on compilers known to allow it.
+#if !defined(STDNET_HAS_VARIADIC_TEMPLATES)
+# if !defined(STDNET_DISABLE_VARIADIC_TEMPLATES)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_VARIADIC_TEMPLATES 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_variadic_templates)
+#   define STDNET_HAS_VARIADIC_TEMPLATES 1
+#  endif // __has_feature(cxx_noexcept)
+# endif // defined(__clang__)
+# endif // !defined(STDNET_DISABLE_VARIADIC_TEMPLATES)
+#endif // !defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+// Support the noexcept specifier on compilers known to allow it.
+#if !defined(STDNET_NOEXCEPT)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#    define STDNET_NOEXCEPT noexcept
+#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+# endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_noexcept)
+#   define STDNET_NOEXCEPT noexcept
+#  endif // __has_feature(cxx_noexcept)
+# endif // defined(__clang__)
+# if !defined(STDNET_NOEXCEPT)
+#  define STDNET_NOEXCEPT
+# endif // !defined(STDNET_NOEXCEPT)
+#endif // !defined(STDNET_NOEXCEPT)
+
+// Support deleted functions on compilers known to allow it.
+#if !defined(STDNET_DELETED)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#    define STDNET_DELETED = delete
+#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+# endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_deleted_functions)
+#   define STDNET_DELETED = delete
+#  endif // __has_feature(cxx_noexcept)
+# endif // defined(__clang__)
+# if !defined(STDNET_DELETED)
+#  define STDNET_DELETED
+# endif // !defined(STDNET_DELETED)
+#endif // !defined(STDNET_DELETED)
+
+// Support relaxed constexpr on compilers known to allow it.
+#if !defined(STDNET_CONSTEXPR)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#    define STDNET_HAS_CONSTEXPR 1
+#    define STDNET_CONSTEXPR constexpr
+#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+# endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_constexpr)
+#   define STDNET_HAS_CONSTEXPR 1
+#   define STDNET_CONSTEXPR constexpr
+#  endif // __has_feature(cxx_constexpr)
+# endif // defined(__clang__)
+# if !defined(STDNET_CONSTEXPR)
+#  define STDNET_CONSTEXPR
+# endif // !defined(STDNET_CONSTEXPR)
+#endif // !defined(STDNET_CONSTEXPR)
+
+// Standard library support for system errors.
+#if !defined(STDNET_HAS_STD_SYSTEM_ERROR)
+# if !defined(STDNET_DISABLE_STD_SYSTEM_ERROR)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_SYSTEM_ERROR 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_SYSTEM_ERROR)
+#endif // !defined(STDNET_HAS_STD_SYSTEM_ERROR)
+
+// Compliant C++11 compilers put noexcept specifiers on error_category members.
+#if !defined(STDNET_ERROR_CATEGORY_NOEXCEPT)
+# if defined(__GNUC__)
+#  if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+#   if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_ERROR_CATEGORY_NOEXCEPT noexcept(true)
+#   endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#  endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 7)) || (__GNUC__ > 4)
+# endif // defined(__GNUC__)
+# if defined(__clang__)
+#  if __has_feature(cxx_noexcept)
+#    define STDNET_ERROR_CATEGORY_NOEXCEPT noexcept(true)
+#  endif // __has_feature(cxx_noexcept)
+# endif // defined(__clang__)
+# if !defined(STDNET_ERROR_CATEGORY_NOEXCEPT)
+#  define STDNET_ERROR_CATEGORY_NOEXCEPT
+# endif // !defined(STDNET_ERROR_CATEGORY_NOEXCEPT)
+#endif // !defined(STDNET_ERROR_CATEGORY_NOEXCEPT)
+
+// Standard library support for arrays.
+#if !defined(STDNET_HAS_STD_ARRAY)
+# if !defined(STDNET_DISABLE_STD_ARRAY)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_ARRAY 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+#  if defined(STDNET_MSVC)
+#   if (_MSC_VER >= 1600)
+#    define STDNET_HAS_STD_ARRAY 1
+#   endif // (_MSC_VER >= 1600)
+#  endif // defined(STDNET_MSVC)
+# endif // !defined(STDNET_DISABLE_STD_ARRAY)
+#endif // !defined(STDNET_HAS_STD_ARRAY)
+
+// Standard library support for shared_ptr and weak_ptr.
+#if !defined(STDNET_HAS_STD_SHARED_PTR)
+# if !defined(STDNET_DISABLE_STD_SHARED_PTR)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_SHARED_PTR 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+#  if defined(STDNET_MSVC)
+#   if (_MSC_VER >= 1600)
+#    define STDNET_HAS_STD_SHARED_PTR 1
+#   endif // (_MSC_VER >= 1600)
+#  endif // defined(STDNET_MSVC)
+# endif // !defined(STDNET_DISABLE_STD_SHARED_PTR)
+#endif // !defined(STDNET_HAS_STD_SHARED_PTR)
+
+// Standard library support for atomic operations.
+#if !defined(STDNET_HAS_STD_ATOMIC)
+# if !defined(STDNET_DISABLE_STD_ATOMIC)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_ATOMIC 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_ATOMIC)
+#endif // !defined(STDNET_HAS_STD_ATOMIC)
+
+// Standard library support for chrono. Some standard libraries (such as the
+// libstdc++ shipped with gcc 4.6) provide monotonic_clock as per early C++0x
+// drafts, rather than the eventually standardised name of steady_clock.
+#if !defined(STDNET_HAS_STD_CHRONO)
+# if !defined(STDNET_DISABLE_STD_CHRONO)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_CHRONO 1
+#     if ((__GNUC__ == 4) && (__GNUC_MINOR__ == 6))
+#      define STDNET_HAS_STD_CHRONO_MONOTONIC_CLOCK 1
+#     endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ == 6))
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_CHRONO)
+#endif // !defined(STDNET_HAS_STD_CHRONO)
+
+// Standard library support for addressof.
+#if !defined(STDNET_HAS_STD_ADDRESSOF)
+# if !defined(STDNET_DISABLE_STD_ADDRESSOF)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_ADDRESSOF 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_ADDRESSOF)
+#endif // !defined(STDNET_HAS_STD_ADDRESSOF)
+
+// Standard library support for the function class.
+#if !defined(STDNET_HAS_STD_FUNCTION)
+# if !defined(STDNET_DISABLE_STD_FUNCTION)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_FUNCTION 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_FUNCTION)
+#endif // !defined(STDNET_HAS_STD_FUNCTION)
+
+// Standard library support for type traits.
+#if !defined(STDNET_HAS_STD_TYPE_TRAITS)
+# if !defined(STDNET_DISABLE_STD_TYPE_TRAITS)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_STD_TYPE_TRAITS 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_STD_TYPE_TRAITS)
+#endif // !defined(STDNET_HAS_STD_TYPE_TRAITS)
+
+// Standard library support for the cstdint header.
+#if !defined(STDNET_HAS_CSTDINT)
+# if !defined(STDNET_DISABLE_CSTDINT)
+#  if defined(__GNUC__)
+#   if ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#    if defined(__GXX_EXPERIMENTAL_CXX0X__)
+#     define STDNET_HAS_CSTDINT 1
+#    endif // defined(__GXX_EXPERIMENTAL_CXX0X__)
+#   endif // ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 5)) || (__GNUC__ > 4)
+#  endif // defined(__GNUC__)
+# endif // !defined(STDNET_DISABLE_CSTDINT)
+#endif // !defined(STDNET_HAS_CSTDINT)
+
+// Windows target.
+#if !defined(STDNET_WINDOWS)
+# if defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
+#  define STDNET_WINDOWS 1
+# endif // defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
+#endif // !defined(STDNET_WINDOWS)
+
+// Windows: target OS version.
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# if !defined(_WIN32_WINNT) && !defined(_WIN32_WINDOWS)
+#  if defined(_MSC_VER) || defined(__BORLANDC__)
+#   pragma message( \
+  "Please define _WIN32_WINNT or _WIN32_WINDOWS appropriately. For example:\n"\
+  "- add -D_WIN32_WINNT=0x0501 to the compiler command line; or\n"\
+  "- add _WIN32_WINNT=0x0501 to your project's Preprocessor Definitions.\n"\
+  "Assuming _WIN32_WINNT=0x0501 (i.e. Windows XP target).")
+#  else // defined(_MSC_VER) || defined(__BORLANDC__)
+#   warning Please define _WIN32_WINNT or _WIN32_WINDOWS appropriately.
+#   warning For example, add -D_WIN32_WINNT=0x0501 to the compiler command line.
+#   warning Assuming _WIN32_WINNT=0x0501 (i.e. Windows XP target).
+#  endif // defined(_MSC_VER) || defined(__BORLANDC__)
+#  define _WIN32_WINNT 0x0501
+# endif // !defined(_WIN32_WINNT) && !defined(_WIN32_WINDOWS)
+# if defined(_MSC_VER)
+#  if defined(_WIN32) && !defined(WIN32)
+#   if !defined(_WINSOCK2API_)
+#    define WIN32 // Needed for correct types in winsock2.h
+#   else // !defined(_WINSOCK2API_)
+#    error Please define the macro WIN32 in your compiler options
+#   endif // !defined(_WINSOCK2API_)
+#  endif // defined(_WIN32) && !defined(WIN32)
+# endif // defined(_MSC_VER)
+# if defined(__BORLANDC__)
+#  if defined(__WIN32__) && !defined(WIN32)
+#   if !defined(_WINSOCK2API_)
+#    define WIN32 // Needed for correct types in winsock2.h
+#   else // !defined(_WINSOCK2API_)
+#    error Please define the macro WIN32 in your compiler options
+#   endif // !defined(_WINSOCK2API_)
+#  endif // defined(__WIN32__) && !defined(WIN32)
+# endif // defined(__BORLANDC__)
+# if defined(__CYGWIN__)
+#  if !defined(__USE_W32_SOCKETS)
+#   error You must add -D__USE_W32_SOCKETS to your compiler options.
+#  endif // !defined(__USE_W32_SOCKETS)
+# endif // defined(__CYGWIN__)
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+// Windows: minimise header inclusion.
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# if !defined(STDNET_NO_WIN32_LEAN_AND_MEAN)
+#  if !defined(WIN32_LEAN_AND_MEAN)
+#   define WIN32_LEAN_AND_MEAN
+#  endif // !defined(WIN32_LEAN_AND_MEAN)
+# endif // !defined(STDNET_NO_WIN32_LEAN_AND_MEAN)
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+// Windows: suppress definition of "min" and "max" macros.
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# if !defined(STDNET_NO_NOMINMAX)
+#  if !defined(NOMINMAX)
+#   define NOMINMAX 1
+#  endif // !defined(NOMINMAX)
+# endif // !defined(STDNET_NO_NOMINMAX)
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+// Windows: No ANSI API calls.
+#if !defined(STDNET_NO_ANSI_APIS)
+# if defined(STDNET_WINDOWS) && defined(UNDER_CE)
+#  define STDNET_NO_ANSI_APIS 1
+# endif // defined(STDNET_WINDOWS) && defined(UNDER_CE)
+#endif // !defined(STDNET_NO_ANSI_APIS)
+
+// Windows: IO Completion Ports.
+#if !defined(STDNET_HAS_IOCP)
+# if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+#  if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0400)
+#   if !defined(UNDER_CE)
+#    if !defined(STDNET_DISABLE_IOCP)
+#     define STDNET_HAS_IOCP 1
+#    endif // !defined(STDNET_DISABLE_IOCP)
+#   endif // !defined(UNDER_CE)
+#  endif // defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0400)
+# endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+#endif // !defined(STDNET_HAS_IOCP)
+
+// Linux: epoll, eventfd and timerfd.
+#if defined(__linux__)
+# include <linux/version.h>
+# if !defined(STDNET_HAS_EPOLL)
+#  if !defined(STDNET_DISABLE_EPOLL)
+#   if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,45)
+#    define STDNET_HAS_EPOLL 1
+#   endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,45)
+#  endif // !defined(STDNET_DISABLE_EPOLL)
+# endif // !defined(STDNET_HAS_EPOLL)
+# if !defined(STDNET_HAS_EVENTFD)
+#  if !defined(STDNET_DISABLE_EVENTFD)
+#   if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#    define STDNET_HAS_EVENTFD 1
+#   endif // LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#  endif // !defined(STDNET_DISABLE_EVENTFD)
+# endif // !defined(STDNET_HAS_EVENTFD)
+# if !defined(STDNET_HAS_TIMERFD)
+#  if defined(STDNET_HAS_EPOLL)
+#   if (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 8)
+#    define STDNET_HAS_TIMERFD 1
+#   endif // (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 8)
+#  endif // defined(STDNET_HAS_EPOLL)
+# endif // !defined(STDNET_HAS_TIMERFD)
+#endif // defined(__linux__)
+
+// Mac OS X, FreeBSD, NetBSD, OpenBSD: kqueue.
+#if (defined(__MACH__) && defined(__APPLE__)) \
+  || defined(__FreeBSD__) \
+  || defined(__NetBSD__) \
+  || defined(__OpenBSD__)
+# if !defined(STDNET_HAS_KQUEUE)
+#  if !defined(STDNET_DISABLE_KQUEUE)
+#   define STDNET_HAS_KQUEUE 1
+#  endif // !defined(STDNET_DISABLE_KQUEUE)
+# endif // !defined(STDNET_HAS_KQUEUE)
+#endif // (defined(__MACH__) && defined(__APPLE__))
+       //   || defined(__FreeBSD__)
+       //   || defined(__NetBSD__)
+       //   || defined(__OpenBSD__)
+
+// Solaris: /dev/poll.
+#if defined(__sun)
+# if !defined(STDNET_HAS_DEV_POLL)
+#  if !defined(STDNET_DISABLE_DEV_POLL)
+#   define STDNET_HAS_DEV_POLL 1
+#  endif // !defined(STDNET_DISABLE_DEV_POLL)
+# endif // !defined(STDNET_HAS_DEV_POLL)
+#endif // defined(__sun)
+
+// Serial ports.
+#if !defined(STDNET_HAS_SERIAL_PORT)
+# if defined(STDNET_HAS_IOCP) \
+    || !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#  if !defined(__SYMBIAN32__)
+#   if !defined(STDNET_DISABLE_SERIAL_PORT)
+#    define STDNET_HAS_SERIAL_PORT 1
+#   endif // !defined(STDNET_DISABLE_SERIAL_PORT)
+#  endif // !defined(__SYMBIAN32__)
+# endif // defined(STDNET_HAS_IOCP)
+        //   || !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#endif // !defined(STDNET_HAS_SERIAL_PORT)
+
+// Windows: stream handles.
+#if !defined(STDNET_HAS_WINDOWS_STREAM_HANDLE)
+# if !defined(STDNET_DISABLE_WINDOWS_STREAM_HANDLE)
+#  if defined(STDNET_HAS_IOCP)
+#   define STDNET_HAS_WINDOWS_STREAM_HANDLE 1
+#  endif // defined(STDNET_HAS_IOCP)
+# endif // !defined(STDNET_DISABLE_WINDOWS_STREAM_HANDLE)
+#endif // !defined(STDNET_HAS_WINDOWS_STREAM_HANDLE)
+
+// Windows: random access handles.
+#if !defined(STDNET_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
+# if !defined(STDNET_DISABLE_WINDOWS_RANDOM_ACCESS_HANDLE)
+#  if defined(STDNET_HAS_IOCP)
+#   define STDNET_HAS_WINDOWS_RANDOM_ACCESS_HANDLE 1
+#  endif // defined(STDNET_HAS_IOCP)
+# endif // !defined(STDNET_DISABLE_WINDOWS_RANDOM_ACCESS_HANDLE)
+#endif // !defined(STDNET_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
+
+// Windows: object handles.
+#if !defined(STDNET_HAS_WINDOWS_OBJECT_HANDLE)
+# if !defined(STDNET_DISABLE_WINDOWS_OBJECT_HANDLE)
+#  if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+#   if !defined(UNDER_CE)
+#    define STDNET_HAS_WINDOWS_OBJECT_HANDLE 1
+#   endif // !defined(UNDER_CE)
+#  endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# endif // !defined(STDNET_DISABLE_WINDOWS_OBJECT_HANDLE)
+#endif // !defined(STDNET_HAS_WINDOWS_OBJECT_HANDLE)
+
+// Windows: OVERLAPPED wrapper.
+#if !defined(STDNET_HAS_WINDOWS_OVERLAPPED_PTR)
+# if !defined(STDNET_DISABLE_WINDOWS_OVERLAPPED_PTR)
+#  if defined(STDNET_HAS_IOCP)
+#   define STDNET_HAS_WINDOWS_OVERLAPPED_PTR 1
+#  endif // defined(STDNET_HAS_IOCP)
+# endif // !defined(STDNET_DISABLE_WINDOWS_OVERLAPPED_PTR)
+#endif // !defined(STDNET_HAS_WINDOWS_OVERLAPPED_PTR)
+
+// POSIX: stream-oriented file descriptors.
+#if !defined(STDNET_HAS_POSIX_STREAM_DESCRIPTOR)
+# if !defined(STDNET_DISABLE_POSIX_STREAM_DESCRIPTOR)
+#  if !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#   define STDNET_HAS_POSIX_STREAM_DESCRIPTOR 1
+#  endif // !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+# endif // !defined(STDNET_DISABLE_POSIX_STREAM_DESCRIPTOR)
+#endif // !defined(STDNET_HAS_POSIX_STREAM_DESCRIPTOR)
+
+// UNIX domain sockets.
+#if !defined(STDNET_HAS_LOCAL_SOCKETS)
+# if !defined(STDNET_DISABLE_LOCAL_SOCKETS)
+#  if !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#   define STDNET_HAS_LOCAL_SOCKETS 1
+#  endif // !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+# endif // !defined(STDNET_DISABLE_LOCAL_SOCKETS)
+#endif // !defined(STDNET_HAS_LOCAL_SOCKETS)
+
+// Can use sigaction() instead of signal().
+#if !defined(STDNET_HAS_SIGACTION)
+# if !defined(STDNET_DISABLE_SIGACTION)
+#  if !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+#   define STDNET_HAS_SIGACTION 1
+#  endif // !defined(STDNET_WINDOWS) && !defined(__CYGWIN__)
+# endif // !defined(STDNET_DISABLE_SIGACTION)
+#endif // !defined(STDNET_HAS_SIGACTION)
+
+// Can use signal().
+#if !defined(STDNET_HAS_SIGNAL)
+# if !defined(STDNET_DISABLE_SIGNAL)
+#  if !defined(UNDER_CE)
+#   define STDNET_HAS_SIGNAL 1
+#  endif // !defined(UNDER_CE)
+# endif // !defined(STDNET_DISABLE_SIGNAL)
+#endif // !defined(STDNET_HAS_SIGNAL)
+
+// Whether standard iostreams are disabled.
+//#if !defined(STDNET_NO_IOSTREAM)
+//# define STDNET_NO_IOSTREAM 1
+//#endif // !defined(STDNET_NO_IOSTREAM)
+
+// Whether exception handling is disabled.
+//#if !defined(STDNET_NO_EXCEPTIONS)
+//# define STDNET_NO_EXCEPTIONS 1
+//#endif // !defined(STDNET_NO_EXCEPTIONS)
+
+// Whether the typeid operator is supported.
+//#if !defined(STDNET_NO_TYPEID)
+//# define STDNET_NO_TYPEID 1
+//#endif // !defined(STDNET_NO_TYPEID)
+
+// On POSIX (and POSIX-like) platforms we need to include unistd.h in order to
+// get access to the various platform feature macros, e.g. to be able to test
+// for threads support.
+#if !defined(STDNET_HAS_UNISTD_H)
+# if defined(unix) \
+  || defined(__unix) \
+  || defined(_XOPEN_SOURCE) \
+  || defined(_POSIX_SOURCE) \
+  || (defined(__MACH__) && defined(__APPLE__)) \
+  || defined(__FreeBSD__) \
+  || defined(__NetBSD__) \
+  || defined(__OpenBSD__) \
+  || defined(__linux__)
+#  define STDNET_HAS_UNISTD_H 1
+# endif
+#endif // !defined(STDNET_HAS_UNISTD_H)
+#if defined(STDNET_HAS_UNISTD_H)
+# include <unistd.h>
+#endif // defined(STDNET_HAS_UNISTD_H)
+
+// Threads.
+#if !defined(STDNET_HAS_THREADS)
+# if !defined(STDNET_DISABLE_THREADS)
+#  if defined(_MSC_VER) && defined(_MT)
+#   define STDNET_HAS_THREADS 1
+#  elif defined(__BORLANDC__) && defined(__MT__)
+#   define STDNET_HAS_THREADS 1
+#  elif defined(_POSIX_THREADS)
+#   define STDNET_HAS_THREADS 1
+#  endif // defined(_MSC_VER) && defined(_MT)
+# endif // !defined(STDNET_DISABLE_THREADS)
+#endif // !defined(STDNET_HAS_THREADS)
+
+// POSIX threads.
+#if !defined(STDNET_HAS_PTHREADS)
+# if defined(STDNET_HAS_THREADS)
+#  if defined(_POSIX_THREADS)
+#   define STDNET_HAS_PTHREADS 1
+#  endif // defined(_POSIX_THREADS)
+# endif // defined(STDNET_HAS_THREADS)
+#endif // !defined(STDNET_HAS_PTHREADS)
+
+// Helper to prevent macro expansion.
+#define STDNET_PREVENT_MACRO_SUBSTITUTION
+
+// Helper to define in-class constants.
+#if !defined(STDNET_STATIC_CONSTANT)
+# define STDNET_STATIC_CONSTANT(type, assignment) \
+   static const type assignment
+#endif // !defined(STDNET_STATIC_CONSTANT)
+
+// Microsoft Visual C++'s secure C runtime library.
+#if !defined(STDNET_HAS_SECURE_RTL)
+# if !defined(STDNET_DISABLE_SECURE_RTL)
+#  if defined(STDNET_MSVC) \
+    && (STDNET_MSVC >= 1400) \
+    && !defined(UNDER_CE)
+#   define STDNET_HAS_SECURE_RTL 1
+#  endif // defined(STDNET_MSVC)
+         // && (STDNET_MSVC >= 1400)
+         // && !defined(UNDER_CE)
+# endif // !defined(STDNET_DISABLE_SECURE_RTL)
+#endif // !defined(STDNET_HAS_SECURE_RTL)
+
+// Handler hooking. Disabled for ancient Borland C++ and gcc compilers.
+#if !defined(STDNET_HAS_HANDLER_HOOKS)
+# if !defined(STDNET_DISABLE_HANDLER_HOOKS)
+#  if defined(__GNUC__)
+#   if (__GNUC__ >= 3)
+#    define STDNET_HAS_HANDLER_HOOKS 1
+#   endif // (__GNUC__ >= 3)
+#  elif !defined(__BORLANDC__)
+#   define STDNET_HAS_HANDLER_HOOKS 1
+#  endif // !defined(__BORLANDC__)
+# endif // !defined(STDNET_DISABLE_HANDLER_HOOKS)
+#endif // !defined(STDNET_HAS_HANDLER_HOOKS)
+
+// Support for the __thread keyword extension.
+#if !defined(STDNET_DISABLE_THREAD_KEYWORD_EXTENSION)
+# if defined(__linux__)
+#  if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+#   if ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3)
+#    if !defined(__INTEL_COMPILER) && !defined(__ICL)
+#     define STDNET_HAS_THREAD_KEYWORD_EXTENSION 1
+#    elif defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1100)
+#     define STDNET_HAS_THREAD_KEYWORD_EXTENSION 1
+#    endif // defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1100)
+#   endif // ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3)
+#  endif // defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+# endif // defined(__linux__)
+#endif // !defined(STDNET_DISABLE_THREAD_KEYWORD_EXTENSION)
+
+// Support for POSIX ssize_t typedef.
+#if !defined(STDNET_DISABLE_SSIZE_T)
+# if defined(__linux__) \
+   || (defined(__MACH__) && defined(__APPLE__))
+#  define STDNET_HAS_SSIZE_T 1
+# endif // defined(__linux__)
+        //   || (defined(__MACH__) && defined(__APPLE__))
+#endif // !defined(STDNET_DISABLE_SSIZE_T)
+
+#endif // STDNET_DETAIL_CONFIG_HPP
diff --git a/ip-address/include/std/net/detail/impl/socket_ops.ipp b/ip-address/include/std/net/detail/impl/socket_ops.ipp
new file mode 100644
index 0000000..13b32a3
--- /dev/null
+++ b/ip-address/include/std/net/detail/impl/socket_ops.ipp
@@ -0,0 +1,260 @@
+//
+// detail/impl/socket_ops.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_SOCKET_OPS_IPP
+#define STDNET_DETAIL_SOCKET_OPS_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <cctype>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <cerrno>
+#include <new>
+#include "std/net/detail/socket_ops.hpp"
+#include "std/net/detail/system_errors.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace socket_ops {
+
+#if defined(__hpux)
+// HP-UX doesn't declare these functions extern "C", so they are declared again
+// here to avoid linker errors about undefined symbols.
+extern "C" char* if_indextoname(unsigned int, char*);
+extern "C" unsigned int if_nametoindex(const char*);
+#endif // defined(__hpux)
+
+inline void clear_last_error()
+{
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  WSASetLastError(0);
+#else
+  errno = 0;
+#endif
+}
+
+template <typename ReturnType>
+inline ReturnType error_wrapper(ReturnType return_value,
+    std::error_code& ec)
+{
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  ec = std::error_code(WSAGetLastError(),
+      std::experimental::net::detail::syserrc::system_category());
+#else
+  ec = std::error_code(errno,
+      std::experimental::net::detail::syserrc::system_category());
+#endif
+  return return_value;
+}
+
+const char* inet_ntop(int af, const void* src, char* dest, size_t length,
+    unsigned long scope_id, std::error_code& ec)
+{
+  clear_last_error();
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  using namespace std; // For memcpy.
+
+  if (af != AF_INET && af != AF_INET6)
+  {
+    ec = std::experimental::net::detail::syserrc::address_family_not_supported;
+    return 0;
+  }
+
+  union
+  {
+    socket_addr_type base;
+    sockaddr_storage_type storage;
+    sockaddr_in4_type v4;
+    sockaddr_in6_type v6;
+  } address;
+  DWORD address_length;
+  if (af == AF_INET)
+  {
+    address_length = sizeof(sockaddr_in4_type);
+    address.v4.sin_family = AF_INET;
+    address.v4.sin_port = 0;
+    memcpy(&address.v4.sin_addr, src, sizeof(in4_addr_type));
+  }
+  else // AF_INET6
+  {
+    address_length = sizeof(sockaddr_in6_type);
+    address.v6.sin6_family = AF_INET6;
+    address.v6.sin6_port = 0;
+    address.v6.sin6_flowinfo = 0;
+    address.v6.sin6_scope_id = scope_id;
+    memcpy(&address.v6.sin6_addr, src, sizeof(in6_addr_type));
+  }
+
+  DWORD string_length = static_cast<DWORD>(length);
+#if defined(STDNET_NO_ANSI_APIS)
+  LPWSTR string_buffer = (LPWSTR)_alloca(length * sizeof(WCHAR));
+  int result = error_wrapper(::WSAAddressToStringW(&address.base,
+        address_length, 0, string_buffer, &string_length), ec);
+  ::WideCharToMultiByte(CP_ACP, 0, string_buffer, -1, dest, length, 0, 0);
+#else
+  int result = error_wrapper(::WSAAddressToStringA(
+        &address.base, address_length, 0, dest, &string_length), ec);
+#endif
+
+  // Windows may set error code on success.
+  if (result != socket_error_retval)
+    ec = std::error_code();
+
+  // Windows may not set an error code on failure.
+  else if (result == socket_error_retval && !ec)
+    ec = std::experimental::net::detail::syserrc::invalid_argument;
+
+  return result == socket_error_retval ? 0 : dest;
+#else // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  const char* result = error_wrapper(::inet_ntop(
+        af, src, dest, static_cast<int>(length)), ec);
+  if (result == 0 && !ec)
+    ec = std::experimental::net::detail::syserrc::invalid_argument;
+  if (result != 0 && af == AF_INET6 && scope_id != 0)
+  {
+    using namespace std; // For strcat and sprintf.
+    char if_name[IF_NAMESIZE + 1] = "%";
+    const in6_addr_type* ipv6_address = static_cast<const in6_addr_type*>(src);
+    bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
+        && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
+    if (!is_link_local
+        || if_indextoname(static_cast<unsigned>(scope_id), if_name + 1) == 0)
+      sprintf(if_name + 1, "%lu", scope_id);
+    strcat(dest, if_name);
+  }
+  return result;
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+}
+
+int inet_pton(int af, const char* src, void* dest,
+    unsigned long* scope_id, std::error_code& ec)
+{
+  clear_last_error();
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  using namespace std; // For memcpy and strcmp.
+
+  if (af != AF_INET && af != AF_INET6)
+  {
+    ec = std::experimental::net::detail::syserrc::address_family_not_supported;
+    return -1;
+  }
+
+  union
+  {
+    socket_addr_type base;
+    sockaddr_storage_type storage;
+    sockaddr_in4_type v4;
+    sockaddr_in6_type v6;
+  } address;
+  int address_length = sizeof(sockaddr_storage_type);
+#if defined(STDNET_NO_ANSI_APIS)
+  int num_wide_chars = strlen(src) + 1;
+  LPWSTR wide_buffer = (LPWSTR)_alloca(num_wide_chars * sizeof(WCHAR));
+  ::MultiByteToWideChar(CP_ACP, 0, src, -1, wide_buffer, num_wide_chars);
+  int result = error_wrapper(::WSAStringToAddressW(
+        wide_buffer, af, 0, &address.base, &address_length), ec);
+#else
+  int result = error_wrapper(::WSAStringToAddressA(
+        const_cast<char*>(src), af, 0, &address.base, &address_length), ec);
+#endif
+
+  if (af == AF_INET)
+  {
+    if (result != socket_error_retval)
+    {
+      memcpy(dest, &address.v4.sin_addr, sizeof(in4_addr_type));
+      ec = std::error_code();
+    }
+    else if (strcmp(src, "255.255.255.255") == 0)
+    {
+      static_cast<in4_addr_type*>(dest)->s_addr = INADDR_NONE;
+      ec = std::error_code();
+    }
+  }
+  else // AF_INET6
+  {
+    if (result != socket_error_retval)
+    {
+      memcpy(dest, &address.v6.sin6_addr, sizeof(in6_addr_type));
+      if (scope_id)
+        *scope_id = address.v6.sin6_scope_id;
+      ec = std::error_code();
+    }
+  }
+
+  // Windows may not set an error code on failure.
+  if (result == socket_error_retval && !ec)
+    ec = std::experimental::net::detail::syserrc::invalid_argument;
+
+  if (result != socket_error_retval)
+    ec = std::error_code();
+
+  return result == socket_error_retval ? -1 : 1;
+#else // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+  int result = error_wrapper(::inet_pton(af, src, dest), ec);
+  if (result <= 0 && !ec)
+    ec = std::experimental::net::detail::syserrc::invalid_argument;
+  if (result > 0 && af == AF_INET6 && scope_id)
+  {
+    using namespace std; // For strchr and atoi.
+    *scope_id = 0;
+    if (const char* if_name = strchr(src, '%'))
+    {
+      in6_addr_type* ipv6_address = static_cast<in6_addr_type*>(dest);
+      bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
+          && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
+      if (is_link_local)
+        *scope_id = if_nametoindex(if_name + 1);
+      if (*scope_id == 0)
+        *scope_id = atoi(if_name + 1);
+    }
+  }
+  return result;
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+}
+
+u_long_type network_to_host_long(u_long_type value)
+{
+  return ntohl(value);
+}
+
+u_long_type host_to_network_long(u_long_type value)
+{
+  return htonl(value);
+}
+
+u_short_type network_to_host_short(u_short_type value)
+{
+  return ntohs(value);
+}
+
+u_short_type host_to_network_short(u_short_type value)
+{
+  return htons(value);
+}
+
+} // namespace socket_ops
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_DETAIL_SOCKET_OPS_IPP
diff --git a/ip-address/include/std/net/detail/impl/system_errors.ipp b/ip-address/include/std/net/detail/impl/system_errors.ipp
new file mode 100644
index 0000000..8b01e08
--- /dev/null
+++ b/ip-address/include/std/net/detail/impl/system_errors.ipp
@@ -0,0 +1,94 @@
+//
+// impl/system_errors.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_IMPL_SYSTEM_ERRORS_IPP
+#define STDNET_DETAIL_IMPL_SYSTEM_ERRORS_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include "std/net/detail/local_free_on_block_exit.hpp"
+#include "std/net/detail/system_errors.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace syserrc {
+
+class system_category : public std::error_category
+{
+public:
+  const char* name() const STDNET_ERROR_CATEGORY_NOEXCEPT
+  {
+    return "std.net.system";
+  }
+
+  std::string message(int value) const
+  {
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+    char* msg = 0;
+    DWORD length = ::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER
+        | FORMAT_MESSAGE_FROM_SYSTEM
+        | FORMAT_MESSAGE_IGNORE_INSERTS, 0, value,
+        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char*)&msg, 0, 0);
+    detail::local_free_on_block_exit local_free_obj(msg);
+    if (length && msg[length - 1] == '\n')
+      msg[--length] = '\0';
+    if (length && msg[length - 1] == '\r')
+      msg[--length] = '\0';
+    if (length)
+      return msg;
+    else
+      return "std.net.system error";
+#else // defined(STDNET_WINDOWS)
+#if !defined(__sun)
+    if (value == ECANCELED)
+      return "Operation aborted.";
+#endif // !defined(__sun)
+#if defined(__sun) || defined(__QNX__) || defined(__SYMBIAN32__)
+    using namespace std;
+    return strerror(value);
+#elif defined(__MACH__) && defined(__APPLE__) \
+  || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__) \
+  || defined(_AIX) || defined(__hpux) || defined(__osf__) \
+  || defined(__ANDROID__)
+    char buf[256] = "";
+    using namespace std;
+    strerror_r(value, buf, sizeof(buf));
+    return buf;
+#else
+    char buf[256] = "";
+    return strerror_r(value, buf, sizeof(buf));
+#endif
+#endif // defined(STDNET_WINDOWS)
+  }
+};
+
+} // namespace syserrc
+
+const std::error_category& system_category()
+{
+  static syserrc::system_category instance;
+  return instance;
+}
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_DETAIL_IMPL_SYSTEM_ERRORS_IPP
diff --git a/ip-address/include/std/net/detail/impl/throw_error.ipp b/ip-address/include/std/net/detail/impl/throw_error.ipp
new file mode 100644
index 0000000..92baf1c
--- /dev/null
+++ b/ip-address/include/std/net/detail/impl/throw_error.ipp
@@ -0,0 +1,49 @@
+//
+// detail/impl/throw_error.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_IMPL_THROW_ERROR_IPP
+#define STDNET_DETAIL_IMPL_THROW_ERROR_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <system_error>
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/detail/throw_exception.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+void do_throw_error(const std::error_code& err)
+{
+  std::system_error e(err);
+  std::experimental::net::detail::throw_exception(e);
+}
+
+void do_throw_error(const std::error_code& err, const char* location)
+{
+  std::system_error e(err, location);
+  std::experimental::net::detail::throw_exception(e);
+}
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_DETAIL_IMPL_THROW_ERROR_IPP
diff --git a/ip-address/include/std/net/detail/impl/winsock_init.ipp b/ip-address/include/std/net/detail/impl/winsock_init.ipp
new file mode 100644
index 0000000..7114f6a
--- /dev/null
+++ b/ip-address/include/std/net/detail/impl/winsock_init.ipp
@@ -0,0 +1,73 @@
+//
+// detail/impl/winsock_init.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_IMPL_WINSOCK_INIT_IPP
+#define STDNET_DETAIL_IMPL_WINSOCK_INIT_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#include "std/net/detail/socket_types.hpp"
+#include "std/net/detail/system_errors.hpp"
+#include "std/net/detail/winsock_init.hpp"
+#include "std/net/detail/throw_error.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+void winsock_init_base::startup(data& d,
+    unsigned char major, unsigned char minor)
+{
+  if (::InterlockedIncrement(&d.init_count_) == 1)
+  {
+    WSADATA wsa_data;
+    long result = ::WSAStartup(MAKEWORD(major, minor), &wsa_data);
+    ::InterlockedExchange(&d.result_, result);
+  }
+}
+
+void winsock_init_base::cleanup(data& d)
+{
+  if (::InterlockedDecrement(&d.init_count_) == 0)
+  {
+    ::WSACleanup();
+  }
+}
+
+void winsock_init_base::throw_on_error(data& d)
+{
+  long result = ::InterlockedExchangeAdd(&d.result_, 0);
+  if (result != 0)
+  {
+    std::error_code ec(result,
+        std::experimental::net::detail::system_category());
+    std::experimental::net::detail::throw_error(ec, "winsock");
+  }
+}
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#endif // STDNET_DETAIL_IMPL_WINSOCK_INIT_IPP
diff --git a/ip-address/include/std/net/detail/local_free_on_block_exit.hpp b/ip-address/include/std/net/detail/local_free_on_block_exit.hpp
new file mode 100644
index 0000000..64c9137
--- /dev/null
+++ b/ip-address/include/std/net/detail/local_free_on_block_exit.hpp
@@ -0,0 +1,63 @@
+//
+// detail/local_free_on_block_exit.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
+#define STDNET_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#include "std/net/detail/socket_types.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+class local_free_on_block_exit
+{
+public:
+  // Constructor blocks all signals for the calling thread.
+  explicit local_free_on_block_exit(void* p)
+    : p_(p)
+  {
+  }
+
+  // Destructor restores the previous signal mask.
+  ~local_free_on_block_exit()
+  {
+    ::LocalFree(p_);
+  }
+
+private:
+  // Disallow copying and assignemnt.
+  local_free_on_block_exit(const local_free_on_block_exit&);
+  local_free_on_block_exit& operator=(const local_free_on_block_exit&);
+
+  void* p_;
+};
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#endif // STDNET_DETAIL_LOCAL_FREE_ON_BLOCK_EXIT_HPP
diff --git a/ip-address/include/std/net/detail/old_win_sdk_compat.hpp b/ip-address/include/std/net/detail/old_win_sdk_compat.hpp
new file mode 100644
index 0000000..3a3cdac
--- /dev/null
+++ b/ip-address/include/std/net/detail/old_win_sdk_compat.hpp
@@ -0,0 +1,218 @@
+//
+// detail/old_win_sdk_compat.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_OLD_WIN_SDK_COMPAT_HPP
+#define STDNET_DETAIL_OLD_WIN_SDK_COMPAT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+// Guess whether we are building against on old Platform SDK.
+#if !defined(IN6ADDR_ANY_INIT)
+#define STDNET_HAS_OLD_WIN_SDK 1
+#endif // !defined(IN6ADDR_ANY_INIT)
+
+#if defined(STDNET_HAS_OLD_WIN_SDK)
+
+// Emulation of types that are missing from old Platform SDKs.
+//
+// N.B. this emulation is also used if building for a Windows 2000 target with
+// a recent (i.e. Vista or later) SDK, as the SDK does not provide IPv6 support
+// in that case.
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+enum
+{
+  sockaddr_storage_maxsize = 128, // Maximum size.
+  sockaddr_storage_alignsize = (sizeof(__int64)), // Desired alignment.
+  sockaddr_storage_pad1size = (sockaddr_storage_alignsize - sizeof(short)),
+  sockaddr_storage_pad2size = (sockaddr_storage_maxsize -
+      (sizeof(short) + sockaddr_storage_pad1size + sockaddr_storage_alignsize))
+};
+
+struct sockaddr_storage_emulation
+{
+  short ss_family;
+  char __ss_pad1[sockaddr_storage_pad1size];
+  __int64 __ss_align;
+  char __ss_pad2[sockaddr_storage_pad2size];
+};
+
+struct in6_addr_emulation
+{
+  union
+  {
+    u_char Byte[16];
+    u_short Word[8];
+  } u;
+};
+
+#if !defined(s6_addr)
+# define _S6_un u
+# define _S6_u8 Byte
+# define s6_addr _S6_un._S6_u8
+#endif // !defined(s6_addr)
+
+struct sockaddr_in6_emulation
+{
+  short sin6_family;
+  u_short sin6_port;
+  u_long sin6_flowinfo;
+  in6_addr_emulation sin6_addr;
+  u_long sin6_scope_id;
+};
+
+struct ipv6_mreq_emulation
+{
+  in6_addr_emulation ipv6mr_multiaddr;
+  unsigned int ipv6mr_interface;
+};
+
+struct addrinfo_emulation
+{
+  int ai_flags;
+  int ai_family;
+  int ai_socktype;
+  int ai_protocol;
+  size_t ai_addrlen;
+  char* ai_canonname;
+  sockaddr* ai_addr;
+  addrinfo_emulation* ai_next;
+};
+
+#if !defined(AI_PASSIVE)
+# define AI_PASSIVE 0x1
+#endif
+
+#if !defined(AI_CANONNAME)
+# define AI_CANONNAME 0x2
+#endif
+
+#if !defined(AI_NUMERICHOST)
+# define AI_NUMERICHOST 0x4
+#endif
+
+#if !defined(EAI_AGAIN)
+# define EAI_AGAIN WSATRY_AGAIN
+#endif
+
+#if !defined(EAI_BADFLAGS)
+# define EAI_BADFLAGS WSAEINVAL
+#endif
+
+#if !defined(EAI_FAIL)
+# define EAI_FAIL WSANO_RECOVERY
+#endif
+
+#if !defined(EAI_FAMILY)
+# define EAI_FAMILY WSAEAFNOSUPPORT
+#endif
+
+#if !defined(EAI_MEMORY)
+# define EAI_MEMORY WSA_NOT_ENOUGH_MEMORY
+#endif
+
+#if !defined(EAI_NODATA)
+# define EAI_NODATA WSANO_DATA
+#endif
+
+#if !defined(EAI_NONAME)
+# define EAI_NONAME WSAHOST_NOT_FOUND
+#endif
+
+#if !defined(EAI_SERVICE)
+# define EAI_SERVICE WSATYPE_NOT_FOUND
+#endif
+
+#if !defined(EAI_SOCKTYPE)
+# define EAI_SOCKTYPE WSAESOCKTNOSUPPORT
+#endif
+
+#if !defined(NI_NOFQDN)
+# define NI_NOFQDN 0x01
+#endif
+
+#if !defined(NI_NUMERICHOST)
+# define NI_NUMERICHOST 0x02
+#endif
+
+#if !defined(NI_NAMEREQD)
+# define NI_NAMEREQD 0x04
+#endif
+
+#if !defined(NI_NUMERICSERV)
+# define NI_NUMERICSERV 0x08
+#endif
+
+#if !defined(NI_DGRAM)
+# define NI_DGRAM 0x10
+#endif
+
+#if !defined(IPPROTO_IPV6)
+# define IPPROTO_IPV6 41
+#endif
+
+#if !defined(IPV6_UNICAST_HOPS)
+# define IPV6_UNICAST_HOPS 4
+#endif
+
+#if !defined(IPV6_MULTICAST_IF)
+# define IPV6_MULTICAST_IF 9
+#endif
+
+#if !defined(IPV6_MULTICAST_HOPS)
+# define IPV6_MULTICAST_HOPS 10
+#endif
+
+#if !defined(IPV6_MULTICAST_LOOP)
+# define IPV6_MULTICAST_LOOP 11
+#endif
+
+#if !defined(IPV6_JOIN_GROUP)
+# define IPV6_JOIN_GROUP 12
+#endif
+
+#if !defined(IPV6_LEAVE_GROUP)
+# define IPV6_LEAVE_GROUP 13
+#endif
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // defined(STDNET_HAS_OLD_WIN_SDK)
+
+// Even newer Platform SDKs that support IPv6 may not define IPV6_V6ONLY.
+#if !defined(IPV6_V6ONLY)
+# define IPV6_V6ONLY 27
+#endif
+
+// Some SDKs (e.g. Windows CE) don't define IPPROTO_ICMPV6.
+#if !defined(IPPROTO_ICMPV6)
+# define IPPROTO_ICMPV6 58
+#endif
+
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#endif // STDNET_DETAIL_OLD_WIN_SDK_COMPAT_HPP
diff --git a/ip-address/include/std/net/detail/pop_options.hpp b/ip-address/include/std/net/detail/pop_options.hpp
new file mode 100644
index 0000000..8aa375e
--- /dev/null
+++ b/ip-address/include/std/net/detail/pop_options.hpp
@@ -0,0 +1,98 @@
+//
+// detail/pop_options.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// No header guard
+
+#if defined(__COMO__)
+
+// Comeau C++
+
+#elif defined(__DMC__)
+
+// Digital Mars C++
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) \
+  || defined(__ICC) || defined(__ECC)
+
+// Intel C++
+
+#elif defined(__GNUC__)
+
+// GNU C++
+
+# if defined(__MINGW32__) || defined(__CYGWIN__)
+#  pragma pack (pop)
+# endif
+
+# if defined(__OBJC__)
+#  if !defined(__APPLE_CC__) || (__APPLE_CC__ <= 1)
+#   if defined(STDNET_OBJC_WORKAROUND)
+#    undef Protocol
+#    undef id
+#    undef STDNET_OBJC_WORKAROUND
+#   endif
+#  endif
+# endif
+
+#elif defined(__KCC)
+
+// Kai C++
+
+#elif defined(__sgi)
+
+// SGI MIPSpro C++
+
+#elif defined(__DECCXX)
+
+// Compaq Tru64 Unix cxx
+
+#elif defined(__ghs)
+
+// Greenhills C++
+
+#elif defined(__BORLANDC__)
+
+// Borland C++
+
+# pragma option pop
+# pragma nopushoptwarn
+# pragma nopackwarning
+
+#elif defined(__MWERKS__)
+
+// Metrowerks CodeWarrior
+
+#elif defined(__SUNPRO_CC)
+
+// Sun Workshop Compiler C++
+
+#elif defined(__HP_aCC)
+
+// HP aCC
+
+#elif defined(__MRC__) || defined(__SC__)
+
+// MPW MrCpp or SCpp
+
+#elif defined(__IBMCPP__)
+
+// IBM Visual Age
+
+#elif defined(_MSC_VER)
+
+// Microsoft Visual C++
+//
+// Must remain the last #elif since some other vendors (Metrowerks, for example)
+// also #define _MSC_VER
+
+# pragma warning (pop)
+# pragma pack (pop)
+
+#endif
diff --git a/ip-address/include/std/net/detail/push_options.hpp b/ip-address/include/std/net/detail/push_options.hpp
new file mode 100644
index 0000000..ec64373
--- /dev/null
+++ b/ip-address/include/std/net/detail/push_options.hpp
@@ -0,0 +1,127 @@
+//
+// detail/push_options.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+// No header guard
+
+#if defined(__COMO__)
+
+// Comeau C++
+
+#elif defined(__DMC__)
+
+// Digital Mars C++
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) \
+  || defined(__ICC) || defined(__ECC)
+
+// Intel C++
+
+#elif defined(__GNUC__)
+
+// GNU C++
+
+# if defined(__MINGW32__) || defined(__CYGWIN__)
+#  pragma pack (push, 8)
+# endif
+
+# if defined(__OBJC__)
+#  if !defined(__APPLE_CC__) || (__APPLE_CC__ <= 1)
+#   if !defined(STDNET_DISABLE_OBJC_WORKAROUND)
+#    if !defined(Protocol) && !defined(id)
+#     define Protocol cpp_Protocol
+#     define id cpp_id
+#     define STDNET_OBJC_WORKAROUND
+#    endif
+#   endif
+#  endif
+# endif
+
+#elif defined(__KCC)
+
+// Kai C++
+
+#elif defined(__sgi)
+
+// SGI MIPSpro C++
+
+#elif defined(__DECCXX)
+
+// Compaq Tru64 Unix cxx
+
+#elif defined(__ghs)
+
+// Greenhills C++
+
+#elif defined(__BORLANDC__)
+
+// Borland C++
+
+# pragma option push -a8 -b -Ve- -Vx- -w-inl -vi-
+# pragma nopushoptwarn
+# pragma nopackwarning
+# if !defined(__MT__)
+#  error Multithreaded RTL must be selected.
+# endif // !defined(__MT__)
+
+#elif defined(__MWERKS__)
+
+// Metrowerks CodeWarrior
+
+#elif defined(__SUNPRO_CC)
+
+// Sun Workshop Compiler C++
+
+#elif defined(__HP_aCC)
+
+// HP aCC
+
+#elif defined(__MRC__) || defined(__SC__)
+
+// MPW MrCpp or SCpp
+
+#elif defined(__IBMCPP__)
+
+// IBM Visual Age
+
+#elif defined(_MSC_VER)
+
+// Microsoft Visual C++
+//
+// Must remain the last #elif since some other vendors (Metrowerks, for example)
+// also #define _MSC_VER
+
+# pragma warning (disable:4103)
+# pragma warning (push)
+# pragma warning (disable:4127)
+# pragma warning (disable:4180)
+# pragma warning (disable:4244)
+# pragma warning (disable:4355)
+# pragma warning (disable:4512)
+# pragma warning (disable:4675)
+# if defined(_M_IX86) && defined(_Wp64)
+// The /Wp64 option is broken. If you want to check 64 bit portability, use a
+// 64 bit compiler!
+#  pragma warning (disable:4311)
+#  pragma warning (disable:4312)
+# endif // defined(_M_IX86) && defined(_Wp64)
+# pragma pack (push, 8)
+// Note that if the /Og optimisation flag is enabled with MSVC6, the compiler
+// has a tendency to incorrectly optimise away some calls to member template
+// functions, even though those functions contain code that should not be
+// optimised away! Therefore we will always disable this optimisation option
+// for the MSVC6 compiler.
+# if (_MSC_VER < 1300)
+#  pragma optimize ("g", off)
+# endif
+# if !defined(_MT)
+#  error Multithreaded RTL must be selected.
+# endif // !defined(_MT)
+
+#endif
diff --git a/ip-address/include/std/net/detail/socket_ops.hpp b/ip-address/include/std/net/detail/socket_ops.hpp
new file mode 100644
index 0000000..02cb8a4
--- /dev/null
+++ b/ip-address/include/std/net/detail/socket_ops.hpp
@@ -0,0 +1,57 @@
+//
+// detail/socket_ops.hpp
+// ~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_SOCKET_OPS_HPP
+#define STDNET_DETAIL_SOCKET_OPS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#include <system_error>
+#include "std/net/detail/socket_types.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace socket_ops {
+
+STDNET_DECL const char* inet_ntop(int af, const void* src, char* dest,
+    size_t length, unsigned long scope_id, std::error_code& ec);
+
+STDNET_DECL int inet_pton(int af, const char* src, void* dest,
+    unsigned long* scope_id, std::error_code& ec);
+
+STDNET_DECL u_long_type network_to_host_long(u_long_type value);
+
+STDNET_DECL u_long_type host_to_network_long(u_long_type value);
+
+STDNET_DECL u_short_type network_to_host_short(u_short_type value);
+
+STDNET_DECL u_short_type host_to_network_short(u_short_type value);
+
+} // namespace socket_ops
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/detail/impl/socket_ops.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_DETAIL_SOCKET_OPS_HPP
diff --git a/ip-address/include/std/net/detail/socket_types.hpp b/ip-address/include/std/net/detail/socket_types.hpp
new file mode 100644
index 0000000..ee35521
--- /dev/null
+++ b/ip-address/include/std/net/detail/socket_types.hpp
@@ -0,0 +1,186 @@
+//
+// detail/socket_types.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_SOCKET_TYPES_HPP
+#define STDNET_DETAIL_SOCKET_TYPES_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# if defined(_WINSOCKAPI_) && !defined(_WINSOCK2API_)
+#  error WinSock.h has already been included
+# endif // defined(_WINSOCKAPI_) && !defined(_WINSOCK2API_)
+# if defined(__BORLANDC__)
+#  include <stdlib.h> // Needed for __errno
+#  if !defined(_WSPIAPI_H_)
+#   define _WSPIAPI_H_
+#   define STDNET_WSPIAPI_H_DEFINED
+#  endif // !defined(_WSPIAPI_H_)
+# endif // defined(__BORLANDC__)
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# if defined(STDNET_WSPIAPI_H_DEFINED)
+#  undef _WSPIAPI_H_
+#  undef STDNET_WSPIAPI_H_DEFINED
+# endif // defined(STDNET_WSPIAPI_H_DEFINED)
+# if !defined(STDNET_NO_DEFAULT_LINKED_LIBS)
+#  if defined(UNDER_CE)
+#   pragma comment(lib, "ws2.lib")
+#  elif defined(_MSC_VER) || defined(__BORLANDC__)
+#   pragma comment(lib, "ws2_32.lib")
+#   pragma comment(lib, "mswsock.lib")
+#  endif // defined(_MSC_VER) || defined(__BORLANDC__)
+# endif // !defined(STDNET_NO_DEFAULT_LINKED_LIBS)
+# include "std/net/detail/old_win_sdk_compat.hpp"
+#else
+# include <sys/ioctl.h>
+# if !defined(__SYMBIAN32__)
+#  include <sys/poll.h>
+# endif
+# include <sys/types.h>
+# include <sys/stat.h>
+# include <fcntl.h>
+# if defined(__hpux)
+#  include <sys/time.h>
+# endif
+# if !defined(__hpux) || defined(__SELECT)
+#  include <sys/select.h>
+# endif
+# include <sys/socket.h>
+# include <sys/uio.h>
+# include <sys/un.h>
+# include <netinet/in.h>
+# if !defined(__SYMBIAN32__)
+#  include <netinet/tcp.h>
+# endif
+# include <arpa/inet.h>
+# include <netdb.h>
+# include <net/if.h>
+# include <limits.h>
+# if defined(__sun)
+#  include <sys/filio.h>
+#  include <sys/sockio.h>
+# endif
+#endif
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+typedef SOCKET socket_type;
+const SOCKET invalid_socket = INVALID_SOCKET;
+const int socket_error_retval = SOCKET_ERROR;
+const int max_addr_v4_str_len = 256;
+const int max_addr_v6_str_len = 256;
+typedef sockaddr socket_addr_type;
+typedef in_addr in4_addr_type;
+typedef ip_mreq in4_mreq_type;
+typedef sockaddr_in sockaddr_in4_type;
+# if defined(STDNET_HAS_OLD_WIN_SDK)
+typedef in6_addr_emulation in6_addr_type;
+typedef ipv6_mreq_emulation in6_mreq_type;
+typedef sockaddr_in6_emulation sockaddr_in6_type;
+typedef sockaddr_storage_emulation sockaddr_storage_type;
+typedef addrinfo_emulation addrinfo_type;
+# else
+typedef in6_addr in6_addr_type;
+typedef ipv6_mreq in6_mreq_type;
+typedef sockaddr_in6 sockaddr_in6_type;
+typedef sockaddr_storage sockaddr_storage_type;
+typedef addrinfo addrinfo_type;
+# endif
+typedef unsigned long ioctl_arg_type;
+typedef u_long u_long_type;
+typedef u_short u_short_type;
+typedef int signed_size_type;
+const int shutdown_receive = SD_RECEIVE;
+const int shutdown_send = SD_SEND;
+const int shutdown_both = SD_BOTH;
+const int message_peek = MSG_PEEK;
+const int message_out_of_band = MSG_OOB;
+const int message_do_not_route = MSG_DONTROUTE;
+const int message_end_of_record = 0; // Not supported on Windows.
+# if defined (_WIN32_WINNT)
+const int max_iov_len = 64;
+# else
+const int max_iov_len = 16;
+# endif
+#else
+typedef int socket_type;
+const int invalid_socket = -1;
+const int socket_error_retval = -1;
+const int max_addr_v4_str_len = INET_ADDRSTRLEN;
+#if defined(INET6_ADDRSTRLEN)
+const int max_addr_v6_str_len = INET6_ADDRSTRLEN + 1 + IF_NAMESIZE;
+#else // defined(INET6_ADDRSTRLEN)
+const int max_addr_v6_str_len = 256;
+#endif // defined(INET6_ADDRSTRLEN)
+typedef sockaddr socket_addr_type;
+typedef in_addr in4_addr_type;
+# if defined(__hpux)
+// HP-UX doesn't provide ip_mreq when _XOPEN_SOURCE_EXTENDED is defined.
+struct in4_mreq_type
+{
+  struct in_addr imr_multiaddr;
+  struct in_addr imr_interface;
+};
+# else
+typedef ip_mreq in4_mreq_type;
+# endif
+typedef sockaddr_in sockaddr_in4_type;
+typedef in6_addr in6_addr_type;
+typedef ipv6_mreq in6_mreq_type;
+typedef sockaddr_in6 sockaddr_in6_type;
+typedef sockaddr_storage sockaddr_storage_type;
+typedef sockaddr_un sockaddr_un_type;
+typedef addrinfo addrinfo_type;
+typedef int ioctl_arg_type;
+typedef uint32_t u_long_type;
+typedef uint16_t u_short_type;
+#if defined(STDNET_HAS_SSIZE_T)
+typedef ssize_t signed_size_type;
+#else // defined(STDNET_HAS_SSIZE_T)
+typedef int signed_size_type;
+#endif // defined(STDNET_HAS_SSIZE_T)
+const int shutdown_receive = SHUT_RD;
+const int shutdown_send = SHUT_WR;
+const int shutdown_both = SHUT_RDWR;
+const int message_peek = MSG_PEEK;
+const int message_out_of_band = MSG_OOB;
+const int message_do_not_route = MSG_DONTROUTE;
+const int message_end_of_record = MSG_EOR;
+# if defined(IOV_MAX)
+const int max_iov_len = IOV_MAX;
+# else
+// POSIX platforms are not required to define IOV_MAX.
+const int max_iov_len = 16;
+# endif
+#endif
+const int custom_socket_option_level = 0xA5100000;
+const int enable_connection_aborted_option = 1;
+const int always_fail_option = 2;
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_DETAIL_SOCKET_TYPES_HPP
diff --git a/ip-address/include/std/net/detail/system_errors.hpp b/ip-address/include/std/net/detail/system_errors.hpp
new file mode 100644
index 0000000..4aa5c44
--- /dev/null
+++ b/ip-address/include/std/net/detail/system_errors.hpp
@@ -0,0 +1,221 @@
+//
+// system_errors.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_SYSTEM_ERRORS_HPP
+#define STDNET_DETAIL_SYSTEM_ERRORS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <system_error>
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# include <winerror.h>
+#else
+# include <cerrno>
+#endif
+
+#if defined(GENERATING_DOCUMENTATION)
+/// INTERNAL ONLY.
+# define STDNET_NATIVE_ERROR(e) implementation_defined
+/// INTERNAL ONLY.
+# define STDNET_SOCKET_ERROR(e) implementation_defined
+/// INTERNAL ONLY.
+# define STDNET_NETDB_ERROR(e) implementation_defined
+/// INTERNAL ONLY.
+# define STDNET_GETADDRINFO_ERROR(e) implementation_defined
+/// INTERNAL ONLY.
+# define STDNET_WIN_OR_POSIX(e_win, e_posix) implementation_defined
+#elif defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+# define STDNET_NATIVE_ERROR(e) e
+# define STDNET_SOCKET_ERROR(e) WSA ## e
+# define STDNET_NETDB_ERROR(e) WSA ## e
+# define STDNET_GETADDRINFO_ERROR(e) WSA ## e
+# define STDNET_WIN_OR_POSIX(e_win, e_posix) e_win
+#else
+# define STDNET_NATIVE_ERROR(e) e
+# define STDNET_SOCKET_ERROR(e) e
+# define STDNET_NETDB_ERROR(e) e
+# define STDNET_GETADDRINFO_ERROR(e) e
+# define STDNET_WIN_OR_POSIX(e_win, e_posix) e_posix
+#endif
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace syserrc {
+
+enum system_errors
+{
+  /// Permission denied.
+  access_denied = STDNET_SOCKET_ERROR(EACCES),
+
+  /// Address family not supported by protocol.
+  address_family_not_supported = STDNET_SOCKET_ERROR(EAFNOSUPPORT),
+
+  /// Address already in use.
+  address_in_use = STDNET_SOCKET_ERROR(EADDRINUSE),
+
+  /// Transport endpoint is already connected.
+  already_connected = STDNET_SOCKET_ERROR(EISCONN),
+
+  /// Operation already in progress.
+  already_started = STDNET_SOCKET_ERROR(EALREADY),
+
+  /// Broken pipe.
+  broken_pipe = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_BROKEN_PIPE),
+      STDNET_NATIVE_ERROR(EPIPE)),
+
+  /// A connection has been aborted.
+  connection_aborted = STDNET_SOCKET_ERROR(ECONNABORTED),
+
+  /// Connection refused.
+  connection_refused = STDNET_SOCKET_ERROR(ECONNREFUSED),
+
+  /// Connection reset by peer.
+  connection_reset = STDNET_SOCKET_ERROR(ECONNRESET),
+
+  /// Bad file descriptor.
+  bad_descriptor = STDNET_SOCKET_ERROR(EBADF),
+
+  /// Bad address.
+  fault = STDNET_SOCKET_ERROR(EFAULT),
+
+  /// No route to host.
+  host_unreachable = STDNET_SOCKET_ERROR(EHOSTUNREACH),
+
+  /// Operation now in progress.
+  in_progress = STDNET_SOCKET_ERROR(EINPROGRESS),
+
+  /// Interrupted system call.
+  interrupted = STDNET_SOCKET_ERROR(EINTR),
+
+  /// Invalid argument.
+  invalid_argument = STDNET_SOCKET_ERROR(EINVAL),
+
+  /// Message too long.
+  message_size = STDNET_SOCKET_ERROR(EMSGSIZE),
+
+  /// The name was too long.
+  name_too_long = STDNET_SOCKET_ERROR(ENAMETOOLONG),
+
+  /// Network is down.
+  network_down = STDNET_SOCKET_ERROR(ENETDOWN),
+
+  /// Network dropped connection on reset.
+  network_reset = STDNET_SOCKET_ERROR(ENETRESET),
+
+  /// Network is unreachable.
+  network_unreachable = STDNET_SOCKET_ERROR(ENETUNREACH),
+
+  /// Too many open files.
+  no_descriptors = STDNET_SOCKET_ERROR(EMFILE),
+
+  /// No buffer space available.
+  no_buffer_space = STDNET_SOCKET_ERROR(ENOBUFS),
+
+  /// Cannot allocate memory.
+  no_memory = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_OUTOFMEMORY),
+      STDNET_NATIVE_ERROR(ENOMEM)),
+
+  /// Operation not permitted.
+  no_permission = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_ACCESS_DENIED),
+      STDNET_NATIVE_ERROR(EPERM)),
+
+  /// Protocol not available.
+  no_protocol_option = STDNET_SOCKET_ERROR(ENOPROTOOPT),
+
+  /// Transport endpoint is not connected.
+  not_connected = STDNET_SOCKET_ERROR(ENOTCONN),
+
+  /// Socket operation on non-socket.
+  not_socket = STDNET_SOCKET_ERROR(ENOTSOCK),
+
+  /// Operation cancelled.
+  operation_aborted = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_OPERATION_ABORTED),
+      STDNET_NATIVE_ERROR(ECANCELED)),
+
+  /// Operation not supported.
+  operation_not_supported = STDNET_SOCKET_ERROR(EOPNOTSUPP),
+
+  /// Cannot send after transport endpoint shutdown.
+  shut_down = STDNET_SOCKET_ERROR(ESHUTDOWN),
+
+  /// Connection timed out.
+  timed_out = STDNET_SOCKET_ERROR(ETIMEDOUT),
+
+  /// Resource temporarily unavailable.
+  try_again = STDNET_WIN_OR_POSIX(
+      STDNET_NATIVE_ERROR(ERROR_RETRY),
+      STDNET_NATIVE_ERROR(EAGAIN)),
+
+  /// The socket is marked non-blocking and the requested operation would block.
+  would_block = STDNET_SOCKET_ERROR(EWOULDBLOCK)
+};
+
+} // namespace syserrc
+
+/// Returns the error category used for the system errors.
+extern STDNET_DECL const std::error_category& system_category();
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+namespace std {
+
+template<> struct is_error_code_enum<
+  std::experimental::net::detail::syserrc::system_errors>
+{
+  static const bool value = true;
+};
+
+} // namespace std
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+namespace syserrc {
+
+inline std::error_code make_error_code(system_errors e)
+{
+  return std::error_code(static_cast<int>(e),
+      std::experimental::net::detail::system_category());
+}
+
+} // namespace syserrc
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#undef STDNET_NATIVE_ERROR
+#undef STDNET_SOCKET_ERROR
+#undef STDNET_NETDB_ERROR
+#undef STDNET_GETADDRINFO_ERROR
+#undef STDNET_WIN_OR_POSIX
+
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/detail/impl/system_errors.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_DETAIL_SYSTEM_ERRORS_HPP
diff --git a/ip-address/include/std/net/detail/throw_error.hpp b/ip-address/include/std/net/detail/throw_error.hpp
new file mode 100644
index 0000000..4067cb7
--- /dev/null
+++ b/ip-address/include/std/net/detail/throw_error.hpp
@@ -0,0 +1,57 @@
+//
+// detail/throw_error.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_THROW_ERROR_HPP
+#define STDNET_DETAIL_THROW_ERROR_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <system_error>
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+STDNET_DECL void do_throw_error(const std::error_code& err);
+
+STDNET_DECL void do_throw_error(const std::error_code& err,
+    const char* location);
+
+inline void throw_error(const std::error_code& err)
+{
+  if (err)
+    do_throw_error(err);
+}
+
+inline void throw_error(const std::error_code& err,
+    const char* location)
+{
+  if (err)
+    do_throw_error(err, location);
+}
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/detail/impl/throw_error.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_DETAIL_THROW_ERROR_HPP
diff --git a/ip-address/include/std/net/detail/throw_exception.hpp b/ip-address/include/std/net/detail/throw_exception.hpp
new file mode 100644
index 0000000..0903df1
--- /dev/null
+++ b/ip-address/include/std/net/detail/throw_exception.hpp
@@ -0,0 +1,45 @@
+//
+// detail/throw_exception.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_THROW_EXCEPTION_HPP
+#define STDNET_DETAIL_THROW_EXCEPTION_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+// Declare the throw_exception function for all targets.
+template <typename Exception>
+void throw_exception(const Exception& e);
+
+// Only define the throw_exception function when exceptions are enabled.
+// Otherwise, it is up to the application to provide a definition of this
+// function.
+# if !defined(STDNET_NO_EXCEPTIONS)
+template <typename Exception>
+void throw_exception(const Exception& e)
+{
+  throw e;
+}
+# endif // !defined(STDNET_NO_EXCEPTIONS)
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#endif // STDNET_DETAIL_THROW_EXCEPTION_HPP
diff --git a/ip-address/include/std/net/detail/winsock_init.hpp b/ip-address/include/std/net/detail/winsock_init.hpp
new file mode 100644
index 0000000..fc008de
--- /dev/null
+++ b/ip-address/include/std/net/detail/winsock_init.hpp
@@ -0,0 +1,94 @@
+//
+// detail/winsock_init.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_DETAIL_WINSOCK_INIT_HPP
+#define STDNET_DETAIL_WINSOCK_INIT_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+
+#if defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace detail {
+
+class winsock_init_base
+{
+protected:
+  // Structure to track result of initialisation and number of uses. POD is used
+  // to ensure that the values are zero-initialised prior to any code being run.
+  struct data
+  {
+    long init_count_;
+    long result_;
+  };
+
+  STDNET_DECL static void startup(data& d,
+      unsigned char major, unsigned char minor);
+
+  STDNET_DECL static void cleanup(data& d);
+
+  STDNET_DECL static void throw_on_error(data& d);
+};
+
+template <int Major = 2, int Minor = 0>
+class winsock_init : private winsock_init_base
+{
+public:
+  winsock_init(bool allow_throw = true)
+  {
+    startup(data_, Major, Minor);
+    if (allow_throw)
+      throw_on_error(data_);
+  }
+
+  winsock_init(const winsock_init&)
+  {
+    startup(data_, Major, Minor);
+    throw_on_error(data_);
+  }
+
+  ~winsock_init()
+  {
+    cleanup(data_);
+  }
+
+private:
+  static data data_;
+};
+
+template <int Major, int Minor>
+winsock_init_base::data winsock_init<Major, Minor>::data_;
+
+// Static variable to ensure that winsock is initialised before main, and
+// therefore before any other threads can get started.
+static const winsock_init<>& winsock_init_instance = winsock_init<>(false);
+
+} // namespace detail
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/detail/impl/winsock_init.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // defined(STDNET_WINDOWS) || defined(__CYGWIN__)
+
+#endif // STDNET_DETAIL_WINSOCK_INIT_HPP
diff --git a/ip-address/include/std/net/ip/address.hpp b/ip-address/include/std/net/ip/address.hpp
new file mode 100644
index 0000000..8a5e75a
--- /dev/null
+++ b/ip-address/include/std/net/ip/address.hpp
@@ -0,0 +1,328 @@
+//
+// ip/address.hpp
+// ~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_ADDRESS_HPP
+#define STDNET_IP_ADDRESS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <string>
+#include <system_error>
+#include <type_traits>
+#include "std/net/ip/fwd.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/address_v6.hpp"
+
+#if !defined(STDNET_NO_IOSTREAM)
+# include <iosfwd>
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+namespace detail {
+
+template <class T, class = void>
+struct is_convertible_to_address_1 : false_type {};
+
+template <class T>
+struct is_convertible_to_address_1<T,
+  typename enable_if<is_same<address,
+    decltype(address_cast<address>(declval<T>()))>::value>::type> : true_type {};
+
+template <class T>
+struct is_convertible_to_address : is_convertible_to_address_1<T> {};
+
+template <>
+struct is_convertible_to_address<address> : false_type {};
+
+} // namespace detail
+
+//template <> struct is_convertible_to_address<address> : false_type {};
+
+/// Implements version-independent IP addresses.
+/**
+ * The ip::address class provides the ability to use either IP version 4 or
+ * version 6 addresses.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class address
+{
+public:
+  /// Default constructor.
+  STDNET_CONSTEXPR address() STDNET_NOEXCEPT
+    : type_(invalid),
+      ipv4_address_(),
+      ipv6_address_()
+  {
+  }
+
+  /// Construct from another address type.
+  template <typename T,
+    typename = typename enable_if<
+      detail::is_convertible_to_address<T>::value>::type>
+  STDNET_CONSTEXPR address(const T& t) STDNET_NOEXCEPT;
+
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  /// Explicitly construct from a list of arguments.
+  template <typename... T,
+    typename = typename enable_if<is_same<address,
+      decltype(make_address(declval<T>()...))>::value>::type>
+  explicit STDNET_CONSTEXPR address(T&&... t);
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  template <typename T1>
+  explicit address(T1& t1, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1&>()))>::value>::type* = 0)
+      { *this = make_address(t1); }
+  template <typename T1>
+  explicit address(const T1& t1, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1>()))>::value>::type* = 0)
+      { *this = make_address(t1); }
+  template <typename T1, typename T2>
+  address(T1& t1, T2& t2, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1&>(), declval<T2&>()))>::value>::type* = 0)
+      { *this = make_address(t1, t2); }
+  template <typename T1, typename T2>
+  address(T1& t1, const T2& t2, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1&>(), declval<T2>()))>::value>::type* = 0)
+      { *this = make_address(t1, t2); }
+  template <typename T1, typename T2>
+  address(const T1& t1, T2& t2, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1>(), declval<T2&>()))>::value>::type* = 0)
+      { *this = make_address(t1, t2); }
+  template <typename T1, typename T2>
+  address(const T1& t1, const T2& t2, typename enable_if<is_same<address,
+    decltype(make_address(declval<T1>(), declval<T2>()))>::value>::type* = 0)
+      { *this = make_address(t1, t2); }
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+  /// Copy constructor.
+  STDNET_CONSTEXPR address(const address& other) STDNET_NOEXCEPT
+    : type_(other.type_),
+      ipv4_address_(other.ipv4_address_),
+      ipv6_address_(other.ipv6_address_)
+  {
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move constructor.
+  address(address&& other) STDNET_NOEXCEPT
+    : type_(other.type_),
+      ipv4_address_(other.ipv4_address_),
+      ipv6_address_(other.ipv6_address_)
+  {
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Assign from another address.
+  address& operator=(const address& other) STDNET_NOEXCEPT
+  {
+    type_ = other.type_;
+    ipv4_address_ = other.ipv4_address_;
+    ipv6_address_ = other.ipv6_address_;
+    return *this;
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move-assign from another address.
+  address& operator=(address&& other) STDNET_NOEXCEPT
+  {
+    type_ = other.type_;
+    ipv4_address_ = other.ipv4_address_;
+    ipv6_address_ = other.ipv6_address_;
+    return *this;
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Get whether the address is an IP version 4 address.
+  STDNET_CONSTEXPR bool is_v4() const STDNET_NOEXCEPT
+  {
+    return type_ == ipv4;
+  }
+
+  /// Get whether the address is an IP version 6 address.
+  STDNET_CONSTEXPR bool is_v6() const STDNET_NOEXCEPT
+  {
+    return type_ == ipv6;
+  }
+
+  /// Get the address as a string in dotted decimal format.
+  STDNET_DECL std::string to_string() const;
+
+  /// Get the address as a string in dotted decimal format.
+  STDNET_DECL std::string to_string(std::error_code& ec) const;
+
+  /// Determine whether the address is a loopback address.
+  STDNET_CONSTEXPR bool is_loopback() const STDNET_NOEXCEPT
+  {
+    return (type_ == ipv4) ? ipv4_address_.is_loopback() :
+      (type_ == ipv6) ? ipv6_address_.is_loopback() : false;
+  }
+
+  /// Determine whether the address is unspecified.
+  STDNET_CONSTEXPR bool is_unspecified() const STDNET_NOEXCEPT
+  {
+    return (type_ == ipv4) ? ipv4_address_.is_unspecified() :
+      (type_ == ipv6) ? ipv6_address_.is_unspecified() : false;
+  }
+
+  /// Determine whether the address is a multicast address.
+  STDNET_CONSTEXPR bool is_multicast() const STDNET_NOEXCEPT
+  {
+    return (type_ == ipv4) ? ipv4_address_.is_multicast() :
+      (type_ == ipv6) ? ipv6_address_.is_multicast() : false;
+  }
+
+  /// Compare two addresses for equality.
+  friend bool operator==(const address& a1,
+      const address& a2) STDNET_NOEXCEPT
+  {
+    if (a1.type_ != a2.type_)
+      return false;
+    if (a1.type_ == address::ipv4)
+      return a1.ipv4_address_ == a2.ipv4_address_;
+    if (a1.type_ == address::ipv6)
+      return a1.ipv4_address_ == a2.ipv4_address_;
+    return true;
+  }
+
+  /// Compare two addresses for inequality.
+  friend bool operator!=(const address& a1, const address& a2) STDNET_NOEXCEPT
+  {
+    return !(a1 == a2);
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<(const address& a1,
+      const address& a2) STDNET_NOEXCEPT
+  {
+    if (a1.type_ < a2.type_)
+      return true;
+    if (a1.type_ > a2.type_)
+      return false;
+    if (a1.type_ == address::ipv4)
+      return a1.ipv4_address_ < a2.ipv4_address_;
+    if (a1.type_ == address::ipv6)
+      return a1.ipv6_address_ < a2.ipv6_address_;
+    return false;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>(const address& a1, const address& a2) STDNET_NOEXCEPT
+  {
+    return a2 < a1;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<=(const address& a1, const address& a2) STDNET_NOEXCEPT
+  {
+    return !(a2 < a1);
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>=(const address& a1, const address& a2) STDNET_NOEXCEPT
+  {
+    return !(a1 < a2);
+  }
+
+private:
+  friend class address_v4;
+  friend class address_v6;
+
+  // The type of the address.
+  enum address_type { invalid, ipv4, ipv6 } type_;
+
+  // The underlying IPv4 address.
+  address_v4 ipv4_address_;
+
+  // The underlying IPv6 address.
+  address_v6 ipv6_address_;
+
+  // Helper constructor for address_cast.
+  STDNET_CONSTEXPR address(address_type type,
+      const address_v4& v4, const address_v6& v6)
+    : type_(type),
+      ipv4_address_(v4),
+      ipv6_address_(v6)
+  {
+  }
+
+  template <class T> friend STDNET_CONSTEXPR T address_cast(const address&,
+    typename enable_if<is_same<T, address_v4>::value>::type*);
+  template <class T> friend STDNET_CONSTEXPR T address_cast(const address&,
+    typename enable_if<is_same<T, address_v6>::value>::type*);
+  template <class T> friend STDNET_CONSTEXPR T address_cast(const address_v4&,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT;
+  template <class T> friend STDNET_CONSTEXPR T address_cast(const address_v6&,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT;
+};
+
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
+STDNET_DECL address make_address(const char* str);
+
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
+STDNET_DECL address make_address(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
+STDNET_DECL address make_address(const std::string& str);
+
+/// Create an address from an IPv4 address string in dotted decimal form,
+/// or from an IPv6 address in hexadecimal notation.
+STDNET_DECL address make_address(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+/// Output an address as a string.
+/**
+ * Used to output a human-readable string for a specified address.
+ *
+ * @param os The output stream to which the string will be written.
+ *
+ * @param addr The address to be written.
+ *
+ * @return The output stream.
+ *
+ * @relates std::experimental::net::ip::address
+ */
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address& addr);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#include "std/net/ip/impl/address.hpp"
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/ip/impl/address.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#include "std/net/ip/address_cast.hpp"
+
+#endif // STDNET_IP_ADDRESS_HPP
diff --git a/ip-address/include/std/net/ip/address_cast.hpp b/ip-address/include/std/net/ip/address_cast.hpp
new file mode 100644
index 0000000..dae3d02
--- /dev/null
+++ b/ip-address/include/std/net/ip/address_cast.hpp
@@ -0,0 +1,106 @@
+//
+// ip/address_cast.hpp
+// ~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_ADDRESS_CAST_HPP
+#define STDNET_IP_ADDRESS_CAST_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include "std/net/detail/throw_exception.hpp"
+#include "std/net/ip/fwd.hpp"
+#include "std/net/ip/address.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/address_v6.hpp"
+#include "std/net/ip/bad_address_cast.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+/// Cast a version-independent address to itself.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address& addr,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT
+{
+  return addr;
+}
+
+/// Cast a version-independent address to an IPv4 address.
+/**
+ * @throws bad_address_cast if @c a does not represent an IPv4 address.
+ */
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address& addr,
+    typename enable_if<is_same<T, address_v4>::value>::type*)
+{
+  return (addr.type_ != address::ipv4)
+    ? throw bad_address_cast()
+    : addr.ipv4_address_;
+}
+
+/// Cast a version-independent address to an IPv6 address.
+/**
+ * @throws bad_address_cast if @c a does not represent an IPv6 address.
+ */
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address& addr,
+    typename enable_if<is_same<T, address_v6>::value>::type*)
+{
+  return (addr.type_ != address::ipv6)
+    ? throw bad_address_cast()
+    : addr.ipv6_address_;
+}
+
+/// Cast an IPv4 address to a version-independent address.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address_v4& addr,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT
+{
+  return address(address::ipv4, addr, address_v6());
+}
+
+/// Cast an IPv4 address to itself.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address_v4& addr,
+    typename enable_if<is_same<T, address_v4>::value>::type*) STDNET_NOEXCEPT
+{
+  return addr;
+}
+
+/// Cast an IPv6 address to a version-independent address.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address_v6& addr,
+    typename enable_if<is_same<T, address>::value>::type*) STDNET_NOEXCEPT
+{
+  return address(address::ipv6, address_v4(), addr);
+}
+
+/// Cast an IPv6 address to itself.
+template <class T>
+inline STDNET_CONSTEXPR T address_cast(const address_v6& addr,
+    typename enable_if<is_same<T, address_v6>::value>::type*) STDNET_NOEXCEPT
+{
+  return addr;
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_ADDRESS_CAST_HPP
diff --git a/ip-address/include/std/net/ip/address_v4.hpp b/ip-address/include/std/net/ip/address_v4.hpp
new file mode 100644
index 0000000..a7b9234
--- /dev/null
+++ b/ip-address/include/std/net/ip/address_v4.hpp
@@ -0,0 +1,376 @@
+//
+// ip/address_v4.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_ADDRESS_V4_HPP
+#define STDNET_IP_ADDRESS_V4_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <array>
+#include <string>
+#include <system_error>
+#include "std/net/ip/fwd.hpp"
+#include "std/net/detail/winsock_init.hpp"
+
+#if !defined(STDNET_NO_IOSTREAM)
+# include <iosfwd>
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+class address;
+
+/// Implements IP version 4 style addresses.
+/**
+ * The ip::address_v4 class provides the ability to use and manipulate IP
+ * version 4 addresses.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class address_v4
+{
+public:
+  /// A standard-layout type used to represent an address as an array of bytes.
+  struct bytes_type : std::array<unsigned char, 4>
+  {
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+    template <class... T>
+    explicit STDNET_CONSTEXPR bytes_type(T... t)
+      : std::array<unsigned char, 4>{{static_cast<unsigned char>(t)...}}
+    {
+    }
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+    explicit STDNET_CONSTEXPR bytes_type(unsigned char a = 0,
+        unsigned char b = 0, unsigned char c = 0, unsigned char d = 0)
+# if defined(STDNET_HAS_CONSTEXPR)
+      : std::array<unsigned char, 4>{{a, b, c, d}}
+    {
+    }
+# else // defined(STDNET_HAS_CONSTEXPR)
+    {
+      (*this)[0] = a, (*this)[1] = b, (*this)[2] = c, (*this)[3] = d;
+    }
+# endif // defined(STDNET_HAS_CONSTEXPR)
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  };
+
+  /// Default constructor.
+  STDNET_CONSTEXPR address_v4() STDNET_NOEXCEPT
+    : bytes_(0, 0, 0, 0)
+  {
+  }
+
+  /// Implicit construction from bytes, in network byte order.
+  STDNET_CONSTEXPR address_v4(const bytes_type& bytes)
+    : bytes_(
+#if UCHAR_MAX > 0xFF
+        (bytes[0] > 0xFF || bytes[1] > 0xFF || bytes[2] > 0xFF || bytes[3] > 0xFF)
+        ? throw std::out_of_range("address_v4 from bytes_type") :
+#endif // UCHAR_MAX > 0xFF
+        bytes)
+  {
+  }
+
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  /// Explicitly construct from a list of arguments.
+  template <typename... T,
+    typename = typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T>()...))>::value>::type>
+  explicit STDNET_CONSTEXPR address_v4(T&&... t)
+    : address_v4(make_address_v4(static_cast<T&&>(t)...))
+  {
+  }
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  template <typename T1>
+  explicit STDNET_CONSTEXPR address_v4(T1& t1,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1&>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1).to_bytes()) {}
+  template <typename T1>
+  explicit STDNET_CONSTEXPR address_v4(const T1& t1,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v4(T1& t1, T2& t2,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1&>(), declval<T2&>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v4(T1& t1, const T2& t2,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1&>(), declval<T2>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v4(const T1& t1, T2& t2,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1>(), declval<T2&>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v4(const T1& t1, const T2& t2,
+    typename enable_if<is_same<address_v4,
+      decltype(make_address_v4(declval<T1>(), declval<T2>()))>::value>::type* = 0)
+        : bytes_(make_address_v4(t1, t2).to_bytes()) {}
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+  /// Copy constructor.
+  STDNET_CONSTEXPR address_v4(const address_v4& other) STDNET_NOEXCEPT
+    : bytes_(other.bytes_)
+  {
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move constructor.
+  address_v4(address_v4&& other) STDNET_NOEXCEPT
+    : bytes_(other.bytes_)
+  {
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Assign from another address.
+  address_v4& operator=(const address_v4& other) STDNET_NOEXCEPT
+  {
+    bytes_ = other.bytes_;
+    return *this;
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move-assign from another address.
+  address_v4& operator=(address_v4&& other) STDNET_NOEXCEPT
+  {
+    bytes_ = other.bytes_;
+    return *this;
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Get the address in bytes, in network byte order.
+  STDNET_CONSTEXPR bytes_type to_bytes() const STDNET_NOEXCEPT
+  {
+    return bytes_;
+  }
+
+  /// Get the address as an unsigned long in host byte order
+  STDNET_CONSTEXPR unsigned long to_ulong() const STDNET_NOEXCEPT
+  {
+    return (static_cast<unsigned long>(bytes_[0]) << 24)
+      | (static_cast<unsigned long>(bytes_[1]) << 16)
+      | (static_cast<unsigned long>(bytes_[2]) << 8)
+      | static_cast<unsigned long>(bytes_[3]);
+  }
+
+  /// Get the address as a string in dotted decimal format.
+  STDNET_DECL std::string to_string() const;
+
+  /// Get the address as a string in dotted decimal format.
+  STDNET_DECL std::string to_string(std::error_code& ec) const;
+
+  /// Determine whether the address is a loopback address.
+  STDNET_CONSTEXPR bool is_loopback() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0xFF000000) == 0x7F000000;
+  }
+
+  /// Determine whether the address is unspecified.
+  STDNET_CONSTEXPR bool is_unspecified() const STDNET_NOEXCEPT
+  {
+    return to_ulong() == 0;
+  }
+
+  /// Determine whether the address is a class A address.
+  STDNET_CONSTEXPR bool is_class_a() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0x80000000) == 0;
+  }
+
+  /// Determine whether the address is a class B address.
+  STDNET_CONSTEXPR bool is_class_b() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0xC0000000) == 0x80000000;
+  }
+
+  /// Determine whether the address is a class C address.
+  STDNET_CONSTEXPR bool is_class_c() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0xE0000000) == 0xC0000000;
+  }
+
+  /// Determine whether the address is a multicast address.
+  STDNET_CONSTEXPR bool is_multicast() const STDNET_NOEXCEPT
+  {
+    return (to_ulong() & 0xF0000000) == 0xE0000000;
+  }
+
+  /// Compare two addresses for equality.
+  friend bool operator==(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.bytes_ == a2.bytes_;
+  }
+
+  /// Compare two addresses for inequality.
+  friend bool operator!=(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.bytes_ == a2.bytes_;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.to_ulong() < a2.to_ulong();
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.to_ulong() > a2.to_ulong();
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<=(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.to_ulong() <= a2.to_ulong();
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>=(const address_v4& a1,
+      const address_v4& a2) STDNET_NOEXCEPT
+  {
+    return a1.to_ulong() >= a2.to_ulong();
+  }
+
+  /// Obtain an address object that represents any address.
+  static STDNET_CONSTEXPR address_v4 any() STDNET_NOEXCEPT
+  {
+    return address_v4();
+  }
+
+  /// Obtain an address object that represents the loopback address.
+  static STDNET_CONSTEXPR address_v4 loopback() STDNET_NOEXCEPT
+  {
+    return address_v4(0x7F000001);
+  }
+
+  /// Obtain an address object that represents the broadcast address.
+  static STDNET_CONSTEXPR address_v4 broadcast() STDNET_NOEXCEPT
+  {
+    return address_v4(0xFFFFFFFF);
+  }
+
+  /// Obtain an address object that represents the broadcast address that
+  /// corresponds to the specified address and netmask.
+  static STDNET_CONSTEXPR address_v4 broadcast(const address_v4& addr,
+      const address_v4& mask) STDNET_NOEXCEPT
+  {
+    return address_v4(addr.to_ulong() | (mask.to_ulong() ^ 0xFFFFFFFF));
+  }
+
+private:
+  // The underlying IPv4 address.
+  bytes_type bytes_;
+};
+
+/// Construct an address_v4 from raw bytes.
+inline STDNET_CONSTEXPR address_v4 make_address_v4(const address_v4::bytes_type& bytes)
+{
+  return bytes;
+}
+
+/// Construct an address_v4 from a unsigned long in host byte order.
+inline STDNET_CONSTEXPR address_v4 make_address_v4(unsigned long addr)
+{
+  return
+#if ULONG_MAX > 0xFFFFFFFF
+    (addr > 0xFFFFFFFF)
+    ? throw std::out_of_range("address_v4 from unsigned long") :
+#endif // ULONG_MAX > 0xFFFFFFFF
+    address_v4::bytes_type((addr >> 24) & 0xFF,
+      (addr >> 16) & 0xFF, (addr >> 8) & 0xFF, addr & 0xFF);
+}
+
+/// Create an address_v4 from an IPv4 address string in dotted decimal form.
+STDNET_DECL address_v4 make_address_v4(const char* str);
+
+/// Create an address_v4 from an IPv4 address string in dotted decimal form.
+STDNET_DECL address_v4 make_address_v4(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+/// Create an address_v4 from an IPv4 address string in dotted decimal form.
+STDNET_DECL address_v4 make_address_v4(const std::string& str);
+
+/// Create an address_v4 from an IPv4 address string in dotted decimal form.
+STDNET_DECL address_v4 make_address_v4(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+#if defined(STDNET_HAS_CONSTEXPR)
+
+/// The IPv4 unspecified address.
+STDNET_CONSTEXPR address_v4 any_v4(0);
+
+/// The IPv4 loopback address.
+STDNET_CONSTEXPR address_v4 loopback_v4(0x7F000001);
+
+/// The IPv4 broadcast address.
+STDNET_CONSTEXPR address_v4 broadcast_v4(0xFFFFFFFF);
+
+#else // defined(STDNET_HAS_CONSTEXPR)
+
+static const address_v4 any_v4(0);
+static const address_v4 loopback_v4(0x7F000001);
+static const address_v4 broadcast_v4(0xFFFFFFFF);
+
+#endif // defined(STDNET_HAS_CONSTEXPR)
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+/// Output an address as a string.
+/**
+ * Used to output a human-readable string for a specified address.
+ *
+ * @param os The output stream to which the string will be written.
+ *
+ * @param addr The address to be written.
+ *
+ * @return The output stream.
+ *
+ * @relates std::experimental::net::ip::address_v4
+ */
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address_v4& addr);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#include "std/net/ip/impl/address_v4.hpp"
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/ip/impl/address_v4.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_IP_ADDRESS_V4_HPP
diff --git a/ip-address/include/std/net/ip/address_v6.hpp b/ip-address/include/std/net/ip/address_v6.hpp
new file mode 100644
index 0000000..3c4f440
--- /dev/null
+++ b/ip-address/include/std/net/ip/address_v6.hpp
@@ -0,0 +1,440 @@
+//
+// ip/address_v6.hpp
+// ~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_ADDRESS_V6_HPP
+#define STDNET_IP_ADDRESS_V6_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <array>
+#include <string>
+#include <system_error>
+#include "std/net/ip/fwd.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/bad_address_cast.hpp"
+#include "std/net/detail/winsock_init.hpp"
+
+#if !defined(STDNET_NO_IOSTREAM)
+# include <iosfwd>
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+class address;
+class address_v4;
+
+/// Implements IP version 6 style addresses.
+/**
+ * The ip::address_v6 class provides the ability to use and manipulate IP
+ * version 6 addresses.
+ *
+ * @par Thread Safety
+ * @e Distinct @e objects: Safe.@n
+ * @e Shared @e objects: Unsafe.
+ */
+class address_v6
+{
+public:
+  /// A standard-layout type used to represent an address as an array of bytes.
+  struct bytes_type : std::array<unsigned char, 16>
+  {
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+    template <class... T>
+    explicit STDNET_CONSTEXPR bytes_type(T... t)
+      : std::array<unsigned char, 16>{{static_cast<unsigned char>(t)...}}
+    {
+    }
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+    explicit STDNET_CONSTEXPR bytes_type(
+        unsigned char a = 0, unsigned char b = 0,
+        unsigned char c = 0, unsigned char d = 0,
+        unsigned char e = 0, unsigned char f = 0,
+        unsigned char g = 0, unsigned char h = 0,
+        unsigned char i = 0, unsigned char j = 0,
+        unsigned char k = 0, unsigned char l = 0,
+        unsigned char m = 0, unsigned char n = 0,
+        unsigned char o = 0, unsigned char p = 0)
+# if defined(STDNET_HAS_CONSTEXPR)
+      : std::array<unsigned char, 16>{{a, b, c, d, e, f, g, h, i, h, k, l, m, n, o, p}}
+    {
+    }
+# else // defined(STDNET_HAS_CONSTEXPR)
+    {
+      (*this)[0] = a, (*this)[1] = b, (*this)[2] = c, (*this)[3] = d;
+      (*this)[4] = e, (*this)[5] = f, (*this)[6] = g, (*this)[7] = h;
+      (*this)[8] = i, (*this)[9] = j, (*this)[10] = k, (*this)[11] = l;
+      (*this)[12] = m, (*this)[13] = n, (*this)[14] = o, (*this)[15] = p;
+    }
+# endif // defined(STDNET_HAS_CONSTEXPR)
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  };
+
+  /// Default constructor.
+  STDNET_CONSTEXPR address_v6() STDNET_NOEXCEPT
+    : bytes_(0),
+      scope_id_(0)
+  {
+  }
+
+  /// Implicit construction from bytes, in network byte order.
+  STDNET_CONSTEXPR address_v6(const bytes_type& bytes, unsigned long scope = 0)
+    : bytes_(
+#if UCHAR_MAX > 0xFF
+        (bytes[0] > 0xFF || bytes[1] > 0xFF || bytes[2] > 0xFF || bytes[3] > 0xFF
+        || bytes[4] > 0xFF || bytes[5] > 0xFF || bytes[6] > 0xFF || bytes[7] > 0xFF
+        || bytes[8] > 0xFF || bytes[9] > 0xFF || bytes[10] > 0xFF || bytes[11] > 0xFF
+        || bytes[12] > 0xFF || bytes[13] > 0xFF || bytes[14] > 0xFF || bytes[15] > 0xFF)
+        ? throw std::out_of_range("address_v6 from bytes_type") :
+#endif // UCHAR_MAX > 0xFF
+        bytes),
+      scope_id_(scope)
+  {
+  }
+
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  /// Explicitly construct from a list of arguments.
+  template <typename... T,
+    typename = typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T>()...))>::value>::type>
+  explicit STDNET_CONSTEXPR address_v6(T&&... t)
+    : address_v6(make_address_v6(static_cast<T&&>(t)...))
+  {
+  }
+#else // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+  template <typename T1>
+  explicit STDNET_CONSTEXPR address_v6(T1& t1,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1&>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1).to_bytes()) {}
+  template <typename T1>
+  explicit STDNET_CONSTEXPR address_v6(const T1& t1,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v6(T1& t1, T2& t2,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1&>(), declval<T2&>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v6(T1& t1, const T2& t2,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1&>(), declval<T2>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v6(const T1& t1, T2& t2,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1>(), declval<T2&>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1, t2).to_bytes()) {}
+  template <typename T1, typename T2>
+  STDNET_CONSTEXPR address_v6(const T1& t1, const T2& t2,
+    typename enable_if<is_same<address_v6,
+      decltype(make_address_v6(declval<T1>(), declval<T2>()))>::value>::type* = 0)
+        : bytes_(make_address_v6(t1, t2).to_bytes()) {}
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+  /// Copy constructor.
+  STDNET_CONSTEXPR address_v6(const address_v6& other) STDNET_NOEXCEPT
+    : bytes_(other.bytes_), scope_id_(other.scope_id_)
+  {
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move constructor.
+  address_v6(address_v6&& other) STDNET_NOEXCEPT
+    : bytes_(other.bytes_), scope_id_(other.scope_id_)
+  {
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// Assign from another address.
+  address_v6& operator=(const address_v6& other) STDNET_NOEXCEPT
+  {
+    bytes_ = other.bytes_;
+    scope_id_ = other.scope_id_;
+    return *this;
+  }
+
+#if defined(STDNET_HAS_MOVE)
+  /// Move-assign from another address.
+  address_v6& operator=(address_v6&& other) STDNET_NOEXCEPT
+  {
+    bytes_ = other.bytes_;
+    scope_id_ = other.scope_id_;
+    return *this;
+  }
+#endif // defined(STDNET_HAS_MOVE)
+
+  /// The scope ID of the address.
+  /**
+   * Returns the scope ID associated with the IPv6 address.
+   */
+  STDNET_CONSTEXPR unsigned long scope_id() const STDNET_NOEXCEPT
+  {
+    return scope_id_;
+  }
+
+  /// The scope ID of the address.
+  /**
+   * Modifies the scope ID associated with the IPv6 address.
+   */
+  void scope_id(unsigned long id) STDNET_NOEXCEPT
+  {
+    scope_id_ = id;
+  }
+
+  /// Get the address in bytes, in network byte order.
+  STDNET_CONSTEXPR bytes_type to_bytes() const STDNET_NOEXCEPT
+  {
+    return bytes_;
+  }
+
+  /// Get the address as a string.
+  STDNET_DECL std::string to_string() const;
+
+  /// Get the address as a string.
+  STDNET_DECL std::string to_string(std::error_code& ec) const;
+
+  /// Determine whether the address is a loopback address.
+  STDNET_CONSTEXPR bool is_loopback() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0) && (bytes_[1] == 0)
+        && (bytes_[2] == 0) && (bytes_[3] == 0)
+        && (bytes_[4] == 0) && (bytes_[5] == 0)
+        && (bytes_[6] == 0) && (bytes_[7] == 0)
+        && (bytes_[8] == 0) && (bytes_[9] == 0)
+        && (bytes_[10] == 0) && (bytes_[11] == 0)
+        && (bytes_[12] == 0) && (bytes_[13] == 0)
+        && (bytes_[14] == 0) && (bytes_[15] == 1));
+  }
+
+  /// Determine whether the address is unspecified.
+  STDNET_CONSTEXPR bool is_unspecified() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0) && (bytes_[1] == 0)
+        && (bytes_[2] == 0) && (bytes_[3] == 0)
+        && (bytes_[4] == 0) && (bytes_[5] == 0)
+        && (bytes_[6] == 0) && (bytes_[7] == 0)
+        && (bytes_[8] == 0) && (bytes_[9] == 0)
+        && (bytes_[10] == 0) && (bytes_[11] == 0)
+        && (bytes_[12] == 0) && (bytes_[13] == 0)
+        && (bytes_[14] == 0) && (bytes_[15] == 0));
+  }
+
+  /// Determine whether the address is link local.
+  STDNET_CONSTEXPR bool is_link_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xfe) && ((bytes_[1] & 0xc0) == 0x80));
+  }
+
+  /// Determine whether the address is site local.
+  STDNET_CONSTEXPR bool is_site_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xfe) && ((bytes_[1] & 0xc0) == 0xc0));
+  }
+
+  /// Determine whether the address is a mapped IPv4 address.
+  STDNET_CONSTEXPR bool is_v4_mapped() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0) && (bytes_[1] == 0)
+        && (bytes_[2] == 0) && (bytes_[3] == 0)
+        && (bytes_[4] == 0) && (bytes_[5] == 0)
+        && (bytes_[6] == 0) && (bytes_[7] == 0)
+        && (bytes_[8] == 0) && (bytes_[9] == 0)
+        && (bytes_[10] == 0xff) && (bytes_[11] == 0xff));
+  }
+
+  /// Determine whether the address is a multicast address.
+  STDNET_CONSTEXPR bool is_multicast() const STDNET_NOEXCEPT
+  {
+    return (bytes_[0] == 0xff);
+  }
+
+  /// Determine whether the address is a global multicast address.
+  STDNET_CONSTEXPR bool is_multicast_global() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x0e));
+  }
+
+  /// Determine whether the address is a link-local multicast address.
+  STDNET_CONSTEXPR bool is_multicast_link_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x02));
+  }
+
+  /// Determine whether the address is a node-local multicast address.
+  STDNET_CONSTEXPR bool is_multicast_node_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x01));
+  }
+
+  /// Determine whether the address is a org-local multicast address.
+  STDNET_CONSTEXPR bool is_multicast_org_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x08));
+  }
+
+  /// Determine whether the address is a site-local multicast address.
+  STDNET_CONSTEXPR bool is_multicast_site_local() const STDNET_NOEXCEPT
+  {
+    return ((bytes_[0] == 0xff) && ((bytes_[1] & 0x0f) == 0x05));
+  }
+
+  /// Compare two addresses for equality.
+  friend bool operator==(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return a1.bytes_ == a2.bytes_ && a1.scope_id_ == a2.scope_id_;
+  }
+
+  /// Compare two addresses for inequality.
+  friend bool operator!=(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return !(a1 == a2);
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    if (a1.bytes_ < a2.bytes_)
+      return true;
+    if (a1.bytes_ > a2.bytes_)
+      return false;
+    return a1.scope_id_ < a2.scope_id_;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return a2 < a1;
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator<=(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return !(a2 < a1);
+  }
+
+  /// Compare addresses for ordering.
+  friend bool operator>=(const address_v6& a1,
+      const address_v6& a2) STDNET_NOEXCEPT
+  {
+    return !(a1 < a2);
+  }
+
+  /// Obtain an address object that represents any address.
+  static STDNET_CONSTEXPR address_v6 any() STDNET_NOEXCEPT
+  {
+    return address_v6();
+  }
+
+  /// Obtain an address object that represents the loopback address.
+  static STDNET_CONSTEXPR address_v6 loopback() STDNET_NOEXCEPT
+  {
+    return bytes_type(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+  }
+
+private:
+  friend STDNET_CONSTEXPR address_v4 make_address_v4(
+      v4_mapped_t, const address_v6&);
+
+  // The underlying IPv6 address.
+  bytes_type bytes_;
+
+  // The scope ID associated with the address.
+  unsigned long scope_id_;
+};
+
+/// Construct an address_v6 from raw bytes.
+inline STDNET_CONSTEXPR address_v6 make_address_v6(
+    const address_v6::bytes_type& bytes, unsigned long scope_id = 0)
+{
+  return address_v6(bytes, scope_id);
+}
+
+/// Create an address_v6 from an IPv6 address string.
+STDNET_DECL address_v6 make_address_v6(const char* str);
+
+/// Create an address_v6 from an IPv6 address string.
+STDNET_DECL address_v6 make_address_v6(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+/// Create an address_v6 from an IPv6 address string.
+STDNET_DECL address_v6 make_address_v6(const std::string& str);
+
+/// Create an address_v6 from an IPv6 address string.
+STDNET_DECL address_v6 make_address_v6(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT;
+
+/// Create an IPv4-mapped address_v6 from an IPv4 address.
+inline STDNET_CONSTEXPR address_v6 make_address_v6(
+    v4_mapped_t, const address_v4& addr) STDNET_NOEXCEPT
+{
+  return address_v6::bytes_type(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF,
+      static_cast<const address_v4::bytes_type>(addr.to_bytes())[0],
+      static_cast<const address_v4::bytes_type>(addr.to_bytes())[1],
+      static_cast<const address_v4::bytes_type>(addr.to_bytes())[2],
+      static_cast<const address_v4::bytes_type>(addr.to_bytes())[3]);
+}
+
+/// Create an address_v4 from an IPv4-mapped address_v6.
+inline STDNET_CONSTEXPR address_v4 make_address_v4(
+    v4_mapped_t, const address_v6& addr)
+{
+  return !addr.is_v4_mapped() ? throw bad_address_cast() :
+    address_v4::bytes_type(addr.bytes_[12], addr.bytes_[13],
+        addr.bytes_[14], addr.bytes_[15]);
+}
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+/// Output an address as a string.
+/**
+ * Used to output a human-readable string for a specified address.
+ *
+ * @param os The output stream to which the string will be written.
+ *
+ * @param addr The address to be written.
+ *
+ * @return The output stream.
+ *
+ * @relates std::experimental::net::ip::address_v6
+ */
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address_v6& addr);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#include "std/net/ip/impl/address_v6.hpp"
+#if defined(STDNET_HEADER_ONLY)
+# include "std/net/ip/impl/address_v6.ipp"
+#endif // defined(STDNET_HEADER_ONLY)
+
+#endif // STDNET_IP_ADDRESS_V6_HPP
diff --git a/ip-address/include/std/net/ip/bad_address_cast.hpp b/ip-address/include/std/net/ip/bad_address_cast.hpp
new file mode 100644
index 0000000..bc330c2
--- /dev/null
+++ b/ip-address/include/std/net/ip/bad_address_cast.hpp
@@ -0,0 +1,46 @@
+//
+// ip/bad_address_cast.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_BAD_ADDRESS_CAST_HPP
+#define STDNET_IP_BAD_ADDRESS_CAST_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <typeinfo>
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+/// Exception thrown on a failed address_cast.
+class bad_address_cast
+  : public bad_cast
+{
+public:
+  virtual const char* what() const STDNET_NOEXCEPT
+  {
+    return "bad address cast";
+  }
+};
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_BAD_ADDRESS_CAST_HPP
diff --git a/ip-address/include/std/net/ip/fwd.hpp b/ip-address/include/std/net/ip/fwd.hpp
new file mode 100644
index 0000000..2c8f929
--- /dev/null
+++ b/ip-address/include/std/net/ip/fwd.hpp
@@ -0,0 +1,149 @@
+//
+// ip/fwd.hpp
+// ~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_FWD_HPP
+#define STDNET_IP_FWD_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <array>
+#include <string>
+#include <system_error>
+#include <type_traits>
+
+#if !defined(STDNET_NO_IOSTREAM)
+# include <iosfwd>
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+#if defined(STDNET_HAS_CONSTEXPR)
+struct v4_mapped_t { STDNET_CONSTEXPR v4_mapped_t() {} };
+STDNET_CONSTEXPR v4_mapped_t v4_mapped;
+#else // !defined(STDNET_HAS_CONSTEXPR)
+enum v4_mapped_t { v4_mapped };
+#endif // !defined(STDNET_HAS_CONSTEXPR)
+
+class address;
+class address_v4;
+class address_v6;
+
+// address comparisons:
+bool operator==(const address&, const address&) STDNET_NOEXCEPT;
+bool operator!=(const address&, const address&) STDNET_NOEXCEPT;
+bool operator< (const address&, const address&) STDNET_NOEXCEPT;
+bool operator> (const address&, const address&) STDNET_NOEXCEPT;
+bool operator<=(const address&, const address&) STDNET_NOEXCEPT;
+bool operator>=(const address&, const address&) STDNET_NOEXCEPT;
+
+// address creation:
+address make_address(const char*);
+address make_address(const char*, std::error_code&) STDNET_NOEXCEPT;
+address make_address(const std::string&);
+address make_address(const std::string&, std::error_code&) STDNET_NOEXCEPT;
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+// address I/O:
+template<class CharT, class Traits>
+  basic_ostream<CharT, Traits>& operator<<(
+    basic_ostream<CharT, Traits>&, const address&);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+// address_v4 comparisons:
+bool operator==(const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator!=(const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator< (const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator> (const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator<=(const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+bool operator>=(const address_v4&, const address_v4&) STDNET_NOEXCEPT;
+
+// address_v4 creation:
+//STDNET_CONSTEXPR address_v4 make_address_v4(const address_v4::octets&);
+STDNET_CONSTEXPR address_v4 make_address_v4(unsigned long);
+STDNET_CONSTEXPR address_v4 make_address_v4(v4_mapped_t, const address_v6&);
+address_v4 make_address_v4(const char*);
+address_v4 make_address_v4(const char*, error_code&) STDNET_NOEXCEPT;
+address_v4 make_address_v4(const std::string&);
+address_v4 make_address_v4(const std::string&, std::error_code&) STDNET_NOEXCEPT;
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+// address_v4 I/O:
+template<class CharT, class Traits>
+  basic_ostream<CharT, Traits>& operator<<(
+    basic_ostream<CharT, Traits>&, const address_v4&);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+// address_v6 comparisons:
+bool operator==(const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator!=(const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator< (const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator> (const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator<=(const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+bool operator>=(const address_v6&, const address_v6&) STDNET_NOEXCEPT;
+
+// address_v6 creation:
+//STDNET_CONSTEXPR address_v6 make_address_v6(const address_v6::octets&, unsigned long = 0);
+STDNET_CONSTEXPR address_v6 make_address_v6(v4_mapped_t, const address_v4&) STDNET_NOEXCEPT;
+address_v6 make_address_v6(const char*);
+address_v6 make_address_v6(const char*, error_code&) STDNET_NOEXCEPT;
+address_v6 make_address_v6(const std::string&);
+address_v6 make_address_v6(const std::string&, error_code&) STDNET_NOEXCEPT;
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+// address_v6 I/O:
+template<class CharT, class Traits>
+  basic_ostream<CharT, Traits>& operator<<(
+    basic_ostream<CharT, Traits>&, const address_v6&);
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+class bad_address_cast;
+
+// address conversion:
+template <class T> STDNET_CONSTEXPR T address_cast(const address&,
+  typename enable_if<is_same<T, address>::value>::type* = 0) STDNET_NOEXCEPT;
+template <class T> STDNET_CONSTEXPR T address_cast(const address&,
+  typename enable_if<is_same<T, address_v4>::value>::type* = 0);
+template <class T> STDNET_CONSTEXPR T address_cast(const address&,
+  typename enable_if<is_same<T, address_v6>::value>::type* = 0);
+template <class T> STDNET_CONSTEXPR T address_cast(const address_v4&,
+  typename enable_if<is_same<T, address>::value>::type* = 0) STDNET_NOEXCEPT;
+template <class T> STDNET_CONSTEXPR T address_cast(const address_v4&,
+  typename enable_if<is_same<T, address_v4>::value>::type* = 0) STDNET_NOEXCEPT;
+template <class T> T address_cast(const address_v4&,
+  typename enable_if<is_same<T, address_v6>::value>::type* = 0) STDNET_DELETED;
+template <class T> STDNET_CONSTEXPR T address_cast(const address_v6&,
+  typename enable_if<is_same<T, address>::value>::type* = 0) STDNET_NOEXCEPT;
+template <class T> T address_cast(const address_v6&,
+  typename enable_if<is_same<T, address_v4>::value>::type* = 0) STDNET_DELETED;
+template <class T> STDNET_CONSTEXPR T address_cast(const address_v6&,
+  typename enable_if<is_same<T, address_v6>::value>::type* = 0) STDNET_NOEXCEPT;
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_FWD_HPP
diff --git a/ip-address/include/std/net/ip/impl/address.hpp b/ip-address/include/std/net/ip/impl/address.hpp
new file mode 100644
index 0000000..82dc09c
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address.hpp
@@ -0,0 +1,74 @@
+//
+// ip/impl/address.hpp
+// ~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_HPP
+#define STDNET_IP_IMPL_ADDRESS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/ip/address_cast.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+template <typename T, typename>
+inline STDNET_CONSTEXPR address::address(const T& t) STDNET_NOEXCEPT
+  : address(address_cast<address>(t))
+{
+}
+
+#if defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+template <typename... T, typename>
+inline STDNET_CONSTEXPR address::address(T&&... t)
+  : address(make_address(static_cast<T&&>(t)...))
+{
+}
+
+#endif // defined(STDNET_HAS_VARIADIC_TEMPLATES)
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address& addr)
+{
+  std::error_code ec;
+  std::string s = addr.to_string(ec);
+  if (ec)
+  {
+    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
+      std::experimental::net::detail::throw_error(ec);
+    else
+      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
+  }
+  else
+    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
+      os << os.widen(*i);
+  return os;
+}
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_IMPL_ADDRESS_HPP
diff --git a/ip-address/include/std/net/ip/impl/address.ipp b/ip-address/include/std/net/ip/impl/address.ipp
new file mode 100644
index 0000000..b74189c
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address.ipp
@@ -0,0 +1,91 @@
+//
+// ip/impl/address.ipp
+// ~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_IPP
+#define STDNET_IP_IMPL_ADDRESS_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <system_error>
+#include <typeinfo>
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/detail/throw_exception.hpp"
+#include "std/net/detail/system_errors.hpp"
+#include "std/net/ip/address.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+std::string address::to_string() const
+{
+  if (type_ == ipv4)
+    return ipv4_address_.to_string();
+  if (type_ == ipv6)
+    return ipv6_address_.to_string();
+  throw bad_address_cast();
+}
+
+std::string address::to_string(std::error_code& ec) const
+{
+  if (type_ == ipv4)
+    return ipv4_address_.to_string(ec);
+  if (type_ == ipv6)
+    return ipv6_address_.to_string(ec);
+  throw bad_address_cast();
+}
+
+address make_address(const char* str)
+{
+  std::error_code ec;
+  address addr = make_address(str, ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+address make_address(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  address_v6 ipv6_address = make_address_v6(str, ec);
+  if (!ec)
+    return ipv6_address;
+
+  address_v4 ipv4_address = make_address_v4(str, ec);
+  if (!ec)
+    return ipv4_address;
+
+  return address();
+}
+
+address make_address(const std::string& str)
+{
+  return make_address(str.c_str());
+}
+
+address make_address(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  return make_address(str.c_str(), ec);
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_IMPL_ADDRESS_IPP
diff --git a/ip-address/include/std/net/ip/impl/address_v4.hpp b/ip-address/include/std/net/ip/impl/address_v4.hpp
new file mode 100644
index 0000000..8544419
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address_v4.hpp
@@ -0,0 +1,57 @@
+//
+// ip/impl/address_v4.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_V4_HPP
+#define STDNET_IP_IMPL_ADDRESS_V4_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/throw_error.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address_v4& addr)
+{
+  std::error_code ec;
+  std::string s = addr.to_string(ec);
+  if (ec)
+  {
+    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
+      std::experimental::net::detail::throw_error(ec);
+    else
+      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
+  }
+  else
+    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
+      os << os.widen(*i);
+  return os;
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#endif // STDNET_IP_IMPL_ADDRESS_V4_HPP
diff --git a/ip-address/include/std/net/ip/impl/address_v4.ipp b/ip-address/include/std/net/ip/impl/address_v4.ipp
new file mode 100644
index 0000000..1ed99f7
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address_v4.ipp
@@ -0,0 +1,90 @@
+//
+// ip/impl/address_v4.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_V4_IPP
+#define STDNET_IP_IMPL_ADDRESS_V4_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include <climits>
+#include <stdexcept>
+#include "std/net/detail/socket_ops.hpp"
+#include "std/net/detail/system_errors.hpp"
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/detail/throw_exception.hpp"
+#include "std/net/ip/address_v4.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+std::string address_v4::to_string() const
+{
+  std::error_code ec;
+  std::string addr = to_string(ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+std::string address_v4::to_string(std::error_code& ec) const
+{
+  char addr_str[std::experimental::net::detail::max_addr_v4_str_len];
+  const char* addr =
+    std::experimental::net::detail::socket_ops::inet_ntop(
+        AF_INET, bytes_.data(), addr_str,
+        std::experimental::net::detail::max_addr_v4_str_len, 0, ec);
+  if (addr == 0)
+    return std::string();
+  return addr;
+}
+
+address_v4 make_address_v4(const char* str)
+{
+  std::error_code ec;
+  address_v4 addr = make_address_v4(str, ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+address_v4 make_address_v4(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  address_v4::bytes_type bytes;
+  if (std::experimental::net::detail::socket_ops::inet_pton(
+        AF_INET, str, bytes.data(), 0, ec) <= 0)
+    return address_v4();
+  return address_v4(bytes);
+}
+
+address_v4 make_address_v4(const std::string& str)
+{
+  return make_address_v4(str.c_str());
+}
+
+address_v4 make_address_v4(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  return make_address_v4(str.c_str(), ec);
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_IMPL_ADDRESS_V4_IPP
diff --git a/ip-address/include/std/net/ip/impl/address_v6.hpp b/ip-address/include/std/net/ip/impl/address_v6.hpp
new file mode 100644
index 0000000..1b3fd23
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address_v6.hpp
@@ -0,0 +1,57 @@
+//
+// ip/impl/address_v6.hpp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_V6_HPP
+#define STDNET_IP_IMPL_ADDRESS_V6_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#if !defined(STDNET_NO_IOSTREAM)
+
+#include "std/net/detail/throw_error.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+template <typename Elem, typename Traits>
+std::basic_ostream<Elem, Traits>& operator<<(
+    std::basic_ostream<Elem, Traits>& os, const address_v6& addr)
+{
+  std::error_code ec;
+  std::string s = addr.to_string(ec);
+  if (ec)
+  {
+    if (os.exceptions() & std::basic_ostream<Elem, Traits>::failbit)
+      std::experimental::net::detail::throw_error(ec);
+    else
+      os.setstate(std::basic_ostream<Elem, Traits>::failbit);
+  }
+  else
+    for (std::string::iterator i = s.begin(); i != s.end(); ++i)
+      os << os.widen(*i);
+  return os;
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // !defined(STDNET_NO_IOSTREAM)
+
+#endif // STDNET_IP_IMPL_ADDRESS_V6_HPP
diff --git a/ip-address/include/std/net/ip/impl/address_v6.ipp b/ip-address/include/std/net/ip/impl/address_v6.ipp
new file mode 100644
index 0000000..682160b
--- /dev/null
+++ b/ip-address/include/std/net/ip/impl/address_v6.ipp
@@ -0,0 +1,90 @@
+//
+// ip/impl/address_v6.ipp
+// ~~~~~~~~~~~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_IP_IMPL_ADDRESS_V6_IPP
+#define STDNET_IP_IMPL_ADDRESS_V6_IPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/detail/config.hpp"
+#include "std/net/detail/socket_ops.hpp"
+#include "std/net/detail/system_errors.hpp"
+#include "std/net/detail/throw_error.hpp"
+#include "std/net/detail/throw_exception.hpp"
+#include "std/net/ip/address_v6.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+namespace net {
+namespace ip {
+
+std::string address_v6::to_string() const
+{
+  std::error_code ec;
+  std::string addr = to_string(ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+std::string address_v6::to_string(std::error_code& ec) const
+{
+  char addr_str[std::experimental::net::detail::max_addr_v6_str_len];
+  const char* addr =
+    std::experimental::net::detail::socket_ops::inet_ntop(
+        AF_INET6, bytes_.data(), addr_str,
+        std::experimental::net::detail::max_addr_v6_str_len,
+        scope_id_, ec);
+  if (addr == 0)
+    return std::string();
+  return addr;
+}
+
+address_v6 make_address_v6(const char* str)
+{
+  std::error_code ec;
+  address_v6 addr = make_address_v6(str, ec);
+  std::experimental::net::detail::throw_error(ec);
+  return addr;
+}
+
+address_v6 make_address_v6(const char* str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  address_v6::bytes_type bytes;
+  unsigned long scope_id = 0;
+  if (std::experimental::net::detail::socket_ops::inet_pton(
+        AF_INET6, str, bytes.data(), &scope_id, ec) <= 0)
+    return address_v6();
+  return address_v6(bytes, scope_id);
+}
+
+address_v6 make_address_v6(const std::string& str)
+{
+  return make_address_v6(str.c_str());
+}
+
+address_v6 make_address_v6(const std::string& str,
+    std::error_code& ec) STDNET_NOEXCEPT
+{
+  return make_address_v6(str.c_str(), ec);
+}
+
+} // namespace ip
+} // namespace net
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_IP_IMPL_ADDRESS_V6_IPP
diff --git a/ip-address/include/std/net/literals.hpp b/ip-address/include/std/net/literals.hpp
new file mode 100644
index 0000000..2f10279
--- /dev/null
+++ b/ip-address/include/std/net/literals.hpp
@@ -0,0 +1,51 @@
+//
+// literals.hpp
+// ~~~~~~~~~~~~
+//
+// Copyright (c) 2003-2013 Christopher M. Kohlhoff (chris at kohlhoff dot com)
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+
+#ifndef STDNET_LITERALS_HPP
+#define STDNET_LITERALS_HPP
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1200)
+# pragma once
+#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
+
+#include "std/net/ip/address.hpp"
+#include "std/net/ip/address_v4.hpp"
+#include "std/net/ip/address_v6.hpp"
+
+#include "std/net/detail/push_options.hpp"
+
+namespace std {
+namespace experimental {
+inline namespace literals {
+inline namespace net_literals {
+
+inline net::ip::address operator"" _ip(const char* str, std::size_t)
+{
+  return net::ip::make_address(str);
+}
+
+inline net::ip::address_v4 operator"" _ipv4(const char* str, std::size_t)
+{
+  return net::ip::make_address_v4(str);
+}
+
+inline net::ip::address_v6 operator"" _ipv6(const char* str, std::size_t)
+{
+  return net::ip::make_address_v6(str);
+}
+
+} // inline namespace net_literals
+} // inline namespace literals
+} // namespace experimental
+} // namespace std
+
+#include "std/net/detail/pop_options.hpp"
+
+#endif // STDNET_LITERALS_HPP
diff --git a/makefile b/makefile
old mode 100755
new mode 100644
index 773f4c1..2c86037
--- a/makefile
+++ b/makefile
@@ -9,8 +9,9 @@
 ## See README file for details
  
 CC = g++
+LIB = -I./ip-address/include
 ##CFLAGS = -g -pg
-CFLAGS = -O2
+CFLAGS = -O2 -g -std=c++11 $(LIB)
 .cc.o:
 	${CC} ${CFLAGS} -c $*.cc 
 
@@ -29,8 +30,12 @@ PrefixList.o : stdinc.h PrefixList.h
 FilterList.o : stdinc.h FilterList.h
 TupleBST.o : stdinc.h dlist.h TupleBST.h
 db_generator.o : stdinc.h random_db.h PortList.h FilterList.h custom_db.h
+uint128_t.o : uint128_t.h
 
-db_generator:	db_generator.o random_db.o dlist.o ProtList.o FlagList.o ExtraList.o PortList.o PrefixList.o sbintree.o dbintree.o redundant_filter_check.o FilterList.o TupleBST.o custom_db.o
-	${CC} ${CFLAGS} db_generator.o random_db.o dlist.o sbintree.o dbintree.o ProtList.o FlagList.o ExtraList.o PortList.o PrefixList.o FilterList.o redundant_filter_check.o TupleBST.o custom_db.o -o db_generator
+db_generator:	db_generator.o random_db.o dlist.o ProtList.o FlagList.o ExtraList.o PortList.o PrefixList.o sbintree.o dbintree.o redundant_filter_check.o FilterList.o TupleBST.o custom_db.o uint128_t.o
+	${CC} ${CFLAGS} db_generator.o random_db.o dlist.o sbintree.o dbintree.o ProtList.o FlagList.o ExtraList.o PortList.o PrefixList.o FilterList.o redundant_filter_check.o TupleBST.o custom_db.o uint128_t.o -o db_generator
 
 all:	db_generator
+
+clean:
+	rm -rf *.o db_generator
diff --git a/random_db.cc b/random_db.cc
index 8da4c37..b71ff3e 100644
--- a/random_db.cc
+++ b/random_db.cc
@@ -16,28 +16,66 @@ int random_db_gen(int num_filters, FilterList* filters){
   int i;
   unsigned temp1;
   unsigned temp2;
+  uint128_t temp1_128;
+  uint128_t temp2_128;
+  uint128_t temp3_128;
+  uint128_t temp4_128;
   struct filter temp_filter;
 
   for (i = 0; i < num_filters; i++) {
-    // Source Address
-    temp1 = 0;
-    temp1 = mrand48();
-    temp_filter.sa = temp1;
+    if (ADDRLEN == 32) { //IPv4
+       // Source Address
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.sa = temp1;
 
-    // Source Address Length
-    temp1 = 0;
-    temp1 = mrand48();
-    temp_filter.sa_len = (temp1 >> 27);
+       // Source Address Length
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.sa_len = (temp1 >> 27);
 
-    // Destination Address
-    temp1 = 0;
-    temp1 = mrand48();
-    temp_filter.da = temp1;
+       // Destination Address
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.da = temp1;
 
-    // Destination Address Length
-    temp1 = 0;
-    temp1 = mrand48();
-    temp_filter.da_len = (temp1 >> 27);
+       // Destination Address Length
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.da_len = (temp1 >> 27);
+    } else { // IPv6
+       // Source Address
+       temp1_128 = temp2_128 = temp3_128 = temp4_128 = 0;
+       temp1_128 = lrand48();
+       temp2_128 = lrand48();
+       temp3_128 = lrand48();
+       temp4_128 = lrand48();
+       temp2_128 <<= 32;
+       temp3_128 <<= 64;
+       temp4_128 <<= 96;
+       temp_filter.sa = temp4_128 | temp3_128 | temp2_128 | temp1_128;
+
+       // Source Address Length
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.sa_len = (temp1 >> 25);
+
+       // Destination Address
+       temp1_128 = temp2_128 = temp3_128 = temp4_128 = 0;
+       temp1_128 = lrand48();
+       temp2_128 = lrand48();
+       temp3_128 = lrand48();
+       temp4_128 = lrand48();
+       temp2_128 <<= 32;
+       temp3_128 <<= 64;
+       temp4_128 <<= 96;
+       temp_filter.da = temp4_128 | temp3_128 | temp2_128 | temp1_128;
+
+       // Destination Address Length
+       temp1 = 0;
+       temp1 = mrand48();
+       temp_filter.da_len = (temp1 >> 25);
+    }
 
     // Source Port Ranges
     temp1 = 0;
diff --git a/redundant_filter_check.cc b/redundant_filter_check.cc
index 38771e7..fbac9d3 100644
--- a/redundant_filter_check.cc
+++ b/redundant_filter_check.cc
@@ -21,7 +21,7 @@ int redundant_check(struct filter filt1, struct filter filt2){
 
 int sa_prefix_match(struct filter filt1, struct filter filt2){
 
-  unsigned addr1, addr2;
+  uint128_t addr1, addr2;
   int len;
 
   len = filt1.sa_len;
@@ -33,11 +33,11 @@ int sa_prefix_match(struct filter filt1, struct filter filt2){
       // Check source address prefixes
       addr1 = filt1.sa;
       // mask bits
-      addr1 = ((addr1 >> (32-len)) << (32-len));
+      addr1 = ((addr1 >> (128-len)) << (128-len));
       
       addr2 = filt2.sa;
       // mask bits
-      addr2 = ((addr2 >> (32-len)) << (32-len));
+      addr2 = ((addr2 >> (128-len)) << (128-len));
     }
     // Check source address match
     if (addr1 == addr2) return 1;
@@ -47,7 +47,7 @@ int sa_prefix_match(struct filter filt1, struct filter filt2){
 
 int da_prefix_match(struct filter filt1, struct filter filt2){
 
-  unsigned addr1, addr2;
+  uint128_t addr1, addr2;
   int len;
 
   len = filt1.da_len;
@@ -59,11 +59,11 @@ int da_prefix_match(struct filter filt1, struct filter filt2){
       // Check source address prefixes
       addr1 = filt1.da;
       // mask bits
-      addr1 = ((addr1 >> (32-len)) << (32-len));
+      addr1 = ((addr1 >> (128-len)) << (128-len));
       
       addr2 = filt2.da;
       // mask bits
-      addr2 = ((addr2 >> (32-len)) << (32-len));
+      addr2 = ((addr2 >> (128-len)) << (128-len));
     }
     
     // Check source address match
diff --git a/sbintree.cc b/sbintree.cc
index d755099..6a83b51 100644
--- a/sbintree.cc
+++ b/sbintree.cc
@@ -13,12 +13,12 @@
 
 sbintree::sbintree() {
 // Initialize to graph with N vertices and no edges.
-  skew = new float[33];
-  p1child = new float[33];
-  p2child = new float[33];
+  skew = new float[129];
+  p1child = new float[129];
+  p2child = new float[129];
   num_stnodes = 0;
   root = NULL;
-  for (int u = 0; u < 33; u++) {
+  for (int u = 0; u < 129; u++) {
     skew[u] = 0;
     p1child[u] = 0;
     p2child[u] = 0;
@@ -96,13 +96,13 @@ void sbintree::read_skew(FILE* fp_in){
     // printf("matches = %d\n",matches);
     // printf("level = %d, skew = %.4f\n",level,skew);
     if (matches == 4) {
-      if (level <= 32) {
+      if (level <= 128) {
 	p1child[level] = p1_t;
 	p2child[level] = p2_t;
 	skew[level] = f_skew;
       }
       else {
-	fprintf(stderr,"Level for source address skew is greater than 32.\n");
+	fprintf(stderr,"Level for source address skew is greater than 128.\n");
 	exit(1);
       }
       // printf("Read line: %d\t%.4f\t%.4f\t%.4f\n",level,p1_t,p2_t,f_skew);
@@ -117,7 +117,7 @@ void sbintree::read_skew(FILE* fp_in){
 void sbintree::print_skew(FILE *fp) {
   
   fprintf(fp,"Level\tp1\tp2\tSkew\n");
-  for (int i = 0; i < 33; i++) {
+  for (int i = 0; i < 129; i++) {
     fprintf(fp,"%d\t%.4f\t%.4f\t%.4f\n",
 	    i,p1child[i],p2child[i],skew[i]);
   }
@@ -125,7 +125,7 @@ void sbintree::print_skew(FILE *fp) {
 }
 
 void sbintree::build_tree(dlist* Flist, struct filter filters[]){
-  unsigned int addr = 0;
+  uint128_t addr = 0;
   // Create copy of list
   dlist* temp_list = new dlist;
   (*temp_list)=(Flist);
@@ -138,7 +138,7 @@ void sbintree::build_tree(dlist* Flist, struct filter filters[]){
   return;
 }
 
-void sbintree::add_node(struct stnode *prnt, int lev, int dir, unsigned int addr, dlist* Flist, struct filter filters[], int CurrNest){
+void sbintree::add_node(struct stnode *prnt, int lev, int dir, uint128_t addr, dlist* Flist, struct filter filters[], int CurrNest){
   int Flist_size = 0;
   /*
   printf("add_node:\n");
@@ -215,7 +215,7 @@ void sbintree::add_node(struct stnode *prnt, int lev, int dir, unsigned int addr
 
   double temp;
   int path;
-  unsigned int addr0, addr1;
+  uint128_t addr0, addr1;
   int lev1;
 
   // If list is empty, return
@@ -231,19 +231,19 @@ void sbintree::add_node(struct stnode *prnt, int lev, int dir, unsigned int addr
     if (lev == 0) {
       addr0 = 0;
       addr1 = 1;
-      addr1 = addr1 << 31;
+      addr1 = addr1 << 127;
     } else {
-      addr0 = addr >> (32 - lev);
-      addr0 = addr0 << (32 - lev);
-      addr1 = addr >> (32 - lev);
+      addr0 = addr >> (128 - lev);
+      addr0 = addr0 << (128 - lev);
+      addr1 = addr >> (128 - lev);
       addr1 = addr1 << 1;
       addr1 += 1;
-      addr1 = addr1 << (31 - lev);
+      addr1 = addr1 << (127 - lev);
     }
     // If at the nesting threshold and list has more than one child,
     //   then split list (allocate all nodes with level == lev1 to one path)
     // printf("lev = %d, MyNest = %d, Nest = %d, lev1_flag = %d\n",lev,MyNest,Nest,lev1_flag);
-    if ((Flist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 31)){
+    if ((Flist_size > 1) && (MyNest >= Nest - 1) && (lev1_flag == 1) && (lev < 127)){
       // Allocate nest_list
       dlist *nest_list = new dlist();
       dlist *other_list = new dlist();
diff --git a/sbintree.h b/sbintree.h
index b085696..937d941 100644
--- a/sbintree.h
+++ b/sbintree.h
@@ -31,7 +31,7 @@ class sbintree {
   float *p1child; // probability that a node at a given level has one child
   float *p2child; // probability that a node at a given level has two children
   int num_stnodes; // number of tree nodes 
-  void add_node(struct stnode *prnt, int lev, int dir, unsigned int addr, dlist* Flist, struct filter filters[], int CurrNest);
+  void add_node(struct stnode *prnt, int lev, int dir, uint128_t addr, dlist* Flist, struct filter filters[], int CurrNest);
   int Nest; // Maximum allowed nesting
  public:
   sbintree();
diff --git a/stdinc.h b/stdinc.h
index f566e0f..f731846 100644
--- a/stdinc.h
+++ b/stdinc.h
@@ -10,6 +10,7 @@
 #include <string.h>
 #include <strings.h>
 #include <math.h>
+#include "uint128_t.h"
 
 typedef char bit;
 // const int false = 0;
@@ -24,7 +25,7 @@ inline double max(double x, double y) { return x > y ? x : y; }
 inline int min(int x, int y) { return x < y ? x : y; }
 inline double min(double x, double y) { return x < y ? x : y; }
 inline int abs(int x) { return x < 0 ? -x : x; }
-inline bit isdigit(int c) { return (c >= '0') && (c <= '9'); }
+// inline bit isdigit(int c) { return (c >= '0') && (c <= '9'); }
 
 inline void warning(char* p) { fprintf(stderr,"Warning:%s \n",p); }
 inline void fatal(char* string) {fprintf(stderr,"Fatal:%s\n",string); exit(1); }
@@ -49,15 +50,15 @@ inline int randgeo(double p) { return int(.999999 + log(randfrac())/log(1-p)); }
 
 // Filter database stuff
 
-#define ADDRLEN 32 // IPv4 
+extern int ADDRLEN; // set in db_generator.cc
 #define ADDRBYTES ADDRLEN/8
 #define MAXFILTERS 130000
 #define MAXSTR 100
 // #define NULL 0
 
 struct filter {
-  unsigned sa; // IP source address
-  unsigned da; // IP destination address
+  uint128_t sa; // IP source address
+  uint128_t da; // IP destination address
   int sa_len; // IP source address mask length
   int da_len; // IP destination address mask length
   int sp[2]; // Transport source port range [low,high]
diff --git a/uint128_t.cc b/uint128_t.cc
new file mode 100644
index 0000000..1e16bbd
--- /dev/null
+++ b/uint128_t.cc
@@ -0,0 +1,372 @@
+#include "uint128_t.h"
+
+const uint128_t uint128_0(0);
+const uint128_t uint128_1(1);
+const uint128_t uint128_64(64);
+const uint128_t uint128_128(128);
+
+uint128_t::uint128_t(){
+    UPPER = 0;
+    LOWER = 0;
+}
+
+uint128_t::uint128_t(const uint128_t & rhs){
+    UPPER = rhs.UPPER;
+    LOWER = rhs.LOWER;
+}
+
+uint128_t uint128_t::operator=(const uint128_t & rhs){
+    UPPER = rhs.UPPER;
+    LOWER = rhs.LOWER;
+    return *this;
+}
+
+uint128_t::operator bool() const{
+    return (bool) (UPPER | LOWER);
+}
+
+uint128_t::operator char() const{
+    return (char) LOWER;
+}
+uint128_t::operator int() const{
+    return (int) LOWER;
+}
+
+uint128_t::operator uint8_t() const{
+    return (uint8_t) LOWER;
+}
+
+uint128_t::operator uint16_t() const{
+    return (uint16_t) LOWER;
+}
+
+uint128_t::operator uint32_t() const{
+    return (uint32_t) LOWER;
+}
+
+uint128_t::operator uint64_t() const{
+    return (uint64_t) LOWER;
+}
+
+uint128_t uint128_t::operator&(const uint128_t & rhs) const{
+return uint128_t(UPPER & rhs.UPPER, LOWER & rhs.LOWER);
+}
+
+uint128_t uint128_t::operator|(const uint128_t & rhs) const{
+    return uint128_t(UPPER | rhs.UPPER, LOWER | rhs.LOWER);
+}
+
+uint128_t uint128_t::operator^(const uint128_t & rhs) const{
+    return uint128_t(UPPER ^ rhs.UPPER, LOWER ^ rhs.LOWER);
+}
+
+uint128_t uint128_t::operator&=(const uint128_t & rhs){
+    UPPER &= rhs.UPPER;
+    LOWER &= rhs.LOWER;
+    return *this;
+}
+
+uint128_t uint128_t::operator|=(const uint128_t & rhs){
+    UPPER |= rhs.UPPER;
+    LOWER |= rhs.LOWER;
+    return *this;
+}
+
+uint128_t uint128_t::operator^=(const uint128_t & rhs){
+    UPPER ^= rhs.UPPER;
+    LOWER ^= rhs.LOWER;
+    return *this;
+}
+
+uint128_t uint128_t::operator~() const{
+    return uint128_t(~UPPER, ~LOWER);
+}
+
+uint128_t uint128_t::operator<<(const uint128_t & rhs) const{
+    uint64_t shift = rhs.LOWER;
+    if (((bool) rhs.UPPER) || (shift >= 128)){
+        return uint128_0;
+    }
+    else if (shift == 64){
+        return uint128_t(LOWER, 0);
+    }
+    else if (shift == 0){
+        return *this;
+    }
+    else if (shift < 64){
+        return uint128_t((UPPER << shift) + (LOWER >> (64 - shift)), LOWER << shift);
+    }
+    else if ((128 > shift) && (shift > 64)){
+        return uint128_t(LOWER << (shift - 64), 0);
+    }
+    else{
+        return uint128_0;
+    }
+}
+
+uint128_t uint128_t::operator>>(const uint128_t & rhs) const{
+    uint64_t shift = rhs.LOWER;
+    if (((bool) rhs.UPPER) || (shift >= 128)){
+        return uint128_0;
+    }
+    else if (shift == 64){
+        return uint128_t(0, UPPER);
+    }
+    else if (shift == 0){
+        return *this;
+    }
+    else if (shift < 64){
+        return uint128_t(UPPER >> shift, (UPPER << (64 - shift)) + (LOWER >> shift));
+    }
+    else if ((128 > shift) && (shift > 64)){
+        return uint128_t(0, (UPPER >> (shift - 64)));
+    }
+    else{
+        return uint128_0;
+    }
+}
+
+uint128_t uint128_t::operator<<=(const uint128_t & rhs){
+    *this = *this << rhs;
+    return *this;
+}
+
+uint128_t uint128_t::operator>>=(const uint128_t & rhs){
+    *this = *this >> rhs;
+    return *this;
+}
+
+bool uint128_t::operator!() const{
+    return !(bool) (UPPER | LOWER);
+}
+
+bool uint128_t::operator&&(const uint128_t & rhs) const{
+    return ((bool) *this && rhs);
+}
+
+bool uint128_t::operator||(const uint128_t & rhs) const{
+     return ((bool) *this || rhs);
+}
+
+bool uint128_t::operator==(const uint128_t & rhs) const{
+    return ((UPPER == rhs.UPPER) && (LOWER == rhs.LOWER));
+}
+
+bool uint128_t::operator!=(const uint128_t & rhs) const{
+    return ((UPPER != rhs.UPPER) | (LOWER != rhs.LOWER));
+}
+
+bool uint128_t::operator>(const uint128_t & rhs) const{
+    if (UPPER == rhs.UPPER){
+        return (LOWER > rhs.LOWER);
+    }
+    return (UPPER > rhs.UPPER);
+}
+
+bool uint128_t::operator<(const uint128_t & rhs) const{
+    if (UPPER == rhs.UPPER){
+        return (LOWER < rhs.LOWER);
+    }
+    return (UPPER < rhs.UPPER);
+}
+
+bool uint128_t::operator>=(const uint128_t & rhs) const{
+    return ((*this > rhs) | (*this == rhs));
+}
+
+bool uint128_t::operator<=(const uint128_t & rhs) const{
+    return ((*this < rhs) | (*this == rhs));
+}
+
+uint128_t uint128_t::operator+(const uint128_t & rhs) const{
+    return uint128_t(UPPER + rhs.UPPER + ((LOWER + rhs.LOWER) < LOWER), LOWER + rhs.LOWER);
+}
+
+uint128_t uint128_t::operator+=(const uint128_t & rhs){
+    UPPER = rhs.UPPER + UPPER + ((LOWER + rhs.LOWER) < LOWER);
+    LOWER += rhs.LOWER;
+    return *this;
+}
+
+uint128_t uint128_t::operator-(const uint128_t & rhs) const{
+    return uint128_t(UPPER - rhs.UPPER - ((LOWER - rhs.LOWER) > LOWER), LOWER - rhs.LOWER);
+}
+
+uint128_t uint128_t::operator-=(const uint128_t & rhs){
+    *this = *this - rhs;
+    return *this;
+}
+
+uint128_t uint128_t::operator*(const uint128_t & rhs) const{
+    // split values into 4 32-bit parts
+    uint64_t top[4] ={UPPER >> 32, UPPER & 0xffffffff, LOWER >> 32, LOWER & 0xffffffff};
+    uint64_t bottom[4] ={rhs.UPPER >> 32, rhs.UPPER & 0xffffffff, rhs.LOWER >> 32, rhs.LOWER & 0xffffffff};
+    uint64_t products[4][4];
+
+    for(int y = 3; y > -1; y--){
+        for(int x = 3; x > -1; x--){
+            products[3 - x][y] = top[x] * bottom[y];
+        }
+    }
+
+    // initial row
+    uint64_t fourth32 = products[0][3] & 0xffffffff;
+    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
+    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
+    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);
+
+    // second row
+    third32 += products[1][3] & 0xffffffff;
+    second32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
+    first32 += (products[1][1] & 0xffffffff) + (products[1][2] >> 32);
+
+    // third row
+    second32 += products[2][3] & 0xffffffff;
+    first32 += (products[2][2] & 0xffffffff) + (products[2][3] >> 32);
+
+    // fourth row
+    first32 += products[3][3] & 0xffffffff;
+
+    // combines the values, taking care of carry over
+    return uint128_t(first32 << 32, 0) + uint128_t(third32 >> 32, third32 << 32) + uint128_t(second32, 0) + uint128_t(fourth32);
+}
+
+uint128_t uint128_t::operator*=(const uint128_t & rhs){
+    *this = *this * rhs;
+    return *this;
+}
+
+std::pair <uint128_t, uint128_t> uint128_t::divmod(const uint128_t & lhs, const uint128_t & rhs) const{
+    // Save some calculations /////////////////////
+    if (rhs == uint128_0){
+        throw std::runtime_error("Error: division or modulus by 0");
+    }
+    else if (rhs == uint128_1){
+        return std::pair <uint128_t, uint128_t> (lhs, uint128_0);
+    }
+    else if (lhs == rhs){
+        return std::pair <uint128_t, uint128_t> (uint128_1, uint128_0);
+    }
+    else if ((lhs == uint128_0) || (lhs < rhs)){
+        return std::pair <uint128_t, uint128_t> (uint128_0, lhs);
+    }
+
+    std::pair <uint128_t, uint128_t> qr(uint128_0, lhs);
+    uint128_t copyd = rhs << (lhs.bits() - rhs.bits());
+    uint128_t adder = uint128_1 << (lhs.bits() - rhs.bits());
+    if (copyd > qr.second){
+        copyd >>= uint128_1;
+        adder >>= uint128_1;
+    }
+    while (qr.second >= rhs){
+        if (qr.second >= copyd){
+            qr.second -= copyd;
+            qr.first |= adder;
+        }
+        copyd >>= uint128_1;
+        adder >>= uint128_1;
+    }
+    return qr;
+}
+
+uint128_t uint128_t::operator/(const uint128_t & rhs) const{
+    return divmod(*this, rhs).first;
+}
+
+uint128_t uint128_t::operator/=(const uint128_t & rhs){
+    *this = *this / rhs;
+    return *this;
+}
+
+uint128_t uint128_t::operator%(const uint128_t & rhs) const{
+    return *this - (rhs * (*this / rhs));
+}
+
+uint128_t uint128_t::operator%=(const uint128_t & rhs){
+    *this = *this % rhs;
+    return *this;
+}
+
+uint128_t uint128_t::operator++(){
+    *this += uint128_1;
+    return *this;
+}
+
+uint128_t uint128_t::operator++(int){
+    uint128_t temp(*this);
+    ++*this;
+    return temp;
+}
+
+uint128_t uint128_t::operator--(){
+    *this -= uint128_1;
+    return *this;
+}
+
+uint128_t uint128_t::operator--(int){
+    uint128_t temp(*this);
+    --*this;
+    return temp;
+}
+
+uint64_t uint128_t::upper() const{
+    return UPPER;
+}
+
+uint64_t uint128_t::lower() const{
+    return LOWER;
+}
+
+uint8_t uint128_t::bits() const{
+    uint8_t out = 0;
+    if (UPPER){
+        out = 64;
+        uint64_t up = UPPER;
+        while (up){
+            up >>= 1;
+            out++;
+        }
+    }
+    else{
+        uint64_t low = LOWER;
+        while (low){
+            low >>= 1;
+            out++;
+        }
+    }
+    return out;
+}
+
+std::string uint128_t::str(uint8_t base, const unsigned int & len) const{
+    if ((base < 2) || (base > 16)){
+        throw std::invalid_argument("Base must be in th range 2-16");
+    }
+    std::string out = "";
+    if (!(*this)){
+        out = "0";
+    }
+    else{
+        std::pair <uint128_t, uint128_t> qr(*this, uint128_0);
+        do{
+            qr = divmod(qr.first, base);
+            out = "0123456789abcdef"[(uint8_t) qr.second] + out;
+        } while (qr.first);
+    }
+    if (out.size() < len){
+        out = std::string(len - out.size(), '0') + out;
+    }
+    return out;
+}
+
+std::ostream & operator<<(std::ostream & stream, const uint128_t & rhs){
+    if (stream.flags() & stream.oct){
+        stream << rhs.str(8);
+    }
+    else if (stream.flags() & stream.dec){
+        stream << rhs.str(10);
+    }
+    else if (stream.flags() & stream.hex){
+        stream << rhs.str(16);
+    }
+    return stream;
+}
diff --git a/uint128_t.h b/uint128_t.h
new file mode 100644
index 0000000..7da340a
--- /dev/null
+++ b/uint128_t.h
@@ -0,0 +1,384 @@
+/*
+uint128_t.h
+An unsigned 128 bit integer type for C++
+Copyright (c) 2014 Jason Lee @ calccrypto at gmail.com
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+With much help from Auston Sterling
+
+Thanks to Stefan Deigmller for finding
+a bug in operator*.
+
+Thanks to Franois Dessenne for convincing me
+to do a general rewrite of this class.
+*/
+
+#ifndef __UINT128_T__
+#define __UINT128_T__
+
+#include <iostream>
+#include <stdexcept>
+#include <stdint.h>
+#include <utility>
+
+class uint128_t{
+    private:
+        uint64_t UPPER, LOWER;
+
+    public:
+        // Constructors
+        uint128_t();
+        uint128_t(const uint128_t & rhs);
+
+        template <typename T> uint128_t(const T & rhs){
+            UPPER = 0;
+            LOWER = rhs;
+        }
+
+        template <typename S, typename T> uint128_t(const S & upper_rhs, const T & lower_rhs){
+            UPPER = upper_rhs;
+            LOWER = lower_rhs;
+        }
+
+        //  RHS input args only
+
+        // Assignment Operator
+        uint128_t operator=(const uint128_t & rhs);
+
+        template <typename T> uint128_t operator=(const T & rhs){
+            UPPER = 0;
+            LOWER = rhs;
+            return *this;
+        }
+
+        // Typecast Operators
+        operator bool() const;
+        operator char() const;
+        operator int() const;
+        operator uint8_t() const;
+        operator uint16_t() const;
+        operator uint32_t() const;
+        operator uint64_t() const;
+
+        // Bitwise Operators
+        uint128_t operator&(const uint128_t & rhs) const;
+        uint128_t operator|(const uint128_t & rhs) const;
+        uint128_t operator^(const uint128_t & rhs) const;
+        uint128_t operator&=(const uint128_t & rhs);
+        uint128_t operator|=(const uint128_t & rhs);
+        uint128_t operator^=(const uint128_t & rhs);
+        uint128_t operator~() const;
+
+        template <typename T> uint128_t operator&(const T & rhs) const{
+            return uint128_t(0, LOWER & (uint64_t) rhs);
+        }
+
+        template <typename T> uint128_t operator|(const T & rhs) const{
+            return uint128_t(UPPER, LOWER | (uint64_t) rhs);
+        }
+
+        template <typename T> uint128_t operator^(const T & rhs) const{
+            return uint128_t(UPPER, LOWER ^ (uint64_t) rhs);
+        }
+
+        template <typename T> uint128_t operator&=(const T & rhs){
+            UPPER = 0;
+            LOWER &= rhs;
+            return *this;
+        }
+
+        template <typename T> uint128_t operator|=(const T & rhs){
+            LOWER |= (uint64_t) rhs;
+            return *this;
+        }
+
+        template <typename T> uint128_t operator^=(const T & rhs){
+            LOWER ^= (uint64_t) rhs;
+            return *this;
+        }
+
+        // Bit Shift Operators
+        uint128_t operator<<(const uint128_t & rhs) const;
+        uint128_t operator>>(const uint128_t & rhs) const;
+        uint128_t operator<<=(const uint128_t & rhs);
+        uint128_t operator>>=(const uint128_t & rhs);
+
+        template <typename T>uint128_t operator<<(const T & rhs) const{
+            return *this << uint128_t(rhs);
+        }
+
+        template <typename T>uint128_t operator>>(const T & rhs) const{
+            return *this >> uint128_t(rhs);
+        }
+
+        template <typename T>uint128_t operator<<=(const T & rhs){
+            *this = *this << uint128_t(rhs);
+            return *this;
+        }
+
+        template <typename T>uint128_t operator>>=(const T & rhs){
+            *this = *this >> uint128_t(rhs);
+            return *this;
+        }
+
+        // Logical Operators
+        bool operator!() const;
+        bool operator&&(const uint128_t & rhs) const;
+        bool operator||(const uint128_t & rhs) const;
+
+        template <typename T> bool operator&&(const T & rhs){
+            return ((bool) *this && rhs);
+        }
+
+        template <typename T> bool operator||(const T & rhs){
+            return ((bool) *this || rhs);
+        }
+
+        // Comparison Operators
+        bool operator==(const uint128_t & rhs) const;
+        bool operator!=(const uint128_t & rhs) const;
+        bool operator>(const uint128_t & rhs) const;
+        bool operator<(const uint128_t & rhs) const;
+        bool operator>=(const uint128_t & rhs) const;
+        bool operator<=(const uint128_t & rhs) const;
+
+        template <typename T> bool operator==(const T & rhs) const{
+            return (!UPPER && (LOWER == (uint64_t) rhs));
+        }
+
+        template <typename T> bool operator!=(const T & rhs) const{
+            return (UPPER | (LOWER != (uint64_t) rhs));
+        }
+
+        template <typename T> bool operator>(const T & rhs) const{
+            return (UPPER || (LOWER > (uint64_t) rhs));
+        }
+
+        template <typename T> bool operator<(const T & rhs) const{
+            return (!UPPER)?(LOWER < (uint64_t) rhs):false;
+        }
+
+        template <typename T> bool operator>=(const T & rhs) const{
+            return ((*this > rhs) | (*this == rhs));
+        }
+
+        template <typename T> bool operator<=(const T & rhs) const{
+            return ((*this < rhs) | (*this == rhs));
+        }
+
+        // Arithmetic Operators
+        uint128_t operator+(const uint128_t & rhs) const;
+        uint128_t operator+=(const uint128_t & rhs);
+        uint128_t operator-(const uint128_t & rhs) const;
+        uint128_t operator-=(const uint128_t & rhs);
+        uint128_t operator*(const uint128_t & rhs) const;
+        uint128_t operator*=(const uint128_t & rhs);
+
+    private:
+        std::pair <uint128_t, uint128_t> divmod(const uint128_t & lhs, const uint128_t & rhs) const;
+
+    public:
+		uint128_t operator/(const uint128_t & rhs) const;
+        uint128_t operator/=(const uint128_t & rhs);
+        uint128_t operator%(const uint128_t & rhs) const;
+        uint128_t operator%=(const uint128_t & rhs);
+
+        template <typename T> uint128_t operator+(const T & rhs) const{
+            return uint128_t(UPPER + ((LOWER + (uint64_t) rhs) < LOWER), LOWER + (uint64_t) rhs);
+        }
+
+        template <typename T> uint128_t operator+=(const T & rhs){
+            UPPER = UPPER + ((LOWER + rhs) < LOWER);
+            LOWER = LOWER + rhs;
+            return *this;
+        }
+
+        template <typename T> uint128_t operator-(const T & rhs) const{
+            return uint128_t((uint64_t) (UPPER - ((LOWER - rhs) > LOWER)), (uint64_t) (LOWER - rhs));
+        }
+
+        template <typename T> uint128_t operator-=(const T & rhs){
+            *this = *this - rhs;
+            return *this;
+        }
+
+        template <typename T> uint128_t operator*(const T & rhs) const{
+            return (*this) * (uint128_t(rhs));
+        }
+
+        template <typename T> uint128_t operator*=(const T & rhs){
+            *this = *this * uint128_t(rhs);
+            return *this;
+        }
+
+        template <typename T> uint128_t operator/(const T & rhs) const{
+            return *this / uint128_t(rhs);
+        }
+
+        template <typename T> uint128_t operator/=(const T & rhs){
+            *this = *this / uint128_t(rhs);
+            return *this;
+        }
+
+        template <typename T> uint128_t operator%(const T & rhs) const{
+            return *this - (rhs * (*this / rhs));
+        }
+
+        template <typename T> uint128_t operator%=(const T & rhs){
+            *this = *this % uint128_t(rhs);
+            return *this;
+        }
+
+        // Increment Operator
+        uint128_t operator++();
+        uint128_t operator++(int);
+
+        // Decrement Operator
+        uint128_t operator--();
+        uint128_t operator--(int);
+
+        // Get private values
+        uint64_t upper() const;
+        uint64_t lower() const;
+
+        // Get bitsize of value
+        uint8_t bits() const;
+
+        // Get string representation of value
+        std::string str(uint8_t base = 10, const unsigned int & len = 0) const;
+};
+
+// Useful values
+extern const uint128_t uint128_0;
+extern const uint128_t uint128_1;
+extern const uint128_t uint128_64;
+extern const uint128_t uint128_128;
+
+// lhs type T as first arguemnt
+// If the output is not a bool, casts to type T
+
+// Bitwise Operators
+template <typename T> T operator&(const T & lhs, const uint128_t & rhs){
+    return (T) (lhs & (T) rhs.lower());
+}
+
+template <typename T> T operator|(const T & lhs, const uint128_t & rhs){
+    return (T) (lhs | (T) rhs.lower());
+}
+
+template <typename T> T operator^(const T & lhs, const uint128_t & rhs){
+    return (T) (lhs ^ (T) rhs.lower());
+}
+
+template <typename T> T operator&=(T & lhs, const uint128_t & rhs){
+    lhs &= (T) rhs.lower(); return lhs;
+}
+
+template <typename T> T operator|=(T & lhs, const uint128_t & rhs){
+    lhs |= (T) rhs.lower(); return lhs;
+}
+
+template <typename T> T operator^=(T & lhs, const uint128_t & rhs){
+    lhs ^= (T) rhs.lower(); return lhs;
+}
+
+// Comparison Operators
+template <typename T> bool operator==(const T & lhs, const uint128_t & rhs){
+    return (!rhs.upper() && ((uint64_t) lhs == rhs.lower()));
+}
+
+template <typename T> bool operator!=(const T & lhs, const uint128_t & rhs){
+    return (rhs.upper() | ((uint64_t) lhs != rhs.lower()));
+}
+
+template <typename T> bool operator>(const T & lhs, const uint128_t & rhs){
+    return (!rhs.upper()) && ((uint64_t) lhs > rhs.lower());
+}
+
+template <typename T> bool operator<(const T & lhs, const uint128_t & rhs){
+    if (rhs.upper()){
+        return true;
+    }
+    return ((uint64_t) lhs < rhs.lower());
+}
+
+template <typename T> bool operator>=(const T & lhs, const uint128_t & rhs){
+    if (rhs.upper()){
+            return false;
+    }
+    return ((uint64_t) lhs >= rhs.lower());
+}
+
+template <typename T> bool operator<=(const T & lhs, const uint128_t & rhs){
+    if (rhs.upper()){
+            return true;
+    }
+    return ((uint64_t) lhs <= rhs.lower());
+}
+
+// Arithmetic Operators
+template <typename T> T operator+(const T & lhs, const uint128_t & rhs){
+    return (T) (rhs + lhs);
+}
+
+template <typename T> T & operator+=(T & lhs, const uint128_t & rhs){
+    lhs = (T) (rhs + lhs);
+    return lhs;
+}
+
+template <typename T> T operator-(const T & lhs, const uint128_t & rhs){
+    return (T) (uint128_t(lhs) - rhs);
+}
+
+template <typename T> T & operator-=(T & lhs, const uint128_t & rhs){
+    lhs = (T) (uint128_t(lhs) - rhs);
+    return lhs;
+}
+
+template <typename T> T operator*(const T & lhs, const uint128_t & rhs){
+    return lhs * (T) rhs.lower();
+}
+
+template <typename T> T & operator*=(T & lhs, const uint128_t & rhs){
+    lhs *= (T) rhs.lower();
+    return lhs;
+}
+
+template <typename T> T operator/(const T & lhs, const uint128_t & rhs){
+    return (T) (uint128_t(lhs) / rhs);
+}
+
+template <typename T> T & operator/=(T & lhs, const uint128_t & rhs){
+    lhs = (T) (uint128_t(lhs) / rhs);
+    return lhs;
+}
+
+template <typename T> T operator%(const T & lhs, const uint128_t & rhs){
+    return (T) (uint128_t(lhs) % rhs);
+}
+
+template <typename T> T & operator%=(T & lhs, const uint128_t & rhs){
+    lhs = (T) (uint128_t(lhs) % rhs);
+    return lhs;
+}
+
+// IO Operator
+std::ostream & operator<<(std::ostream & stream, const uint128_t & rhs);
+#endif
